{"version":3,"file":"sidepanel-D3PqM2Vx.js","sources":["../../../../../node_modules/.bun/lucide-react@0.554.0+83d5fd7b249dbeef/node_modules/lucide-react/dist/esm/icons/brain.js","../../../../../node_modules/.bun/lucide-react@0.554.0+83d5fd7b249dbeef/node_modules/lucide-react/dist/esm/icons/circle-dashed.js","../../../../../node_modules/.bun/lucide-react@0.554.0+83d5fd7b249dbeef/node_modules/lucide-react/dist/esm/icons/github.js","../../../../../node_modules/.bun/lucide-react@0.554.0+83d5fd7b249dbeef/node_modules/lucide-react/dist/esm/icons/square-stop.js","../../../../../node_modules/.bun/lucide-react@0.554.0+83d5fd7b249dbeef/node_modules/lucide-react/dist/esm/icons/thumbs-down.js","../../../../../node_modules/.bun/lucide-react@0.554.0+83d5fd7b249dbeef/node_modules/lucide-react/dist/esm/icons/thumbs-up.js","../../../lib/jtbd-popup/constants.ts","../../../lib/jtbd-popup/use-jtbd-popup.ts","../../../entrypoints/sidepanel/index/chatTypes.ts","../../../entrypoints/sidepanel/index/ChatEmptyState.tsx","../../../entrypoints/sidepanel/index/ChatError.tsx","../../../entrypoints/sidepanel/index/ChatAttachedTabs.tsx","../../../components/elements/tab-mention-popover.tsx","../../../entrypoints/sidepanel/index/ChatInput.tsx","../../../entrypoints/sidepanel/index/ChatModeToggle.tsx","../../../entrypoints/sidepanel/index/ChatFooter.tsx","../../../entrypoints/sidepanel/index/ChatProviderSelector.tsx","../../../entrypoints/sidepanel/index/ChatHeader.tsx","../../../../../node_modules/.bun/use-stick-to-bottom@1.1.1+83d5fd7b249dbeef/node_modules/use-stick-to-bottom/dist/useStickToBottom.js","../../../../../node_modules/.bun/use-stick-to-bottom@1.1.1+83d5fd7b249dbeef/node_modules/use-stick-to-bottom/dist/StickToBottom.js","../../../components/ai-elements/conversation.tsx","../../../components/ai-elements/shimmer.tsx","../../../components/ai-elements/reasoning.tsx","../../../entrypoints/sidepanel/index/ChatMessageActions.tsx","../../../entrypoints/sidepanel/index/getMessageSegments.ts","../../../entrypoints/sidepanel/index/JtbdPopup.tsx","../../../components/ai-elements/task.tsx","../../../entrypoints/sidepanel/index/ToolBatch.tsx","../../../entrypoints/sidepanel/index/UserActionMessage.tsx","../../../entrypoints/sidepanel/index/ChatMessages.tsx","../../../../../node_modules/.bun/@ai-sdk+provider@2.0.0/node_modules/@ai-sdk/provider/dist/index.mjs","../../../../../node_modules/.bun/eventsource-parser@3.0.6/node_modules/eventsource-parser/dist/index.js","../../../../../node_modules/.bun/eventsource-parser@3.0.6/node_modules/eventsource-parser/dist/stream.js","../../../../../node_modules/.bun/@ai-sdk+provider-utils@3.0.19+68156bc0b5d50bb8/node_modules/@ai-sdk/provider-utils/dist/index.mjs","../../../../../node_modules/.bun/ai@5.0.116+68156bc0b5d50bb8/node_modules/ai/dist/index.mjs","../../../../../node_modules/.bun/throttleit@2.1.0/node_modules/throttleit/index.js","../../../../../node_modules/.bun/@ai-sdk+react@2.0.118+6d04a7f92303fe3c/node_modules/@ai-sdk/react/dist/index.mjs","../../../../../node_modules/.bun/dequal@2.0.3/node_modules/dequal/dist/index.mjs","../../../../../node_modules/.bun/use-deep-compare-effect@1.8.1+83d5fd7b249dbeef/node_modules/use-deep-compare-effect/dist/use-deep-compare-effect.esm.js","../../../lib/search-actions/searchActionsStorage.ts","../../../entrypoints/sidepanel/index/useNotifyActiveTab.tsx","../../../entrypoints/sidepanel/index/useChatSession.ts","../../../entrypoints/sidepanel/index/Chat.tsx","../../../entrypoints/sidepanel/App.tsx","../../../entrypoints/sidepanel/main.tsx"],"sourcesContent":["/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M12 18V5\", key: \"adv99a\" }],\n  [\"path\", { d: \"M15 13a4.17 4.17 0 0 1-3-4 4.17 4.17 0 0 1-3 4\", key: \"1e3is1\" }],\n  [\"path\", { d: \"M17.598 6.5A3 3 0 1 0 12 5a3 3 0 1 0-5.598 1.5\", key: \"1gqd8o\" }],\n  [\"path\", { d: \"M17.997 5.125a4 4 0 0 1 2.526 5.77\", key: \"iwvgf7\" }],\n  [\"path\", { d: \"M18 18a4 4 0 0 0 2-7.464\", key: \"efp6ie\" }],\n  [\"path\", { d: \"M19.967 17.483A4 4 0 1 1 12 18a4 4 0 1 1-7.967-.517\", key: \"1gq6am\" }],\n  [\"path\", { d: \"M6 18a4 4 0 0 1-2-7.464\", key: \"k1g0md\" }],\n  [\"path\", { d: \"M6.003 5.125a4 4 0 0 0-2.526 5.77\", key: \"q97ue3\" }]\n];\nconst Brain = createLucideIcon(\"brain\", __iconNode);\n\nexport { __iconNode, Brain as default };\n//# sourceMappingURL=brain.js.map\n","/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M10.1 2.182a10 10 0 0 1 3.8 0\", key: \"5ilxe3\" }],\n  [\"path\", { d: \"M13.9 21.818a10 10 0 0 1-3.8 0\", key: \"11zvb9\" }],\n  [\"path\", { d: \"M17.609 3.721a10 10 0 0 1 2.69 2.7\", key: \"1iw5b2\" }],\n  [\"path\", { d: \"M2.182 13.9a10 10 0 0 1 0-3.8\", key: \"c0bmvh\" }],\n  [\"path\", { d: \"M20.279 17.609a10 10 0 0 1-2.7 2.69\", key: \"1ruxm7\" }],\n  [\"path\", { d: \"M21.818 10.1a10 10 0 0 1 0 3.8\", key: \"qkgqxc\" }],\n  [\"path\", { d: \"M3.721 6.391a10 10 0 0 1 2.7-2.69\", key: \"1mcia2\" }],\n  [\"path\", { d: \"M6.391 20.279a10 10 0 0 1-2.69-2.7\", key: \"1fvljs\" }]\n];\nconst CircleDashed = createLucideIcon(\"circle-dashed\", __iconNode);\n\nexport { __iconNode, CircleDashed as default };\n//# sourceMappingURL=circle-dashed.js.map\n","/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\n    \"path\",\n    {\n      d: \"M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4\",\n      key: \"tonef\"\n    }\n  ],\n  [\"path\", { d: \"M9 18c-4.51 2-5-2-7-2\", key: \"9comsn\" }]\n];\nconst Github = createLucideIcon(\"github\", __iconNode);\n\nexport { __iconNode, Github as default };\n//# sourceMappingURL=github.js.map\n","/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"rect\", { width: \"18\", height: \"18\", x: \"3\", y: \"3\", rx: \"2\", key: \"afitv7\" }],\n  [\"rect\", { x: \"9\", y: \"9\", width: \"6\", height: \"6\", rx: \"1\", key: \"1ssd4o\" }]\n];\nconst SquareStop = createLucideIcon(\"square-stop\", __iconNode);\n\nexport { __iconNode, SquareStop as default };\n//# sourceMappingURL=square-stop.js.map\n","/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M17 14V2\", key: \"8ymqnk\" }],\n  [\n    \"path\",\n    {\n      d: \"M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88Z\",\n      key: \"m61m77\"\n    }\n  ]\n];\nconst ThumbsDown = createLucideIcon(\"thumbs-down\", __iconNode);\n\nexport { __iconNode, ThumbsDown as default };\n//# sourceMappingURL=thumbs-down.js.map\n","/**\n * @license lucide-react v0.554.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\n\nimport createLucideIcon from '../createLucideIcon.js';\n\nconst __iconNode = [\n  [\"path\", { d: \"M7 10v12\", key: \"1qc93n\" }],\n  [\n    \"path\",\n    {\n      d: \"M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88Z\",\n      key: \"emmmcr\"\n    }\n  ]\n];\nconst ThumbsUp = createLucideIcon(\"thumbs-up\", __iconNode);\n\nexport { __iconNode, ThumbsUp as default };\n//# sourceMappingURL=thumbs-up.js.map\n","export const JTBD_POPUP_CONSTANTS = {\n  // Show popup after this many messages\n  MESSAGE_THRESHOLD: 15,\n  // Show to 1 in N users (samplingId % N === 0)\n  // Set to 1 to show to everyone\n  SAMPLING_DIVISOR: 1,\n} as const\n","import { useCallback, useEffect, useState } from 'react'\nimport {\n  JTBD_POPUP_CLICKED_EVENT,\n  JTBD_POPUP_DISMISSED_EVENT,\n  JTBD_POPUP_SHOWN_EVENT,\n} from '@/lib/constants/analyticsEvents'\nimport { track } from '@/lib/metrics/track'\nimport { JTBD_POPUP_CONSTANTS } from './constants'\nimport { type JtbdPopupState, jtbdPopupStorage } from './storage'\n\nconst isEligible = (state: JtbdPopupState): boolean => {\n  if (state.surveyTaken) return false\n  if (state.messageCount < JTBD_POPUP_CONSTANTS.MESSAGE_THRESHOLD) return false\n  if (state.messageCount % JTBD_POPUP_CONSTANTS.MESSAGE_THRESHOLD !== 0)\n    return false\n  if (state.samplingId % JTBD_POPUP_CONSTANTS.SAMPLING_DIVISOR !== 0)\n    return false\n  return true\n}\n\nexport function useJtbdPopup() {\n  const [popupVisible, setPopupVisible] = useState(false)\n\n  useEffect(() => {\n    jtbdPopupStorage.getValue().then(async (val) => {\n      if (val.samplingId === -1) {\n        const newVal = { ...val, samplingId: Math.floor(Math.random() * 100) }\n        await jtbdPopupStorage.setValue(newVal)\n      }\n    })\n  }, [])\n\n  const recordMessageSent = useCallback(async () => {\n    const current = await jtbdPopupStorage.getValue()\n    const newState = { ...current, messageCount: current.messageCount + 1 }\n    await jtbdPopupStorage.setValue(newState)\n  }, [])\n\n  const triggerIfEligible = useCallback(async () => {\n    const current = await jtbdPopupStorage.getValue()\n    if (isEligible(current)) {\n      track(JTBD_POPUP_SHOWN_EVENT, { messageCount: current.messageCount })\n      setPopupVisible(true)\n    }\n  }, [])\n\n  const onTakeSurvey = useCallback(async () => {\n    const current = await jtbdPopupStorage.getValue()\n    track(JTBD_POPUP_CLICKED_EVENT, { messageCount: current.messageCount })\n    setPopupVisible(false)\n    window.open('/options.html?page=survey', '_blank')\n  }, [])\n\n  const onDismiss = useCallback(async () => {\n    const current = await jtbdPopupStorage.getValue()\n    track(JTBD_POPUP_DISMISSED_EVENT, { messageCount: current.messageCount })\n    setPopupVisible(false)\n  }, [])\n\n  return {\n    popupVisible,\n    recordMessageSent,\n    triggerIfEligible,\n    onTakeSurvey,\n    onDismiss,\n  }\n}\n","import type { ProviderType } from '@/lib/llm-providers/types'\n\nexport type ChatMode = 'chat' | 'agent'\n\nexport interface Provider {\n  id: string\n  name: string\n  type: ProviderType\n}\n\nexport interface Suggestion {\n  display: string\n  prompt: string\n  icon: string\n}\n\nexport const CHAT_SUGGESTIONS: Suggestion[] = [\n  {\n    display: 'Summarize this page',\n    prompt: 'Read the current tab and summarize it in bullet points',\n    icon: 'âœ¨',\n  },\n  {\n    display: 'What topics does this page talk about?',\n    prompt:\n      'Read the current tab and briefly describe what it is about in 1-2 lines',\n    icon: 'ðŸ”',\n  },\n  {\n    display: 'Extract comments from this page',\n    prompt: 'Read the current tab and extract comments as bullet points',\n    icon: 'ðŸ’¬',\n  },\n]\n\nexport const AGENT_SUGGESTIONS: Suggestion[] = [\n  {\n    display: 'Read about our vision and upvote',\n    prompt:\n      'Go to https://dub.sh/browseros-launch in current tab. Find and click the upvote button',\n    icon: 'â¤ï¸',\n  },\n  {\n    display: 'Support BrowserOS on Github',\n    prompt:\n      'Go to http://git.new/browseros in current tab and star the repository',\n    icon: 'â­',\n  },\n  {\n    display: 'Open amazon.com and order Sensodyne toothpaste',\n    prompt:\n      'Open amazon.com in current tab and add sensodyne toothpaste to cart',\n    icon: 'ðŸ›’',\n  },\n]\n","import { Sparkles } from 'lucide-react'\nimport type { FC } from 'react'\nimport { cn } from '@/lib/utils'\nimport { AGENT_SUGGESTIONS, CHAT_SUGGESTIONS, type ChatMode } from './chatTypes'\n\ninterface ChatEmptyStateProps {\n  mode: ChatMode\n  mounted: boolean\n  onSuggestionClick: (suggestion: string) => void\n}\n\nexport const ChatEmptyState: FC<ChatEmptyStateProps> = ({\n  mode,\n  mounted,\n  onSuggestionClick,\n}) => {\n  const suggestions = mode === 'chat' ? CHAT_SUGGESTIONS : AGENT_SUGGESTIONS\n\n  return (\n    <div\n      className={cn(\n        'm-0! flex h-full flex-col items-center justify-center space-y-4 text-center opacity-0 transition-all duration-700',\n        mounted ? 'translate-y-0 opacity-100' : 'translate-y-4 opacity-0',\n      )}\n    >\n      <div className=\"mb-2 flex h-14 w-14 items-center justify-center rounded-2xl bg-muted/50\">\n        <Sparkles className=\"h-7 w-7 text-[var(--accent-orange)]\" />\n      </div>\n      <div>\n        <h2 className=\"mb-1 font-semibold text-lg\">\n          {mode === 'chat' ? 'Chat with this page' : 'Agent at your service'}\n        </h2>\n        <p className=\"max-w-[200px] text-muted-foreground text-xs\">\n          {mode === 'chat'\n            ? 'Ask questions about the current page or any topic'\n            : 'Let AI automate tasks and browse for you'}\n        </p>\n      </div>\n\n      <div className=\"mt-6 grid w-full max-w-[260px] grid-cols-1 gap-2\">\n        {suggestions.map((suggestion) => (\n          <button\n            type=\"button\"\n            key={suggestion.display}\n            onClick={() => onSuggestionClick(suggestion.prompt)}\n            className=\"group flex items-center justify-between rounded-lg border border-border/50 bg-card px-3 py-2.5 text-left text-xs transition-all duration-200 hover:border-[var(--accent-orange)]/50 hover:bg-[var(--accent-orange)]/5\"\n          >\n            {suggestion.display}\n            <span className=\"opacity-0 transition-opacity duration-200 group-hover:opacity-100\">\n              {suggestion.icon}\n            </span>\n          </button>\n        ))}\n      </div>\n    </div>\n  )\n}\n","import { AlertCircle, RefreshCw } from 'lucide-react'\nimport type { FC } from 'react'\nimport { Button } from '@/components/ui/button'\n\ninterface ChatErrorProps {\n  error: Error\n  onRetry?: () => void\n}\n\nfunction parseErrorMessage(message: string): {\n  text: string\n  url?: string\n  isRateLimit?: boolean\n} {\n  // Detect BrowserOS rate limit (unique pattern, no provider uses this)\n  if (message.includes('BrowserOS LLM daily limit reached')) {\n    return {\n      text: 'Add your own API key for unlimited usage.',\n      url: 'https://dub.sh/browseros-usage-limit',\n      isRateLimit: true,\n    }\n  }\n\n  let text = message\n  try {\n    const parsed = JSON.parse(message)\n    if (parsed?.error?.message) text = parsed.error.message\n  } catch {}\n\n  // Extract URL if present\n  const urlMatch = text.match(/https?:\\/\\/[^\\s]+/)\n  const url = urlMatch?.[0]\n  if (url) {\n    text = text.replace(url, '').replace(/\\s+/g, ' ').trim()\n  }\n\n  return { text: text || 'An unexpected error occurred', url }\n}\n\nexport const ChatError: FC<ChatErrorProps> = ({ error, onRetry }) => {\n  const { text, url, isRateLimit } = parseErrorMessage(error.message)\n\n  return (\n    <div className=\"mx-4 flex flex-col items-center justify-center gap-3 rounded-lg border border-destructive/30 bg-destructive/5 p-4\">\n      <div className=\"flex items-center gap-2 text-muted-foreground\">\n        <AlertCircle className=\"h-5 w-5\" />\n        <span className=\"font-medium text-sm\">\n          {isRateLimit ? 'Daily limit reached' : 'Something went wrong'}\n        </span>\n      </div>\n      <p className=\"text-center text-destructive text-xs\">{text}</p>\n      {isRateLimit && (\n        <p className=\"text-muted-foreground text-xs\">\n          <a\n            href={url}\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            className=\"underline hover:text-foreground\"\n          >\n            Learn more\n          </a>\n          {' or '}\n          <a\n            href=\"/options.html?page=survey\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            className=\"underline hover:text-foreground\"\n          >\n            take a quick survey\n          </a>\n        </p>\n      )}\n      {onRetry && (\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={onRetry}\n          className=\"mt-1 gap-2\"\n        >\n          <RefreshCw className=\"h-3.5 w-3.5\" />\n          Try again\n        </Button>\n      )}\n    </div>\n  )\n}\n","import { Globe, X } from 'lucide-react'\nimport type { FC } from 'react'\n\ninterface ChatAttachedTabsProps {\n  tabs: chrome.tabs.Tab[]\n  onRemoveTab: (tabId?: number) => void\n}\n\nexport const ChatAttachedTabs: FC<ChatAttachedTabsProps> = ({\n  tabs,\n  onRemoveTab,\n}) => {\n  if (tabs.length === 0) return null\n\n  return (\n    <div className=\"px-3 pt-2\">\n      <div className=\"styled-scrollbar flex items-center gap-2 overflow-x-auto pb-1\">\n        {tabs.map((tab) => (\n          <div\n            key={tab.id}\n            className=\"flex min-w-0 max-w-[200px] flex-shrink-0 items-center gap-1.5 rounded-lg border border-border bg-accent/50 px-2 py-1.5\"\n          >\n            <div className=\"flex h-4 w-4 flex-shrink-0 items-center justify-center rounded border border-border bg-background\">\n              {tab.favIconUrl ? (\n                <img src={tab.favIconUrl} alt=\"\" className=\"h-3 w-3\" />\n              ) : (\n                <Globe className=\"h-3 w-3 text-muted-foreground\" />\n              )}\n            </div>\n            <div className=\"flex-1 truncate font-medium text-foreground text-xs\">\n              {tab.title}\n            </div>\n            <button\n              type=\"button\"\n              onClick={() => onRemoveTab(tab.id)}\n              className=\"flex-shrink-0 rounded p-0.5 transition-colors hover:bg-background\"\n              title=\"Remove tab\"\n            >\n              <X className=\"h-3 w-3 text-muted-foreground\" />\n            </button>\n          </div>\n        ))}\n      </div>\n    </div>\n  )\n}\n","import type * as React from 'react'\nimport type { FC } from 'react'\nimport { useEffect, useMemo, useRef, useState } from 'react'\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command'\nimport { Popover, PopoverAnchor, PopoverContent } from '@/components/ui/popover'\nimport { TabListItem } from './tab-list-item'\nimport { useAvailableTabs } from './use-available-tabs'\n\ninterface TabMentionPopoverProps {\n  isOpen: boolean\n  filterText: string\n  selectedTabs: chrome.tabs.Tab[]\n  onToggleTab: (tab: chrome.tabs.Tab) => void\n  onClose: () => void\n  anchorRef: React.RefObject<HTMLTextAreaElement | null>\n}\n\nexport const TabMentionPopover: FC<TabMentionPopoverProps> = ({\n  isOpen,\n  filterText,\n  selectedTabs,\n  onToggleTab,\n  onClose,\n  anchorRef,\n}) => {\n  const { tabs, allTabs } = useAvailableTabs({ enabled: isOpen, filterText })\n  const [focusedIndex, setFocusedIndex] = useState(0)\n  const listRef = useRef<HTMLDivElement>(null)\n\n  const selectedTabIds = useMemo(\n    () => new Set(selectedTabs.map((t) => t.id)),\n    [selectedTabs],\n  )\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentionally reset focus when filter changes\n  useEffect(() => {\n    setFocusedIndex(0)\n  }, [filterText])\n\n  useEffect(() => {\n    if (!isOpen) return\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      switch (e.key) {\n        case 'ArrowDown':\n          e.preventDefault()\n          setFocusedIndex((prev) => (prev < tabs.length - 1 ? prev + 1 : prev))\n          break\n        case 'ArrowUp':\n          e.preventDefault()\n          setFocusedIndex((prev) => (prev > 0 ? prev - 1 : prev))\n          break\n        case 'Enter':\n          e.preventDefault()\n          if (tabs[focusedIndex]) {\n            onToggleTab(tabs[focusedIndex])\n          }\n          break\n        case 'Escape':\n          e.preventDefault()\n          onClose()\n          break\n        case 'Tab':\n          onClose()\n          break\n      }\n    }\n\n    document.addEventListener('keydown', handleKeyDown)\n    return () => document.removeEventListener('keydown', handleKeyDown)\n  }, [isOpen, tabs, focusedIndex, onToggleTab, onClose])\n\n  useEffect(() => {\n    if (listRef.current && focusedIndex >= 0) {\n      const items = listRef.current.querySelectorAll('[data-tab-item]')\n      items[focusedIndex]?.scrollIntoView({ block: 'nearest' })\n    }\n  }, [focusedIndex])\n\n  if (!isOpen) return null\n\n  return (\n    <Popover open={isOpen} onOpenChange={(open) => !open && onClose()}>\n      <PopoverAnchor\n        virtualRef={anchorRef as React.RefObject<HTMLTextAreaElement>}\n      />\n      <PopoverContent\n        side=\"top\"\n        align=\"start\"\n        sideOffset={8}\n        className=\"w-[calc(100vw-24px)] max-w-[400px] p-0\"\n        onOpenAutoFocus={(e) => e.preventDefault()}\n        onCloseAutoFocus={(e) => e.preventDefault()}\n        role=\"dialog\"\n        aria-label=\"Select tabs to attach\"\n      >\n        <Command\n          className=\"[&_svg:not([class*='text-'])]:text-muted-foreground\"\n          shouldFilter={false}\n        >\n          <div className=\"border-border/50 border-b px-3 py-2\">\n            <div className=\"flex items-center justify-between\">\n              <span className=\"font-semibold text-muted-foreground text-xs uppercase tracking-wide\">\n                Attach Tabs\n              </span>\n              {filterText && (\n                <span className=\"text-muted-foreground text-xs\">\n                  Filtering: \"{filterText}\"\n                </span>\n              )}\n            </div>\n            {selectedTabs.length > 0 && (\n              <span className=\"mt-1 block text-[var(--accent-orange)] text-xs\">\n                {selectedTabs.length} tab{selectedTabs.length !== 1 ? 's' : ''}{' '}\n                selected\n              </span>\n            )}\n          </div>\n          <CommandList\n            ref={listRef}\n            className=\"max-h-64 overflow-auto\"\n            role=\"listbox\"\n            aria-label=\"Available tabs\"\n            aria-multiselectable=\"true\"\n          >\n            <CommandEmpty className=\"py-6 text-center\">\n              <div className=\"text-muted-foreground text-sm\">\n                {allTabs.length === 0\n                  ? 'No active tabs'\n                  : `No tabs matching \"${filterText}\"`}\n              </div>\n              <div className=\"mt-1 text-muted-foreground/70 text-xs\">\n                {allTabs.length === 0\n                  ? 'Open some web pages to attach them'\n                  : 'Try a different search term'}\n              </div>\n            </CommandEmpty>\n            <CommandGroup>\n              {tabs.map((tab, index) => (\n                <CommandItem\n                  key={tab.id}\n                  data-tab-item\n                  value={`${tab.id}`}\n                  onSelect={() => onToggleTab(tab)}\n                  onMouseEnter={() => setFocusedIndex(index)}\n                  className=\"p-0 data-[selected=true]:bg-transparent\"\n                >\n                  <TabListItem\n                    tab={tab}\n                    isSelected={selectedTabIds.has(tab.id)}\n                    className={index === focusedIndex ? 'bg-accent' : undefined}\n                  />\n                </CommandItem>\n              ))}\n            </CommandGroup>\n          </CommandList>\n          <div className=\"border-border/50 border-t px-3 py-2\">\n            <div className=\"flex items-center justify-between text-[10px] text-muted-foreground\">\n              <span>\n                <kbd className=\"rounded border border-border bg-muted px-1 py-0.5\">\n                  â†‘â†“\n                </kbd>{' '}\n                navigate\n              </span>\n              <span>\n                <kbd className=\"rounded border border-border bg-muted px-1 py-0.5\">\n                  Enter\n                </kbd>{' '}\n                select\n              </span>\n              <span>\n                <kbd className=\"rounded border border-border bg-muted px-1 py-0.5\">\n                  Esc\n                </kbd>{' '}\n                close\n              </span>\n            </div>\n          </div>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  )\n}\n","import { Send, SquareStop } from 'lucide-react'\nimport type { FC, FormEvent, KeyboardEvent } from 'react'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport { TabMentionPopover } from '@/components/elements/tab-mention-popover'\nimport { cn } from '@/lib/utils'\nimport type { ChatMode } from './chatTypes'\n\ninterface MentionState {\n  isOpen: boolean\n  filterText: string\n  startPosition: number\n}\n\ninterface ChatInputProps {\n  input: string\n  status: 'streaming' | 'submitted' | 'ready' | 'error'\n  mode: ChatMode\n  onInputChange: (value: string) => void\n  onSubmit: (e: FormEvent) => void\n  onStop: () => void\n  selectedTabs: chrome.tabs.Tab[]\n  onToggleTab: (tab: chrome.tabs.Tab) => void\n}\n\nexport const ChatInput: FC<ChatInputProps> = ({\n  input,\n  status,\n  mode,\n  onInputChange,\n  onSubmit,\n  onStop,\n  selectedTabs,\n  onToggleTab,\n}) => {\n  const textareaRef = useRef<HTMLTextAreaElement>(null)\n  const [mentionState, setMentionState] = useState<MentionState>({\n    isOpen: false,\n    filterText: '',\n    startPosition: 0,\n  })\n\n  const inputRef = useRef(input)\n  const mentionStateRef = useRef(mentionState)\n\n  useEffect(() => {\n    inputRef.current = input\n    mentionStateRef.current = mentionState\n  })\n\n  const closeMention = useCallback(() => {\n    const state = mentionStateRef.current\n    if (state.isOpen) {\n      const currentInput = inputRef.current\n      const beforeMention = currentInput.slice(0, state.startPosition)\n      const afterMention = currentInput.slice(\n        state.startPosition + 1 + state.filterText.length,\n      )\n      onInputChange(beforeMention + afterMention)\n      setMentionState({ isOpen: false, filterText: '', startPosition: 0 })\n\n      requestAnimationFrame(() => {\n        textareaRef.current?.focus()\n        const newPosition = beforeMention.length\n        textareaRef.current?.setSelectionRange(newPosition, newPosition)\n      })\n    }\n  }, [onInputChange])\n\n  const handleInputChange = (value: string) => {\n    const textarea = textareaRef.current\n    const cursorPosition = textarea?.selectionStart ?? value.length\n\n    if (mentionState.isOpen) {\n      const textAfterAt = value.slice(mentionState.startPosition + 1)\n      const spaceIndex = textAfterAt.search(/\\s/)\n      const filterText =\n        spaceIndex === -1 ? textAfterAt : textAfterAt.slice(0, spaceIndex)\n\n      if (\n        cursorPosition <= mentionState.startPosition ||\n        value[mentionState.startPosition] !== '@'\n      ) {\n        setMentionState({ isOpen: false, filterText: '', startPosition: 0 })\n      } else {\n        setMentionState((prev) => ({ ...prev, filterText }))\n      }\n    } else {\n      const charBeforeCursor = value[cursorPosition - 1]\n      const textBeforeAt = value.slice(0, cursorPosition - 1)\n      const isAtWordBoundary = /(?:^|[\\s\\n])$/.test(textBeforeAt)\n\n      if (charBeforeCursor === '@' && isAtWordBoundary) {\n        setMentionState({\n          isOpen: true,\n          filterText: '',\n          startPosition: cursorPosition - 1,\n        })\n      }\n    }\n\n    onInputChange(value)\n  }\n\n  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {\n    if (mentionState.isOpen) {\n      if (\n        e.key === 'ArrowDown' ||\n        e.key === 'ArrowUp' ||\n        e.key === 'Enter' ||\n        e.key === 'Escape'\n      ) {\n        return\n      }\n      if (e.key === 'Tab') {\n        e.preventDefault()\n        closeMention()\n        return\n      }\n    }\n\n    if (\n      e.key === 'Enter' &&\n      !e.shiftKey &&\n      !e.metaKey &&\n      !e.ctrlKey &&\n      !e.nativeEvent.isComposing\n    ) {\n      e.preventDefault()\n      if (input.trim()) {\n        e.currentTarget.form?.requestSubmit()\n      }\n    }\n  }\n\n  useEffect(() => {\n    if (!mentionState.isOpen) return\n\n    const handleClickOutside = (e: MouseEvent) => {\n      const target = e.target as HTMLElement\n      if (\n        !textareaRef.current?.contains(target) &&\n        !target.closest('[data-slot=\"popover-content\"]')\n      ) {\n        closeMention()\n      }\n    }\n\n    document.addEventListener('mousedown', handleClickOutside)\n    return () => document.removeEventListener('mousedown', handleClickOutside)\n  }, [mentionState.isOpen, closeMention])\n\n  return (\n    <form\n      onSubmit={onSubmit}\n      className=\"relative mt-2 flex w-full items-end gap-2\"\n    >\n      <TabMentionPopover\n        isOpen={mentionState.isOpen}\n        filterText={mentionState.filterText}\n        selectedTabs={selectedTabs}\n        onToggleTab={onToggleTab}\n        onClose={closeMention}\n        anchorRef={textareaRef}\n      />\n      <textarea\n        ref={textareaRef}\n        className={cn(\n          'field-sizing-content max-h-60 min-h-[42px] flex-1 resize-none overflow-hidden rounded-2xl border border-border/50 bg-muted/50 px-4 py-2.5 pr-11 text-sm outline-none transition-colors placeholder:text-muted-foreground/70 hover:border-border focus:border-[var(--accent-orange)]',\n        )}\n        value={input}\n        onChange={(e) => handleInputChange(e.target.value)}\n        onKeyDown={handleKeyDown}\n        placeholder={\n          mode === 'chat' ? 'Ask about this page...' : 'What should I do?'\n        }\n        rows={1}\n      />\n      {status === 'streaming' ? (\n        <button\n          type=\"button\"\n          onClick={onStop}\n          className=\"absolute right-1.5 bottom-1.5 cursor-pointer rounded-full bg-red-600 p-2 text-white shadow-sm transition-all duration-200 hover:bg-red-900 disabled:cursor-not-allowed disabled:opacity-50\"\n        >\n          <SquareStop className=\"h-3.5 w-3.5\" />\n          <span className=\"sr-only\">Stop</span>\n        </button>\n      ) : (\n        <button\n          type=\"submit\"\n          disabled={!input.trim()}\n          className=\"absolute right-1.5 bottom-1.5 cursor-pointer rounded-full bg-[var(--accent-orange)] p-2 text-white shadow-sm transition-all duration-200 hover:bg-[var(--accent-orange-bright)] disabled:cursor-not-allowed disabled:opacity-50\"\n        >\n          <Send className=\"h-3.5 w-3.5\" />\n          <span className=\"sr-only\">Send</span>\n        </button>\n      )}\n    </form>\n  )\n}\n","import { MessageSquare, Zap } from 'lucide-react'\nimport type { FC } from 'react'\nimport { cn } from '@/lib/utils'\nimport type { ChatMode } from './chatTypes'\n\ninterface ChatModeToggleProps {\n  mode: ChatMode\n  onModeChange: (mode: ChatMode) => void\n}\n\nexport const ChatModeToggle: FC<ChatModeToggleProps> = ({\n  mode,\n  onModeChange,\n}) => {\n  return (\n    <div className=\"flex items-center rounded-full border border-border/50 bg-muted p-0.5\">\n      <button\n        type=\"button\"\n        onClick={() => onModeChange('chat')}\n        className={cn(\n          'flex items-center gap-1.5 rounded-full px-2.5 py-1.5 font-medium text-xs transition-all',\n          mode === 'chat'\n            ? 'bg-background text-foreground shadow-sm'\n            : 'text-muted-foreground',\n        )}\n        title=\"Chat Mode\"\n      >\n        <MessageSquare className=\"h-3 w-3\" />\n        <span>Chat</span>\n      </button>\n      <button\n        type=\"button\"\n        onClick={() => onModeChange('agent')}\n        className={cn(\n          'flex items-center gap-1.5 rounded-full px-2.5 py-1.5 font-medium text-xs transition-all',\n          mode === 'agent'\n            ? 'bg-background text-foreground shadow-sm'\n            : 'text-muted-foreground',\n        )}\n        title=\"Agent Mode\"\n      >\n        <Zap className=\"h-3 w-3\" />\n        <span>Agent</span>\n      </button>\n    </div>\n  )\n}\n","import { ChevronDown, Layers } from 'lucide-react'\nimport type { FC, FormEvent } from 'react'\nimport { TabSelector } from '@/components/elements/tab-selector'\nimport { ChatAttachedTabs } from './ChatAttachedTabs'\nimport { ChatInput } from './ChatInput'\nimport { ChatModeToggle } from './ChatModeToggle'\nimport type { ChatMode } from './chatTypes'\n\ninterface ChatFooterProps {\n  mode: ChatMode\n  onModeChange: (mode: ChatMode) => void\n  input: string\n  onInputChange: (value: string) => void\n  onSubmit: (e: FormEvent) => void\n  status: 'streaming' | 'submitted' | 'ready' | 'error'\n  onStop: () => void\n  attachedTabs: chrome.tabs.Tab[]\n  onToggleTab: (tab: chrome.tabs.Tab) => void\n  onRemoveTab: (tabId?: number) => void\n}\n\nexport const ChatFooter: FC<ChatFooterProps> = ({\n  mode,\n  onModeChange,\n  input,\n  onInputChange,\n  onSubmit,\n  status,\n  onStop,\n  attachedTabs,\n  onToggleTab,\n  onRemoveTab,\n}) => {\n  return (\n    <footer className=\"border-border/40 border-t bg-background/80 backdrop-blur-md\">\n      <ChatAttachedTabs tabs={attachedTabs} onRemoveTab={onRemoveTab} />\n\n      <div className=\"p-3\">\n        <div className=\"flex items-center gap-2\">\n          <ChatModeToggle mode={mode} onModeChange={onModeChange} />\n\n          {mode === 'chat' && (\n            <TabSelector\n              selectedTabs={attachedTabs}\n              onToggleTab={onToggleTab}\n              side=\"top\"\n            >\n              <button\n                type=\"button\"\n                className=\"flex cursor-pointer items-center gap-1.5 rounded-lg p-2 text-muted-foreground transition-colors hover:bg-muted/50 hover:text-foreground data-[state=open]:bg-accent\"\n                title=\"Select tabs\"\n              >\n                <Layers className=\"h-4 w-4\" />\n                {attachedTabs.length > 0 && (\n                  <span className=\"font-medium text-[var(--accent-orange)] text-xs\">\n                    {attachedTabs.length}\n                  </span>\n                )}\n                <ChevronDown className=\"h-3 w-3\" />\n              </button>\n            </TabSelector>\n          )}\n        </div>\n\n        <ChatInput\n          input={input}\n          status={status}\n          mode={mode}\n          onInputChange={onInputChange}\n          onSubmit={onSubmit}\n          onStop={onStop}\n          selectedTabs={attachedTabs}\n          onToggleTab={onToggleTab}\n        />\n      </div>\n    </footer>\n  )\n}\n","import { Check } from 'lucide-react'\nimport type { FC, PropsWithChildren } from 'react'\nimport { useState } from 'react'\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from '@/components/ui/command'\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover'\nimport { BrowserOSIcon, ProviderIcon } from '@/lib/llm-providers/providerIcons'\nimport type { ProviderType } from '@/lib/llm-providers/types'\nimport { cn } from '@/lib/utils'\nimport type { Provider } from './chatTypes'\n\ninterface ChatProviderSelectorProps {\n  providers: Provider[]\n  selectedProvider: Provider\n  onSelectProvider: (provider: Provider) => void\n}\n\nexport const ChatProviderSelector: FC<\n  PropsWithChildren<ChatProviderSelectorProps>\n> = ({ children, providers, selectedProvider, onSelectProvider }) => {\n  const [open, setOpen] = useState(false)\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>{children}</PopoverTrigger>\n      <PopoverContent side=\"bottom\" align=\"start\" className=\"w-48 p-0\">\n        <Command>\n          <CommandInput placeholder=\"Search providers...\" className=\"h-9\" />\n          <CommandList>\n            <div className=\"my-2 px-2 font-semibold text-muted-foreground text-xs uppercase tracking-wide\">\n              AI Provider\n            </div>\n            <CommandEmpty>No provider found</CommandEmpty>\n            <CommandGroup>\n              {providers.map((provider) => {\n                const isSelected = selectedProvider.id === provider.id\n                return (\n                  <CommandItem\n                    key={provider.id}\n                    value={`${provider.id} ${provider.name}`}\n                    onSelect={() => {\n                      onSelectProvider(provider)\n                      setOpen(false)\n                    }}\n                    className={cn(\n                      'flex w-full items-center gap-3 rounded-md p-2 transition-colors',\n                      isSelected && 'bg-[var(--accent-orange)]/10',\n                    )}\n                  >\n                    <span className=\"text-muted-foreground\">\n                      {provider.type === 'browseros' ? (\n                        <BrowserOSIcon size={18} />\n                      ) : (\n                        <ProviderIcon\n                          type={provider.type as ProviderType}\n                          size={18}\n                        />\n                      )}\n                    </span>\n                    <span className=\"flex-1 text-left text-sm\">\n                      {provider.name}\n                    </span>\n                    {isSelected && (\n                      <Check className=\"h-3.5 w-3.5 text-[var(--accent-orange)]\" />\n                    )}\n                  </CommandItem>\n                )\n              })}\n            </CommandGroup>\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  )\n}\n","import { Github, Plus, SettingsIcon } from 'lucide-react'\nimport type { FC } from 'react'\nimport { ThemeToggle } from '@/components/elements/theme-toggle'\nimport { productRepositoryUrl } from '@/lib/constants/productUrls'\nimport { BrowserOSIcon, ProviderIcon } from '@/lib/llm-providers/providerIcons'\nimport type { ProviderType } from '@/lib/llm-providers/types'\nimport { ChatProviderSelector } from './ChatProviderSelector'\nimport type { Provider } from './chatTypes'\n\ninterface ChatHeaderProps {\n  selectedProvider: Provider\n  providers: Provider[]\n  onSelectProvider: (provider: Provider) => void\n  onNewConversation: () => void\n  hasMessages: boolean\n}\n\nexport const ChatHeader: FC<ChatHeaderProps> = ({\n  selectedProvider,\n  providers,\n  onSelectProvider,\n  onNewConversation,\n  hasMessages,\n}) => {\n  return (\n    <header className=\"flex items-center justify-between border-border/40 border-b bg-background/80 px-3 py-2.5 backdrop-blur-md\">\n      <div className=\"flex items-center gap-2\">\n        {/* Provider Selector */}\n        <ChatProviderSelector\n          providers={providers}\n          selectedProvider={selectedProvider}\n          onSelectProvider={onSelectProvider}\n        >\n          <button\n            type=\"button\"\n            className=\"group relative inline-flex cursor-pointer items-center gap-2 rounded-lg p-2 text-muted-foreground transition-colors hover:bg-muted/50 hover:text-foreground data-[state=open]:bg-accent\"\n            title=\"Change AI Provider\"\n          >\n            {selectedProvider.type === 'browseros' ? (\n              <BrowserOSIcon size={18} />\n            ) : (\n              <ProviderIcon\n                type={selectedProvider.type as ProviderType}\n                size={18}\n              />\n            )}\n            <span className=\"font-semibold text-base\">\n              {selectedProvider.name}\n            </span>\n          </button>\n        </ChatProviderSelector>\n      </div>\n\n      <div className=\"flex items-center gap-1\">\n        {hasMessages && (\n          <button\n            type=\"button\"\n            onClick={onNewConversation}\n            className=\"cursor-pointer rounded-lg p-2 text-muted-foreground transition-colors hover:bg-muted/50 hover:text-foreground\"\n            title=\"New conversation\"\n          >\n            <Plus className=\"h-4 w-4\" />\n          </button>\n        )}\n\n        <a\n          href={productRepositoryUrl}\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          className=\"cursor-pointer rounded-lg p-2 text-muted-foreground transition-colors hover:bg-muted/50 hover:text-foreground\"\n          title=\"Star on Github\"\n        >\n          <Github className=\"h-4 w-4\" />\n        </a>\n\n        <a\n          href=\"/options.html\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          className=\"cursor-pointer rounded-lg p-2 text-muted-foreground transition-colors hover:bg-muted/50 hover:text-foreground\"\n          title=\"Settings\"\n        >\n          <SettingsIcon className=\"h-4 w-4\" />\n        </a>\n\n        <ThemeToggle\n          className=\"rounded-lg p-2 text-muted-foreground transition-colors hover:bg-muted/50 hover:text-foreground\"\n          iconClassName=\"h-4 w-4\"\n        />\n      </div>\n    </header>\n  )\n}\n","/*!---------------------------------------------------------------------------------------------\n *  Copyright (c) StackBlitz. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { useCallback, useMemo, useRef, useState, } from \"react\";\nconst DEFAULT_SPRING_ANIMATION = {\n    /**\n     * A value from 0 to 1, on how much to damp the animation.\n     * 0 means no damping, 1 means full damping.\n     *\n     * @default 0.7\n     */\n    damping: 0.7,\n    /**\n     * The stiffness of how fast/slow the animation gets up to speed.\n     *\n     * @default 0.05\n     */\n    stiffness: 0.05,\n    /**\n     * The inertial mass associated with the animation.\n     * Higher numbers make the animation slower.\n     *\n     * @default 1.25\n     */\n    mass: 1.25,\n};\nconst STICK_TO_BOTTOM_OFFSET_PX = 70;\nconst SIXTY_FPS_INTERVAL_MS = 1000 / 60;\nconst RETAIN_ANIMATION_DURATION_MS = 350;\nlet mouseDown = false;\nglobalThis.document?.addEventListener(\"mousedown\", () => {\n    mouseDown = true;\n});\nglobalThis.document?.addEventListener(\"mouseup\", () => {\n    mouseDown = false;\n});\nglobalThis.document?.addEventListener(\"click\", () => {\n    mouseDown = false;\n});\nexport const useStickToBottom = (options = {}) => {\n    const [escapedFromLock, updateEscapedFromLock] = useState(false);\n    const [isAtBottom, updateIsAtBottom] = useState(options.initial !== false);\n    const [isNearBottom, setIsNearBottom] = useState(false);\n    const optionsRef = useRef(null);\n    optionsRef.current = options;\n    const isSelecting = useCallback(() => {\n        if (!mouseDown) {\n            return false;\n        }\n        const selection = window.getSelection();\n        if (!selection || !selection.rangeCount) {\n            return false;\n        }\n        const range = selection.getRangeAt(0);\n        return (range.commonAncestorContainer.contains(scrollRef.current) ||\n            scrollRef.current?.contains(range.commonAncestorContainer));\n    }, []);\n    const setIsAtBottom = useCallback((isAtBottom) => {\n        state.isAtBottom = isAtBottom;\n        updateIsAtBottom(isAtBottom);\n    }, []);\n    const setEscapedFromLock = useCallback((escapedFromLock) => {\n        state.escapedFromLock = escapedFromLock;\n        updateEscapedFromLock(escapedFromLock);\n    }, []);\n    // biome-ignore lint/correctness/useExhaustiveDependencies: not needed\n    const state = useMemo(() => {\n        let lastCalculation;\n        return {\n            escapedFromLock,\n            isAtBottom,\n            resizeDifference: 0,\n            accumulated: 0,\n            velocity: 0,\n            listeners: new Set(),\n            get scrollTop() {\n                return scrollRef.current?.scrollTop ?? 0;\n            },\n            set scrollTop(scrollTop) {\n                if (scrollRef.current) {\n                    scrollRef.current.scrollTop = scrollTop;\n                    state.ignoreScrollToTop = scrollRef.current.scrollTop;\n                }\n            },\n            get targetScrollTop() {\n                if (!scrollRef.current || !contentRef.current) {\n                    return 0;\n                }\n                return (scrollRef.current.scrollHeight - 1 - scrollRef.current.clientHeight);\n            },\n            get calculatedTargetScrollTop() {\n                if (!scrollRef.current || !contentRef.current) {\n                    return 0;\n                }\n                const { targetScrollTop } = this;\n                if (!options.targetScrollTop) {\n                    return targetScrollTop;\n                }\n                if (lastCalculation?.targetScrollTop === targetScrollTop) {\n                    return lastCalculation.calculatedScrollTop;\n                }\n                const calculatedScrollTop = Math.max(Math.min(options.targetScrollTop(targetScrollTop, {\n                    scrollElement: scrollRef.current,\n                    contentElement: contentRef.current,\n                }), targetScrollTop), 0);\n                lastCalculation = { targetScrollTop, calculatedScrollTop };\n                requestAnimationFrame(() => {\n                    lastCalculation = undefined;\n                });\n                return calculatedScrollTop;\n            },\n            get scrollDifference() {\n                return this.calculatedTargetScrollTop - this.scrollTop;\n            },\n            get isNearBottom() {\n                return this.scrollDifference <= STICK_TO_BOTTOM_OFFSET_PX;\n            },\n        };\n    }, []);\n    const scrollToBottom = useCallback((scrollOptions = {}) => {\n        if (typeof scrollOptions === \"string\") {\n            scrollOptions = { animation: scrollOptions };\n        }\n        if (!scrollOptions.preserveScrollPosition) {\n            setIsAtBottom(true);\n        }\n        const waitElapsed = Date.now() + (Number(scrollOptions.wait) || 0);\n        const behavior = mergeAnimations(optionsRef.current, scrollOptions.animation);\n        const { ignoreEscapes = false } = scrollOptions;\n        let durationElapsed;\n        let startTarget = state.calculatedTargetScrollTop;\n        if (scrollOptions.duration instanceof Promise) {\n            scrollOptions.duration.finally(() => {\n                durationElapsed = Date.now();\n            });\n        }\n        else {\n            durationElapsed = waitElapsed + (scrollOptions.duration ?? 0);\n        }\n        const next = async () => {\n            const promise = new Promise(requestAnimationFrame).then(() => {\n                if (!state.isAtBottom) {\n                    state.animation = undefined;\n                    return false;\n                }\n                const { scrollTop } = state;\n                const tick = performance.now();\n                const tickDelta = (tick - (state.lastTick ?? tick)) / SIXTY_FPS_INTERVAL_MS;\n                state.animation || (state.animation = { behavior, promise, ignoreEscapes });\n                if (state.animation.behavior === behavior) {\n                    state.lastTick = tick;\n                }\n                if (isSelecting()) {\n                    return next();\n                }\n                if (waitElapsed > Date.now()) {\n                    return next();\n                }\n                if (scrollTop < Math.min(startTarget, state.calculatedTargetScrollTop)) {\n                    if (state.animation?.behavior === behavior) {\n                        if (behavior === \"instant\") {\n                            state.scrollTop = state.calculatedTargetScrollTop;\n                            return next();\n                        }\n                        state.velocity =\n                            (behavior.damping * state.velocity +\n                                behavior.stiffness * state.scrollDifference) /\n                                behavior.mass;\n                        state.accumulated += state.velocity * tickDelta;\n                        state.scrollTop += state.accumulated;\n                        if (state.scrollTop !== scrollTop) {\n                            state.accumulated = 0;\n                        }\n                    }\n                    return next();\n                }\n                if (durationElapsed > Date.now()) {\n                    startTarget = state.calculatedTargetScrollTop;\n                    return next();\n                }\n                state.animation = undefined;\n                /**\n                 * If we're still below the target, then queue\n                 * up another scroll to the bottom with the last\n                 * requested animatino.\n                 */\n                if (state.scrollTop < state.calculatedTargetScrollTop) {\n                    return scrollToBottom({\n                        animation: mergeAnimations(optionsRef.current, optionsRef.current.resize),\n                        ignoreEscapes,\n                        duration: Math.max(0, durationElapsed - Date.now()) || undefined,\n                    });\n                }\n                return state.isAtBottom;\n            });\n            return promise.then((isAtBottom) => {\n                requestAnimationFrame(() => {\n                    if (!state.animation) {\n                        state.lastTick = undefined;\n                        state.velocity = 0;\n                    }\n                });\n                return isAtBottom;\n            });\n        };\n        if (scrollOptions.wait !== true) {\n            state.animation = undefined;\n        }\n        if (state.animation?.behavior === behavior) {\n            return state.animation.promise;\n        }\n        return next();\n    }, [setIsAtBottom, isSelecting, state]);\n    const stopScroll = useCallback(() => {\n        setEscapedFromLock(true);\n        setIsAtBottom(false);\n    }, [setEscapedFromLock, setIsAtBottom]);\n    const handleScroll = useCallback(({ target }) => {\n        if (target !== scrollRef.current) {\n            return;\n        }\n        const { scrollTop, ignoreScrollToTop } = state;\n        let { lastScrollTop = scrollTop } = state;\n        state.lastScrollTop = scrollTop;\n        state.ignoreScrollToTop = undefined;\n        if (ignoreScrollToTop && ignoreScrollToTop > scrollTop) {\n            /**\n             * When the user scrolls up while the animation plays, the `scrollTop` may\n             * not come in separate events; if this happens, to make sure `isScrollingUp`\n             * is correct, set the lastScrollTop to the ignored event.\n             */\n            lastScrollTop = ignoreScrollToTop;\n        }\n        setIsNearBottom(state.isNearBottom);\n        /**\n         * Scroll events may come before a ResizeObserver event,\n         * so in order to ignore resize events correctly we use a\n         * timeout.\n         *\n         * @see https://github.com/WICG/resize-observer/issues/25#issuecomment-248757228\n         */\n        setTimeout(() => {\n            /**\n             * When theres a resize difference ignore the resize event.\n             */\n            if (state.resizeDifference || scrollTop === ignoreScrollToTop) {\n                return;\n            }\n            if (isSelecting()) {\n                setEscapedFromLock(true);\n                setIsAtBottom(false);\n                return;\n            }\n            const isScrollingDown = scrollTop > lastScrollTop;\n            const isScrollingUp = scrollTop < lastScrollTop;\n            if (state.animation?.ignoreEscapes) {\n                state.scrollTop = lastScrollTop;\n                return;\n            }\n            if (isScrollingUp) {\n                setEscapedFromLock(true);\n                setIsAtBottom(false);\n            }\n            if (isScrollingDown) {\n                setEscapedFromLock(false);\n            }\n            if (!state.escapedFromLock && state.isNearBottom) {\n                setIsAtBottom(true);\n            }\n        }, 1);\n    }, [setEscapedFromLock, setIsAtBottom, isSelecting, state]);\n    const handleWheel = useCallback(({ target, deltaY }) => {\n        let element = target;\n        while (![\"scroll\", \"auto\"].includes(getComputedStyle(element).overflow)) {\n            if (!element.parentElement) {\n                return;\n            }\n            element = element.parentElement;\n        }\n        /**\n         * The browser may cancel the scrolling from the mouse wheel\n         * if we update it from the animation in meantime.\n         * To prevent this, always escape when the wheel is scrolled up.\n         */\n        if (element === scrollRef.current &&\n            deltaY < 0 &&\n            scrollRef.current.scrollHeight > scrollRef.current.clientHeight &&\n            !state.animation?.ignoreEscapes) {\n            setEscapedFromLock(true);\n            setIsAtBottom(false);\n        }\n    }, [setEscapedFromLock, setIsAtBottom, state]);\n    const scrollRef = useRefCallback((scroll) => {\n        scrollRef.current?.removeEventListener(\"scroll\", handleScroll);\n        scrollRef.current?.removeEventListener(\"wheel\", handleWheel);\n        scroll?.addEventListener(\"scroll\", handleScroll, { passive: true });\n        scroll?.addEventListener(\"wheel\", handleWheel, { passive: true });\n    }, []);\n    const contentRef = useRefCallback((content) => {\n        state.resizeObserver?.disconnect();\n        if (!content) {\n            return;\n        }\n        let previousHeight;\n        state.resizeObserver = new ResizeObserver(([entry]) => {\n            const { height } = entry.contentRect;\n            const difference = height - (previousHeight ?? height);\n            state.resizeDifference = difference;\n            /**\n             * Sometimes the browser can overscroll past the target,\n             * so check for this and adjust appropriately.\n             */\n            if (state.scrollTop > state.targetScrollTop) {\n                state.scrollTop = state.targetScrollTop;\n            }\n            setIsNearBottom(state.isNearBottom);\n            if (difference >= 0) {\n                /**\n                 * If it's a positive resize, scroll to the bottom when\n                 * we're already at the bottom.\n                 */\n                const animation = mergeAnimations(optionsRef.current, previousHeight\n                    ? optionsRef.current.resize\n                    : optionsRef.current.initial);\n                scrollToBottom({\n                    animation,\n                    wait: true,\n                    preserveScrollPosition: true,\n                    duration: animation === \"instant\" ? undefined : RETAIN_ANIMATION_DURATION_MS,\n                });\n            }\n            else {\n                /**\n                 * Else if it's a negative resize, check if we're near the bottom\n                 * if we are want to un-escape from the lock, because the resize\n                 * could have caused the container to be at the bottom.\n                 */\n                if (state.isNearBottom) {\n                    setEscapedFromLock(false);\n                    setIsAtBottom(true);\n                }\n            }\n            previousHeight = height;\n            /**\n             * Reset the resize difference after the scroll event\n             * has fired. Requires a rAF to wait for the scroll event,\n             * and a setTimeout to wait for the other timeout we have in\n             * resizeObserver in case the scroll event happens after the\n             * resize event.\n             */\n            requestAnimationFrame(() => {\n                setTimeout(() => {\n                    if (state.resizeDifference === difference) {\n                        state.resizeDifference = 0;\n                    }\n                }, 1);\n            });\n        });\n        state.resizeObserver?.observe(content);\n    }, []);\n    return {\n        contentRef,\n        scrollRef,\n        scrollToBottom,\n        stopScroll,\n        isAtBottom: isAtBottom || isNearBottom,\n        isNearBottom,\n        escapedFromLock,\n        state,\n    };\n};\nfunction useRefCallback(callback, deps) {\n    // biome-ignore lint/correctness/useExhaustiveDependencies: not needed\n    const result = useCallback((ref) => {\n        result.current = ref;\n        return callback(ref);\n    }, deps);\n    return result;\n}\nconst animationCache = new Map();\nfunction mergeAnimations(...animations) {\n    const result = { ...DEFAULT_SPRING_ANIMATION };\n    let instant = false;\n    for (const animation of animations) {\n        if (animation === \"instant\") {\n            instant = true;\n            continue;\n        }\n        if (typeof animation !== \"object\") {\n            continue;\n        }\n        instant = false;\n        result.damping = animation.damping ?? result.damping;\n        result.stiffness = animation.stiffness ?? result.stiffness;\n        result.mass = animation.mass ?? result.mass;\n    }\n    const key = JSON.stringify(result);\n    if (!animationCache.has(key)) {\n        animationCache.set(key, Object.freeze(result));\n    }\n    return instant ? \"instant\" : animationCache.get(key);\n}\n","import { jsx as _jsx } from \"react/jsx-runtime\";\n/*!---------------------------------------------------------------------------------------------\n *  Copyright (c) StackBlitz. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as React from \"react\";\nimport { createContext, useContext, useEffect, useImperativeHandle, useLayoutEffect, useMemo, useRef, } from \"react\";\nimport { useStickToBottom, } from \"./useStickToBottom.js\";\nconst StickToBottomContext = createContext(null);\nconst useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\nexport function StickToBottom({ instance, children, resize, initial, mass, damping, stiffness, targetScrollTop: currentTargetScrollTop, contextRef, ...props }) {\n    const customTargetScrollTop = useRef(null);\n    const targetScrollTop = React.useCallback((target, elements) => {\n        const get = context?.targetScrollTop ?? currentTargetScrollTop;\n        return get?.(target, elements) ?? target;\n    }, [currentTargetScrollTop]);\n    const defaultInstance = useStickToBottom({\n        mass,\n        damping,\n        stiffness,\n        resize,\n        initial,\n        targetScrollTop,\n    });\n    const { scrollRef, contentRef, scrollToBottom, stopScroll, isAtBottom, escapedFromLock, state, } = instance ?? defaultInstance;\n    const context = useMemo(() => ({\n        scrollToBottom,\n        stopScroll,\n        scrollRef,\n        isAtBottom,\n        escapedFromLock,\n        contentRef,\n        state,\n        get targetScrollTop() {\n            return customTargetScrollTop.current;\n        },\n        set targetScrollTop(targetScrollTop) {\n            customTargetScrollTop.current = targetScrollTop;\n        },\n    }), [\n        scrollToBottom,\n        isAtBottom,\n        contentRef,\n        scrollRef,\n        stopScroll,\n        escapedFromLock,\n        state,\n    ]);\n    useImperativeHandle(contextRef, () => context, [context]);\n    useIsomorphicLayoutEffect(() => {\n        if (!scrollRef.current) {\n            return;\n        }\n        if (getComputedStyle(scrollRef.current).overflow === \"visible\") {\n            scrollRef.current.style.overflow = \"auto\";\n        }\n    }, []);\n    return (_jsx(StickToBottomContext.Provider, { value: context, children: _jsx(\"div\", { ...props, children: typeof children === \"function\" ? children(context) : children }) }));\n}\n(function (StickToBottom) {\n    function Content({ children, ...props }) {\n        const context = useStickToBottomContext();\n        return (_jsx(\"div\", { ref: context.scrollRef, style: {\n                height: \"100%\",\n                width: \"100%\",\n            }, children: _jsx(\"div\", { ...props, ref: context.contentRef, children: typeof children === \"function\" ? children(context) : children }) }));\n    }\n    StickToBottom.Content = Content;\n})(StickToBottom || (StickToBottom = {}));\n/**\n * Use this hook inside a <StickToBottom> component to gain access to whether the component is at the bottom of the scrollable area.\n */\nexport function useStickToBottomContext() {\n    const context = useContext(StickToBottomContext);\n    if (!context) {\n        throw new Error(\"use-stick-to-bottom component context must be used within a StickToBottom component\");\n    }\n    return context;\n}\n","'use client'\n\nimport { ArrowDownIcon } from 'lucide-react'\nimport type { ComponentProps } from 'react'\nimport { useCallback } from 'react'\nimport { StickToBottom, useStickToBottomContext } from 'use-stick-to-bottom'\nimport { Button } from '@/components/ui/button'\nimport { cn } from '@/lib/utils'\n\nexport type ConversationProps = ComponentProps<typeof StickToBottom>\n\n/**\n * @public\n */\nexport const Conversation = ({ className, ...props }: ConversationProps) => (\n  <StickToBottom\n    className={cn(\n      'styled-scrollbar relative flex-1 overflow-y-hidden',\n      className,\n    )}\n    initial=\"smooth\"\n    resize=\"smooth\"\n    role=\"log\"\n    {...props}\n  />\n)\n\nexport type ConversationContentProps = ComponentProps<\n  typeof StickToBottom.Content\n>\n\n/**\n * @public\n */\nexport const ConversationContent = ({\n  className,\n  ...props\n}: ConversationContentProps) => (\n  <StickToBottom.Content\n    className={cn('flex flex-col gap-8 p-4', className)}\n    {...props}\n  />\n)\n\nexport type ConversationEmptyStateProps = ComponentProps<'div'> & {\n  title?: string\n  description?: string\n  icon?: React.ReactNode\n}\n\n/**\n * @public\n */\nexport const ConversationEmptyState = ({\n  className,\n  title = 'No messages yet',\n  description = 'Start a conversation to see messages here',\n  icon,\n  children,\n  ...props\n}: ConversationEmptyStateProps) => (\n  <div\n    className={cn(\n      'flex size-full flex-col items-center justify-center gap-3 p-8 text-center',\n      className,\n    )}\n    {...props}\n  >\n    {children ?? (\n      <>\n        {icon && <div className=\"text-muted-foreground\">{icon}</div>}\n        <div className=\"space-y-1\">\n          <h3 className=\"font-medium text-sm\">{title}</h3>\n          {description && (\n            <p className=\"text-muted-foreground text-sm\">{description}</p>\n          )}\n        </div>\n      </>\n    )}\n  </div>\n)\n\nexport type ConversationScrollButtonProps = ComponentProps<typeof Button>\n\n/**\n * @public\n */\nexport const ConversationScrollButton = ({\n  className,\n  ...props\n}: ConversationScrollButtonProps) => {\n  const { isAtBottom, scrollToBottom } = useStickToBottomContext()\n\n  const handleScrollToBottom = useCallback(() => {\n    scrollToBottom()\n  }, [scrollToBottom])\n\n  return (\n    !isAtBottom && (\n      <Button\n        className={cn(\n          'absolute right-[16px] bottom-4 translate-x-[-50%] rounded-full',\n          className,\n        )}\n        onClick={handleScrollToBottom}\n        size=\"icon\"\n        type=\"button\"\n        variant=\"outline\"\n        {...props}\n      >\n        <ArrowDownIcon className=\"size-4\" />\n      </Button>\n    )\n  )\n}\n","'use client'\n\nimport { motion } from 'motion/react'\nimport {\n  type CSSProperties,\n  type ElementType,\n  type JSX,\n  memo,\n  useMemo,\n} from 'react'\nimport { cn } from '@/lib/utils'\n\nexport type TextShimmerProps = {\n  children: string\n  as?: ElementType\n  className?: string\n  duration?: number\n  spread?: number\n}\n\nconst ShimmerComponent = ({\n  children,\n  as: Component = 'p',\n  className,\n  duration = 2,\n  spread = 2,\n}: TextShimmerProps) => {\n  const MotionComponent = motion.create(\n    Component as keyof JSX.IntrinsicElements,\n  )\n\n  const dynamicSpread = useMemo(\n    () => (children?.length ?? 0) * spread,\n    [children, spread],\n  )\n\n  return (\n    <MotionComponent\n      animate={{ backgroundPosition: '0% center' }}\n      className={cn(\n        'relative inline-block bg-[length:250%_100%,auto] bg-clip-text text-transparent',\n        '[--bg:linear-gradient(90deg,#0000_calc(50%-var(--spread)),var(--color-background),#0000_calc(50%+var(--spread)))] [background-repeat:no-repeat,padding-box]',\n        className,\n      )}\n      initial={{ backgroundPosition: '100% center' }}\n      style={\n        {\n          '--spread': `${dynamicSpread}px`,\n          backgroundImage:\n            'var(--bg), linear-gradient(var(--color-muted-foreground), var(--color-muted-foreground))',\n        } as CSSProperties\n      }\n      transition={{\n        repeat: Number.POSITIVE_INFINITY,\n        duration,\n        ease: 'linear',\n      }}\n    >\n      {children}\n    </MotionComponent>\n  )\n}\n\n/**\n * @public\n */\nexport const Shimmer = memo(ShimmerComponent)\n","'use client'\n\nimport { useControllableState } from '@radix-ui/react-use-controllable-state'\nimport { BrainIcon, ChevronDownIcon } from 'lucide-react'\nimport type { ComponentProps } from 'react'\nimport { createContext, memo, useContext, useEffect, useState } from 'react'\nimport { Streamdown } from 'streamdown'\nimport {\n  Collapsible,\n  CollapsibleContent,\n  CollapsibleTrigger,\n} from '@/components/ui/collapsible'\nimport { cn } from '@/lib/utils'\nimport { Shimmer } from './shimmer'\n\ntype ReasoningContextValue = {\n  isStreaming: boolean\n  isOpen: boolean\n  setIsOpen: (open: boolean) => void\n  duration: number | undefined\n}\n\nconst ReasoningContext = createContext<ReasoningContextValue | null>(null)\n\nconst useReasoning = () => {\n  const context = useContext(ReasoningContext)\n  if (!context) {\n    throw new Error('Reasoning components must be used within Reasoning')\n  }\n  return context\n}\n\nexport type ReasoningProps = ComponentProps<typeof Collapsible> & {\n  isStreaming?: boolean\n  open?: boolean\n  defaultOpen?: boolean\n  onOpenChange?: (open: boolean) => void\n  duration?: number\n}\n\nconst AUTO_CLOSE_DELAY = 1000\nconst MS_IN_S = 1000\n\n/** @public */\nexport const Reasoning = memo(\n  ({\n    className,\n    isStreaming = false,\n    open,\n    defaultOpen = true,\n    onOpenChange,\n    duration: durationProp,\n    children,\n    ...props\n  }: ReasoningProps) => {\n    const [isOpen, setIsOpen] = useControllableState({\n      prop: open,\n      defaultProp: defaultOpen,\n      onChange: onOpenChange,\n    })\n    const [duration, setDuration] = useControllableState({\n      prop: durationProp,\n      defaultProp: undefined,\n    })\n\n    const [hasAutoClosed, setHasAutoClosed] = useState(false)\n    const [startTime, setStartTime] = useState<number | null>(null)\n\n    // Track duration when streaming starts and ends\n    useEffect(() => {\n      if (isStreaming) {\n        if (startTime === null) {\n          setStartTime(Date.now())\n        }\n      } else if (startTime !== null) {\n        setDuration(Math.ceil((Date.now() - startTime) / MS_IN_S))\n        setStartTime(null)\n      }\n    }, [isStreaming, startTime, setDuration])\n\n    // Auto-open when streaming starts, auto-close when streaming ends (once only)\n    useEffect(() => {\n      if (defaultOpen && !isStreaming && isOpen && !hasAutoClosed) {\n        // Add a small delay before closing to allow user to see the content\n        const timer = setTimeout(() => {\n          setIsOpen(false)\n          setHasAutoClosed(true)\n        }, AUTO_CLOSE_DELAY)\n\n        return () => clearTimeout(timer)\n      }\n    }, [isStreaming, isOpen, defaultOpen, setIsOpen, hasAutoClosed])\n\n    const handleOpenChange = (newOpen: boolean) => {\n      setIsOpen(newOpen)\n    }\n\n    return (\n      <ReasoningContext.Provider\n        value={{ isStreaming, isOpen, setIsOpen, duration }}\n      >\n        <Collapsible\n          className={cn('not-prose mb-4', className)}\n          onOpenChange={handleOpenChange}\n          open={isOpen}\n          {...props}\n        >\n          {children}\n        </Collapsible>\n      </ReasoningContext.Provider>\n    )\n  },\n)\n\nexport type ReasoningTriggerProps = ComponentProps<typeof CollapsibleTrigger>\n\nconst getThinkingMessage = (isStreaming: boolean, duration?: number) => {\n  if (isStreaming || duration === 0) {\n    return <Shimmer duration={1}>Thinking...</Shimmer>\n  }\n  if (duration === undefined) {\n    return <p>Thought for a few seconds</p>\n  }\n  return <p>Thought for {duration} seconds</p>\n}\n\n/** @public */\nexport const ReasoningTrigger = memo(\n  ({ className, children, ...props }: ReasoningTriggerProps) => {\n    const { isStreaming, isOpen, duration } = useReasoning()\n\n    return (\n      <CollapsibleTrigger\n        className={cn(\n          'flex w-full items-center gap-2 text-muted-foreground text-sm transition-colors hover:text-foreground',\n          className,\n        )}\n        {...props}\n      >\n        {children ?? (\n          <>\n            <BrainIcon className=\"size-4\" />\n            {getThinkingMessage(isStreaming, duration)}\n            <ChevronDownIcon\n              className={cn(\n                'size-4 transition-transform',\n                isOpen ? 'rotate-180' : 'rotate-0',\n              )}\n            />\n          </>\n        )}\n      </CollapsibleTrigger>\n    )\n  },\n)\n\nexport type ReasoningContentProps = ComponentProps<\n  typeof CollapsibleContent\n> & {\n  children: string\n}\n\n/** @public */\nexport const ReasoningContent = memo(\n  ({ className, children, ...props }: ReasoningContentProps) => (\n    <CollapsibleContent\n      className={cn(\n        'mt-4 text-sm',\n        'data-[state=closed]:fade-out-0 data-[state=closed]:slide-out-to-top-2 data-[state=open]:slide-in-from-top-2 text-muted-foreground outline-none data-[state=closed]:animate-out data-[state=open]:animate-in',\n        className,\n      )}\n      {...props}\n    >\n      <Streamdown {...props}>{children}</Streamdown>\n    </CollapsibleContent>\n  ),\n)\n\nReasoning.displayName = 'Reasoning'\nReasoningTrigger.displayName = 'ReasoningTrigger'\nReasoningContent.displayName = 'ReasoningContent'\n","import { CheckIcon, CopyIcon, ThumbsDownIcon, ThumbsUpIcon } from 'lucide-react'\nimport { AnimatePresence, motion } from 'motion/react'\nimport { type FC, useState } from 'react'\nimport { MessageAction, MessageActions } from '@/components/ai-elements/message'\nimport { Button } from '@/components/ui/button'\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from '@/components/ui/dialog'\nimport { Input } from '@/components/ui/input'\n\ninterface ChatMessageActionsProps {\n  messageId: string\n  messageText: string\n  liked: boolean\n  disliked: boolean\n  onClickLike: () => void\n  onClickDislike: (comment?: string) => void\n}\n\nexport const ChatMessageActions: FC<ChatMessageActionsProps> = ({\n  messageId,\n  messageText,\n  liked,\n  disliked,\n  onClickLike,\n  onClickDislike,\n}) => {\n  const [dislikeDialogOpen, setDislikeDialogOpen] = useState(false)\n  const [dislikeComment, setDislikeComment] = useState('')\n\n  const feedbackSubmitted = liked || disliked\n\n  const handleLike = () => {\n    onClickLike()\n  }\n\n  const handleDislikeClick = () => {\n    setDislikeDialogOpen(true)\n  }\n\n  const handleDislikeSubmit = () => {\n    onClickDislike(dislikeComment.trim() || undefined)\n    setDislikeDialogOpen(false)\n    setDislikeComment('')\n  }\n\n  const handleDislikeCancel = () => {\n    setDislikeDialogOpen(false)\n    setDislikeComment('')\n  }\n\n  return (\n    <MessageActions>\n      <MessageAction\n        onClick={() => navigator.clipboard.writeText(messageText)}\n        label=\"Copy\"\n        tooltip=\"Copy to clipboard\"\n      >\n        <CopyIcon className=\"size-3\" />\n      </MessageAction>\n      <AnimatePresence mode=\"wait\" initial={false}>\n        {feedbackSubmitted ? (\n          <motion.div\n            key={`${messageId}-feedback-submitted`}\n            initial={{ opacity: 0, scale: 0.8 }}\n            animate={{ opacity: 1, scale: 1 }}\n            exit={{ opacity: 0, scale: 0.8 }}\n            transition={{ duration: 0.2 }}\n            className=\"flex items-center gap-1 text-muted-foreground text-xs\"\n          >\n            <CheckIcon className=\"size-3\" />\n            <span>Feedback submitted</span>\n          </motion.div>\n        ) : (\n          <motion.div\n            key={`${messageId}-feedback-actions`}\n            initial={{ opacity: 0, scale: 0.8 }}\n            animate={{ opacity: 1, scale: 1 }}\n            exit={{ opacity: 0, scale: 0.8 }}\n            transition={{ duration: 0.2 }}\n            className=\"flex items-center gap-1\"\n          >\n            <MessageAction\n              label=\"Like\"\n              onClick={handleLike}\n              tooltip=\"Like this response\"\n            >\n              <ThumbsUpIcon\n                className=\"size-4\"\n                fill={liked ? 'currentColor' : 'none'}\n              />\n            </MessageAction>\n            <MessageAction\n              label=\"Dislike\"\n              onClick={handleDislikeClick}\n              tooltip=\"Dislike this response\"\n            >\n              <ThumbsDownIcon\n                className=\"size-4\"\n                fill={disliked ? 'currentColor' : 'none'}\n              />\n            </MessageAction>\n          </motion.div>\n        )}\n      </AnimatePresence>\n\n      <Dialog open={dislikeDialogOpen} onOpenChange={setDislikeDialogOpen}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>What went wrong?</DialogTitle>\n            <DialogDescription>\n              Help us improve by sharing what was wrong with this response.\n            </DialogDescription>\n          </DialogHeader>\n          <Input\n            placeholder=\"Add a comment (optional)\"\n            value={dislikeComment}\n            onChange={(e) => setDislikeComment(e.target.value)}\n            onKeyDown={(e) => {\n              if (e.key === 'Enter') {\n                handleDislikeSubmit()\n              }\n            }}\n          />\n          <DialogFooter>\n            <Button variant=\"outline\" onClick={handleDislikeCancel}>\n              Cancel\n            </Button>\n            <Button onClick={handleDislikeSubmit}>Submit</Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </MessageActions>\n  )\n}\n","import type { UIMessage } from 'ai'\n\nexport type ToolInvocationState =\n  | 'partial-call'\n  | 'call'\n  | 'result'\n  | 'input-streaming'\n  | 'input-available'\n  | 'output-available'\n  | 'output-error'\n\nexport interface ToolInvocationInfo {\n  state: ToolInvocationState\n  toolCallId: string\n  toolName: string\n  input: Record<string, unknown>\n  output: unknown[]\n}\n\nexport type MessageSegment =\n  | { type: 'text'; key: string; text: string }\n  | { type: 'reasoning'; key: string; text: string; isStreaming: boolean }\n  | { type: 'tool-batch'; key: string; tools: ToolInvocationInfo[] }\n\nexport const getMessageSegments = (\n  message: UIMessage,\n  isLastMessage: boolean,\n  isStreaming: boolean,\n): MessageSegment[] => {\n  const segments: MessageSegment[] = []\n  let currentToolBatch: ToolInvocationInfo[] = []\n  let textSegmentCount = 0\n  let reasoningSegmentCount = 0\n\n  const flushToolBatch = () => {\n    if (currentToolBatch.length > 0) {\n      segments.push({\n        type: 'tool-batch',\n        key: `${message.id}-tools-${currentToolBatch[0].toolCallId}`,\n        tools: [...currentToolBatch],\n      })\n      currentToolBatch = []\n    }\n  }\n\n  for (let i = 0; i < message.parts.length; i++) {\n    const part = message.parts[i]\n\n    if (part.type === 'text') {\n      flushToolBatch()\n      segments.push({\n        type: 'text',\n        key: `${message.id}-text-${textSegmentCount}`,\n        text: part.text,\n      })\n      textSegmentCount++\n    } else if (part.type === 'reasoning') {\n      flushToolBatch()\n      segments.push({\n        type: 'reasoning',\n        key: `${message.id}-reasoning-${reasoningSegmentCount}`,\n        text: part.text,\n        isStreaming:\n          isStreaming && i === message.parts.length - 1 && isLastMessage,\n      })\n      reasoningSegmentCount++\n    } else if (part.type.startsWith('tool-')) {\n      const toolPart = part as {\n        toolCallId: string\n        type: string\n        state: ToolInvocationState\n        input: Record<string, unknown>\n        output: unknown[]\n      }\n      currentToolBatch.push({\n        state: toolPart.state,\n        toolCallId: toolPart.toolCallId,\n        toolName: toolPart.type?.replace('tool-', ''),\n        input: toolPart?.input ?? {},\n        output: toolPart?.output ?? [],\n      })\n    }\n  }\n\n  flushToolBatch()\n\n  return segments\n}\n","import { MessageSquareHeart, X } from 'lucide-react'\nimport type { FC } from 'react'\nimport { Message, MessageContent } from '@/components/ai-elements/message'\nimport { Button } from '@/components/ui/button'\n\ninterface JtbdPopupProps {\n  onTakeSurvey: () => void\n  onDismiss: () => void\n}\n\nexport const JtbdPopup: FC<JtbdPopupProps> = ({ onTakeSurvey, onDismiss }) => {\n  return (\n    <Message from=\"assistant\">\n      <MessageContent>\n        <div className=\"relative rounded-lg border border-border/50 bg-card p-4 shadow-sm\">\n          <button\n            type=\"button\"\n            onClick={onDismiss}\n            className=\"absolute top-2 right-2 rounded p-1 text-muted-foreground hover:bg-accent hover:text-foreground\"\n          >\n            <X className=\"h-4 w-4\" />\n          </button>\n\n          <div className=\"flex items-start gap-3 pr-6\">\n            <MessageSquareHeart className=\"h-5 w-5 shrink-0 text-primary\" />\n            <div>\n              <p className=\"font-medium text-sm\">Help us improve BrowserOS!</p>\n              <p className=\"mt-1 text-muted-foreground text-xs\">\n                Take a quick 2-minute survey.\n              </p>\n            </div>\n          </div>\n\n          <div className=\"mt-3 flex gap-2\">\n            <Button size=\"sm\" onClick={onTakeSurvey}>\n              Take Survey\n            </Button>\n            <Button size=\"sm\" variant=\"ghost\" onClick={onDismiss}>\n              Maybe Later\n            </Button>\n          </div>\n        </div>\n      </MessageContent>\n    </Message>\n  )\n}\n","'use client'\n\nimport { ChevronDownIcon, type LucideIcon, SearchIcon } from 'lucide-react'\nimport type { ComponentProps } from 'react'\nimport {\n  Collapsible,\n  CollapsibleContent,\n  CollapsibleTrigger,\n} from '@/components/ui/collapsible'\nimport { cn } from '@/lib/utils'\n\nexport type TaskItemFileProps = ComponentProps<'div'>\n\n/** @public */\nexport const TaskItemFile = ({\n  children,\n  className,\n  ...props\n}: TaskItemFileProps) => (\n  <div\n    className={cn(\n      'inline-flex items-center gap-1 rounded-md border bg-secondary px-1.5 py-0.5 text-foreground text-xs',\n      className,\n    )}\n    {...props}\n  >\n    {children}\n  </div>\n)\n\nexport type TaskItemProps = ComponentProps<'div'>\n\n/** @public */\nexport const TaskItem = ({ children, className, ...props }: TaskItemProps) => (\n  <div className={cn('text-muted-foreground text-sm', className)} {...props}>\n    {children}\n  </div>\n)\n\nexport type TaskProps = ComponentProps<typeof Collapsible>\n\n/** @public */\nexport const Task = ({\n  defaultOpen = true,\n  className,\n  ...props\n}: TaskProps) => (\n  <Collapsible className={cn(className)} defaultOpen={defaultOpen} {...props} />\n)\n\nexport type TaskTriggerProps = ComponentProps<typeof CollapsibleTrigger> & {\n  title: string\n  TriggerIcon?: LucideIcon\n}\n\n/** @public */\nexport const TaskTrigger = ({\n  children,\n  className,\n  title,\n  TriggerIcon = SearchIcon,\n  ...props\n}: TaskTriggerProps) => (\n  <CollapsibleTrigger asChild className={cn('group', className)} {...props}>\n    {children ?? (\n      <div className=\"flex w-full cursor-pointer items-center gap-2 text-muted-foreground text-sm transition-colors hover:text-foreground\">\n        <TriggerIcon className=\"size-4\" />\n        <p className=\"text-sm\">{title}</p>\n        <ChevronDownIcon className=\"size-4 transition-transform group-data-[state=open]:rotate-180\" />\n      </div>\n    )}\n  </CollapsibleTrigger>\n)\n\nexport type TaskContentProps = ComponentProps<typeof CollapsibleContent>\n\n/** @public */\nexport const TaskContent = ({\n  children,\n  className,\n  ...props\n}: TaskContentProps) => (\n  <CollapsibleContent\n    className={cn(\n      'data-[state=closed]:fade-out-0 data-[state=closed]:slide-out-to-top-2 data-[state=open]:slide-in-from-top-2 text-popover-foreground outline-none data-[state=closed]:animate-out data-[state=open]:animate-in',\n      className,\n    )}\n    {...props}\n  >\n    <div className=\"mt-4 space-y-2 border-muted border-l-2 pl-4\">\n      {children}\n    </div>\n  </CollapsibleContent>\n)\n","import {\n  BotIcon,\n  CheckCircle2,\n  CircleDashed,\n  Loader2,\n  XCircle,\n} from 'lucide-react'\nimport type { FC } from 'react'\nimport {\n  Task,\n  TaskContent,\n  TaskItem,\n  TaskTrigger,\n} from '@/components/ai-elements/task'\nimport type {\n  ToolInvocationInfo,\n  ToolInvocationState,\n} from './getMessageSegments'\n\ninterface ToolBatchProps {\n  tools: ToolInvocationInfo[]\n  isLastBatch: boolean\n  isLastMessage: boolean\n  isStreaming: boolean\n}\n\nexport const ToolBatch: FC<ToolBatchProps> = ({\n  tools,\n  isLastBatch,\n  isLastMessage,\n  isStreaming,\n}) => {\n  const shouldBeOpen = isLastMessage && isLastBatch && isStreaming\n  const [isOpen, setIsOpen] = useState(shouldBeOpen)\n  const [hasUserInteracted, setHasUserInteracted] = useState(false)\n\n  useEffect(() => {\n    if (isLastMessage && !hasUserInteracted) {\n      if (isLastBatch) {\n        setIsOpen(isStreaming)\n      } else {\n        setIsOpen(false)\n      }\n    }\n  }, [isStreaming, isLastMessage, isLastBatch, hasUserInteracted])\n\n  const completedCount = tools.filter((t) => isToolCompleted(t.state)).length\n\n  const onManualToggle = (newState: boolean) => {\n    setHasUserInteracted(true)\n    setIsOpen(newState)\n  }\n\n  return (\n    <Task open={isOpen} onOpenChange={onManualToggle}>\n      <TaskTrigger\n        title={`${completedCount}/${tools.length} actions completed`}\n        TriggerIcon={BotIcon}\n      />\n      <TaskContent>\n        {tools.map((tool) => (\n          <TaskItem key={tool.toolCallId} className=\"flex items-center gap-2\">\n            <ToolStatusIcon state={tool.state} />\n            <span>{formatToolName(tool.toolName)}</span>\n          </TaskItem>\n        ))}\n      </TaskContent>\n    </Task>\n  )\n}\n\nconst formatToolName = (name: string) => {\n  return name\n    ?.replace(/_/g, ' ')\n    ?.replace(/([a-z])([A-Z])/g, '$1 $2')\n    ?.replace(/^./, (s) => s.toUpperCase())\n}\n\nconst isToolCompleted = (state: ToolInvocationState) =>\n  state === 'result' || state === 'output-available'\n\nconst isToolInProgress = (state: ToolInvocationState) =>\n  state === 'call' || state === 'input-available'\n\nconst isToolError = (state: ToolInvocationState) => state === 'output-error'\n\nconst ToolStatusIcon: FC<{ state: ToolInvocationState }> = ({ state }) => {\n  if (isToolCompleted(state)) {\n    return <CheckCircle2 className=\"h-3.5 w-3.5 text-green-500\" />\n  }\n  if (isToolInProgress(state)) {\n    return (\n      <Loader2 className=\"h-3.5 w-3.5 animate-spin text-[var(--accent-orange)]\" />\n    )\n  }\n  if (isToolError(state)) {\n    return <XCircle className=\"h-3.5 w-3.5 text-destructive\" />\n  }\n  return <CircleDashed className=\"h-3.5 w-3.5 text-muted-foreground\" />\n}\n","import { Bot, FileText, Globe, Sparkles } from 'lucide-react'\nimport type { FC } from 'react'\nimport type {\n  AITabAction,\n  BrowserOSAction,\n  ChatAction,\n} from '@/lib/chat-actions/types'\n\ninterface UserActionMessageProps {\n  action: ChatAction\n}\n\ninterface AttachedTabsProps {\n  tabs: chrome.tabs.Tab[]\n}\n\nconst AttachedTabs: FC<AttachedTabsProps> = ({ tabs }) => {\n  return (\n    tabs.length > 0 && (\n      <div className=\"flex flex-wrap gap-1.5\">\n        {tabs.map((tab, idx) => (\n          <div\n            key={tab.id || idx}\n            className=\"flex items-center gap-1.5 rounded-md border border-border/50 bg-accent/50 px-2 py-1\"\n          >\n            {tab.favIconUrl ? (\n              <img\n                src={tab.favIconUrl}\n                alt={tab.title}\n                className=\"h-3 w-3 object-contain\"\n              />\n            ) : (\n              <Globe className=\"h-3 w-3 text-muted-foreground\" />\n            )}\n            <span className=\"max-w-[150px] truncate text-xs\">{tab.title}</span>\n          </div>\n        ))}\n      </div>\n    )\n  )\n}\n\nconst AITabActionCard: FC<{ action: AITabAction }> = ({ action }) => {\n  return (\n    <div className=\"flex flex-col gap-2\">\n      <div className=\"flex items-center gap-2\">\n        <div className=\"flex h-8 w-8 items-center justify-center rounded-lg bg-[var(--accent-orange)]/10\">\n          <FileText className=\"h-4 w-4 text-[var(--accent-orange)]\" />\n        </div>\n        <div className=\"flex-1\">\n          <div className=\"font-medium text-foreground text-sm\">\n            {action.name}\n          </div>\n          {action.description && (\n            <div className=\"text-muted-foreground text-xs\">\n              {action.description}\n            </div>\n          )}\n        </div>\n      </div>\n      <AttachedTabs tabs={action.tabs} />\n    </div>\n  )\n}\n\nconst BrowserOSActionCard: FC<{ action: BrowserOSAction }> = ({ action }) => {\n  const isAgent = action.mode === 'agent'\n\n  return (\n    <div className=\"flex flex-col gap-2\">\n      <div className=\"flex items-start gap-2\">\n        <div className=\"flex h-8 w-8 flex-shrink-0 items-center justify-center rounded-lg bg-[var(--accent-orange)]/10\">\n          {isAgent ? (\n            <Bot className=\"h-4 w-4 text-[var(--accent-orange)]\" />\n          ) : (\n            <Sparkles className=\"h-4 w-4 text-[var(--accent-orange)]\" />\n          )}\n        </div>\n        <div className=\"flex-1\">\n          <div className=\"mb-0.5 flex items-center gap-1.5\">\n            <span className=\"rounded bg-[var(--accent-orange)]/10 px-1.5 py-0.5 font-medium text-[10px] text-[var(--accent-orange)] uppercase\">\n              {isAgent ? 'Agent' : 'Chat'}\n            </span>\n          </div>\n          <div className=\"text-foreground text-sm\">{action.message}</div>\n        </div>\n      </div>\n      {action.tabs ? <AttachedTabs tabs={action.tabs} /> : null}\n    </div>\n  )\n}\n\nexport const UserActionMessage: FC<UserActionMessageProps> = ({ action }) => {\n  switch (action.type) {\n    case 'ai-tab':\n      return <AITabActionCard action={action} />\n    case 'browseros':\n      return <BrowserOSActionCard action={action} />\n    default:\n      return null\n  }\n}\n","import type { UIMessage } from 'ai'\nimport { Bot } from 'lucide-react'\nimport { type FC, Fragment, type RefObject } from 'react'\nimport {\n  Conversation,\n  ConversationContent,\n  ConversationScrollButton,\n} from '@/components/ai-elements/conversation'\nimport {\n  Message,\n  MessageContent,\n  MessageResponse,\n} from '@/components/ai-elements/message'\nimport {\n  Reasoning,\n  ReasoningContent,\n  ReasoningTrigger,\n} from '@/components/ai-elements/reasoning'\nimport type { ChatAction } from '@/lib/chat-actions/types'\nimport { ChatMessageActions } from './ChatMessageActions'\nimport { getMessageSegments } from './getMessageSegments'\nimport { JtbdPopup } from './JtbdPopup'\nimport { ToolBatch } from './ToolBatch'\nimport { UserActionMessage } from './UserActionMessage'\n\ninterface ChatMessagesProps {\n  messages: UIMessage[]\n  status: 'streaming' | 'submitted' | 'ready' | 'error'\n  messagesEndRef: RefObject<HTMLDivElement | null>\n  getActionForMessage: (message: UIMessage) => ChatAction | undefined\n  liked: Record<string, boolean>\n  onClickLike: (messageId: string) => void\n  disliked: Record<string, boolean>\n  onClickDislike: (messageId: string, comment?: string) => void\n  showJtbdPopup: boolean\n  onTakeSurvey: () => void\n  onDismissJtbdPopup: () => void\n}\n\nexport const ChatMessages: FC<ChatMessagesProps> = ({\n  messages,\n  status,\n  messagesEndRef,\n  getActionForMessage,\n  liked,\n  disliked,\n  onClickLike,\n  onClickDislike,\n  showJtbdPopup,\n  onTakeSurvey,\n  onDismissJtbdPopup,\n}) => {\n  const isStreaming = status === 'streaming' || status === 'submitted'\n\n  return (\n    <>\n      <Conversation className=\"ph-mask\">\n        <ConversationContent>\n          {messages.map((message, messageIndex) => {\n            const action = getActionForMessage(message)\n            const isLastMessage = messageIndex === messages.length - 1\n            const segments = getMessageSegments(\n              message,\n              isLastMessage,\n              isStreaming,\n            )\n            const toolBatches = segments.filter((s) => s.type === 'tool-batch')\n            const lastToolBatchKey = toolBatches[toolBatches.length - 1]?.key\n\n            const messageText = segments\n              ?.filter((each) => each.type === 'text')\n              ?.map((each) => each.text)\n              ?.join('\\n\\n')\n\n            const likeAction = () => onClickLike(message.id)\n            const dislikeAction = (comment?: string) =>\n              onClickDislike(message.id, comment)\n\n            return (\n              <Fragment key={message.id}>\n                <Message from={message.role}>\n                  <MessageContent>\n                    {action ? (\n                      <UserActionMessage action={action} />\n                    ) : (\n                      segments.map((segment) => {\n                        switch (segment.type) {\n                          case 'text':\n                            return (\n                              <MessageResponse key={segment.key}>\n                                {segment.text}\n                              </MessageResponse>\n                            )\n                          case 'reasoning':\n                            return (\n                              <Reasoning\n                                key={segment.key}\n                                className=\"w-full\"\n                                isStreaming={segment.isStreaming}\n                              >\n                                <ReasoningTrigger />\n                                <ReasoningContent>\n                                  {segment.text}\n                                </ReasoningContent>\n                              </Reasoning>\n                            )\n                          case 'tool-batch':\n                            return (\n                              <ToolBatch\n                                key={segment.key}\n                                tools={segment.tools}\n                                isLastBatch={segment.key === lastToolBatchKey}\n                                isLastMessage={isLastMessage}\n                                isStreaming={isStreaming}\n                              />\n                            )\n                          default:\n                            return null\n                        }\n                      })\n                    )}\n                  </MessageContent>\n                </Message>\n                {message.role === 'assistant' &&\n                (!isLastMessage || !isStreaming) ? (\n                  <ChatMessageActions\n                    messageId={message.id}\n                    messageText={messageText}\n                    liked={liked[message.id] ?? false}\n                    disliked={disliked[message.id] ?? false}\n                    onClickLike={likeAction}\n                    onClickDislike={dislikeAction}\n                  />\n                ) : null}\n              </Fragment>\n            )\n          })}\n          {showJtbdPopup && (\n            <JtbdPopup\n              onTakeSurvey={onTakeSurvey}\n              onDismiss={onDismissJtbdPopup}\n            />\n          )}\n        </ConversationContent>\n        <ConversationScrollButton />\n      </Conversation>\n\n      {isStreaming && (\n        <div className=\"flex animate-fadeInUp gap-2 px-3\">\n          <div className=\"flex h-7 w-7 shrink-0 items-center justify-center rounded-full bg-[var(--accent-orange)] text-white\">\n            <Bot className=\"h-3.5 w-3.5\" />\n          </div>\n          <div className=\"flex items-center gap-1 rounded-xl rounded-tl-none border border-border/50 bg-card px-3 py-2.5 shadow-sm\">\n            <span className=\"h-1.5 w-1.5 animate-bounce rounded-full bg-[var(--accent-orange)] [animation-delay:-0.3s]\" />\n            <span className=\"h-1.5 w-1.5 animate-bounce rounded-full bg-[var(--accent-orange)] [animation-delay:-0.15s]\" />\n            <span className=\"h-1.5 w-1.5 animate-bounce rounded-full bg-[var(--accent-orange)]\" />\n          </div>\n        </div>\n      )}\n      <div ref={messagesEndRef} />\n    </>\n  )\n}\n","// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({ name: name4, message: `Invalid prompt: ${message}`, cause });\n    this[_a5] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name5, message });\n    this[_a6] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar LoadSettingError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoContentGeneratedError = class extends AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name9, message });\n    this[_a10] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchModelError = class extends AISDKError {\n  constructor({\n    errorName = name10,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: errorName, message });\n    this[_a11] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n  constructor(options) {\n    super({\n      name: name11,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a12] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n};\n_a12 = symbol12;\n\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\n\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({ name: name13, message });\n    this[_a14] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n    );\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(\n    ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n  );\n}\nexport {\n  AISDKError,\n  APICallError,\n  EmptyResponseBodyError,\n  InvalidArgumentError,\n  InvalidPromptError,\n  InvalidResponseDataError,\n  JSONParseError,\n  LoadAPIKeyError,\n  LoadSettingError,\n  NoContentGeneratedError,\n  NoSuchModelError,\n  TooManyEmbeddingValuesForCallError,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n  getErrorMessage,\n  isJSONArray,\n  isJSONObject,\n  isJSONValue\n};\n//# sourceMappingURL=index.mjs.map","class ParseError extends Error {\n  constructor(message, options) {\n    super(message), this.name = \"ParseError\", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;\n  }\n}\nfunction noop(_arg) {\n}\nfunction createParser(callbacks) {\n  if (typeof callbacks == \"function\")\n    throw new TypeError(\n      \"`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?\"\n    );\n  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;\n  let incompleteLine = \"\", isFirstChunk = !0, id, data = \"\", eventType = \"\";\n  function feed(newChunk) {\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, \"\") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);\n    for (const line of complete)\n      parseLine(line);\n    incompleteLine = incomplete, isFirstChunk = !1;\n  }\n  function parseLine(line) {\n    if (line === \"\") {\n      dispatchEvent();\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      onComment && onComment(line.slice(line.startsWith(\": \") ? 2 : 1));\n      return;\n    }\n    const fieldSeparatorIndex = line.indexOf(\":\");\n    if (fieldSeparatorIndex !== -1) {\n      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === \" \" ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);\n      processField(field, value, line);\n      return;\n    }\n    processField(line, \"\", line);\n  }\n  function processField(field, value, line) {\n    switch (field) {\n      case \"event\":\n        eventType = value;\n        break;\n      case \"data\":\n        data = `${data}${value}\n`;\n        break;\n      case \"id\":\n        id = value.includes(\"\\0\") ? void 0 : value;\n        break;\n      case \"retry\":\n        /^\\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(\n          new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n            type: \"invalid-retry\",\n            value,\n            line\n          })\n        );\n        break;\n      default:\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}\\u2026` : field}\"`,\n            { type: \"unknown-field\", field, value, line }\n          )\n        );\n        break;\n    }\n  }\n  function dispatchEvent() {\n    data.length > 0 && onEvent({\n      id,\n      event: eventType || void 0,\n      // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n      // then remove the last character from the data buffer.\n      data: data.endsWith(`\n`) ? data.slice(0, -1) : data\n    }), id = void 0, data = \"\", eventType = \"\";\n  }\n  function reset(options = {}) {\n    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = !0, id = void 0, data = \"\", eventType = \"\", incompleteLine = \"\";\n  }\n  return { feed, reset };\n}\nfunction splitLines(chunk) {\n  const lines = [];\n  let incompleteLine = \"\", searchIndex = 0;\n  for (; searchIndex < chunk.length; ) {\n    const crIndex = chunk.indexOf(\"\\r\", searchIndex), lfIndex = chunk.indexOf(`\n`, searchIndex);\n    let lineEnd = -1;\n    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {\n      incompleteLine = chunk.slice(searchIndex);\n      break;\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd);\n      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === \"\\r\" && chunk[searchIndex] === `\n` && searchIndex++;\n    }\n  }\n  return [lines, incompleteLine];\n}\nexport {\n  ParseError,\n  createParser\n};\n//# sourceMappingURL=index.js.map\n","import { createParser } from \"./index.js\";\nimport { ParseError } from \"./index.js\";\nclass EventSourceParserStream extends TransformStream {\n  constructor({ onError, onRetry, onComment } = {}) {\n    let parser;\n    super({\n      start(controller) {\n        parser = createParser({\n          onEvent: (event) => {\n            controller.enqueue(event);\n          },\n          onError(error) {\n            onError === \"terminate\" ? controller.error(error) : typeof onError == \"function\" && onError(error);\n          },\n          onRetry,\n          onComment\n        });\n      },\n      transform(chunk) {\n        parser.feed(chunk);\n      }\n    });\n  }\n}\nexport {\n  EventSourceParserStream,\n  ParseError\n};\n//# sourceMappingURL=stream.js.map\n","// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-iterator-to-readable-stream.ts\nfunction convertAsyncIteratorToReadableStream(iterator) {\n  let cancelled = false;\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      if (cancelled) return;\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    async cancel(reason) {\n      cancelled = true;\n      if (iterator.return) {\n        try {\n          await iterator.return(reason);\n        } catch (e) {\n        }\n      }\n    }\n  });\n}\n\n// src/delay.ts\nasync function delay(delayInMs, options) {\n  if (delayInMs == null) {\n    return Promise.resolve();\n  }\n  const signal = options == null ? void 0 : options.abortSignal;\n  return new Promise((resolve2, reject) => {\n    if (signal == null ? void 0 : signal.aborted) {\n      reject(createAbortError());\n      return;\n    }\n    const timeoutId = setTimeout(() => {\n      cleanup();\n      resolve2();\n    }, delayInMs);\n    const cleanup = () => {\n      clearTimeout(timeoutId);\n      signal == null ? void 0 : signal.removeEventListener(\"abort\", onAbort);\n    };\n    const onAbort = () => {\n      cleanup();\n      reject(createAbortError());\n    };\n    signal == null ? void 0 : signal.addEventListener(\"abort\", onAbort);\n  });\n}\nfunction createAbortError() {\n  return new DOMException(\"Delay was aborted\", \"AbortError\");\n}\n\n// src/delayed-promise.ts\nvar DelayedPromise = class {\n  constructor() {\n    this.status = { type: \"pending\" };\n    this._resolve = void 0;\n    this._reject = void 0;\n  }\n  get promise() {\n    if (this._promise) {\n      return this._promise;\n    }\n    this._promise = new Promise((resolve2, reject) => {\n      if (this.status.type === \"resolved\") {\n        resolve2(this.status.value);\n      } else if (this.status.type === \"rejected\") {\n        reject(this.status.error);\n      }\n      this._resolve = resolve2;\n      this._reject = reject;\n    });\n    return this._promise;\n  }\n  resolve(value) {\n    var _a;\n    this.status = { type: \"resolved\", value };\n    if (this._promise) {\n      (_a = this._resolve) == null ? void 0 : _a.call(this, value);\n    }\n  }\n  reject(error) {\n    var _a;\n    this.status = { type: \"rejected\", error };\n    if (this._promise) {\n      (_a = this._reject) == null ? void 0 : _a.call(this, error);\n    }\n  }\n  isResolved() {\n    return this.status.type === \"resolved\";\n  }\n  isRejected() {\n    return this.status.type === \"rejected\";\n  }\n  isPending() {\n    return this.status.type === \"pending\";\n  }\n};\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  return Object.fromEntries([...response.headers]);\n}\n\n// src/generate-id.ts\nimport { InvalidArgumentError } from \"@ai-sdk/provider\";\nvar createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join(\"\");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/get-from-api.ts\nimport { APICallError as APICallError2 } from \"@ai-sdk/provider\";\n\n// src/handle-fetch-error.ts\nimport { APICallError } from \"@ai-sdk/provider\";\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return (error instanceof Error || error instanceof DOMException) && (error.name === \"AbortError\" || error.name === \"ResponseAborted\" || // Next.js\n  error.name === \"TimeoutError\");\n}\n\n// src/handle-fetch-error.ts\nvar FETCH_FAILED_ERROR_MESSAGES = [\"fetch failed\", \"failed to fetch\"];\nfunction handleFetchError({\n  error,\n  url,\n  requestBodyValues\n}) {\n  if (isAbortError(error)) {\n    return error;\n  }\n  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {\n    const cause = error.cause;\n    if (cause != null) {\n      return new APICallError({\n        message: `Cannot connect to API: ${cause.message}`,\n        cause,\n        url,\n        requestBodyValues,\n        isRetryable: true\n        // retry when network error\n      });\n    }\n  }\n  return error;\n}\n\n// src/get-runtime-environment-user-agent.ts\nfunction getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {\n  var _a, _b, _c;\n  if (globalThisAny.window) {\n    return `runtime/browser`;\n  }\n  if ((_a = globalThisAny.navigator) == null ? void 0 : _a.userAgent) {\n    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;\n  }\n  if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {\n    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;\n  }\n  if (globalThisAny.EdgeRuntime) {\n    return `runtime/vercel-edge`;\n  }\n  return \"runtime/unknown\";\n}\n\n// src/normalize-headers.ts\nfunction normalizeHeaders(headers) {\n  if (headers == null) {\n    return {};\n  }\n  const normalized = {};\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => {\n      normalized[key.toLowerCase()] = value;\n    });\n  } else {\n    if (!Array.isArray(headers)) {\n      headers = Object.entries(headers);\n    }\n    for (const [key, value] of headers) {\n      if (value != null) {\n        normalized[key.toLowerCase()] = value;\n      }\n    }\n  }\n  return normalized;\n}\n\n// src/with-user-agent-suffix.ts\nfunction withUserAgentSuffix(headers, ...userAgentSuffixParts) {\n  const normalizedHeaders = new Headers(normalizeHeaders(headers));\n  const currentUserAgentHeader = normalizedHeaders.get(\"user-agent\") || \"\";\n  normalizedHeaders.set(\n    \"user-agent\",\n    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(\" \")\n  );\n  return Object.fromEntries(normalizedHeaders.entries());\n}\n\n// src/version.ts\nvar VERSION = true ? \"3.0.19\" : \"0.0.0-test\";\n\n// src/get-from-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar getFromApi = async ({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/provider-utils/${VERSION}`,\n        getRuntimeEnvironmentUserAgent()\n      ),\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {}\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError2.isInstance(error)) {\n          throw error;\n        }\n        throw new APICallError2({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {}\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {}\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError2.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new APICallError2({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {}\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: {} });\n  }\n};\n\n// src/inject-json-instruction.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nvar DEFAULT_GENERIC_SUFFIX = \"You MUST answer with JSON.\";\nfunction injectJsonInstruction({\n  prompt,\n  schema,\n  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,\n  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX\n}) {\n  return [\n    prompt != null && prompt.length > 0 ? prompt : void 0,\n    prompt != null && prompt.length > 0 ? \"\" : void 0,\n    // add a newline if prompt is not null\n    schemaPrefix,\n    schema != null ? JSON.stringify(schema) : void 0,\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\nfunction injectJsonInstructionIntoMessages({\n  messages,\n  schema,\n  schemaPrefix,\n  schemaSuffix\n}) {\n  var _a, _b;\n  const systemMessage = ((_a = messages[0]) == null ? void 0 : _a.role) === \"system\" ? { ...messages[0] } : { role: \"system\", content: \"\" };\n  systemMessage.content = injectJsonInstruction({\n    prompt: systemMessage.content,\n    schema,\n    schemaPrefix,\n    schemaSuffix\n  });\n  return [\n    systemMessage,\n    ...((_b = messages[0]) == null ? void 0 : _b.role) === \"system\" ? messages.slice(1) : messages\n  ];\n}\n\n// src/is-url-supported.ts\nfunction isUrlSupported({\n  mediaType,\n  url,\n  supportedUrls\n}) {\n  url = url.toLowerCase();\n  mediaType = mediaType.toLowerCase();\n  return Object.entries(supportedUrls).map(([key, value]) => {\n    const mediaType2 = key.toLowerCase();\n    return mediaType2 === \"*\" || mediaType2 === \"*/*\" ? { mediaTypePrefix: \"\", regexes: value } : { mediaTypePrefix: mediaType2.replace(/\\*/, \"\"), regexes: value };\n  }).filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix)).flatMap(({ regexes }) => regexes).some((pattern) => pattern.test(url));\n}\n\n// src/load-api-key.ts\nimport { LoadAPIKeyError } from \"@ai-sdk/provider\";\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/load-setting.ts\nimport { LoadSettingError } from \"@ai-sdk/provider\";\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/media-type-to-extension.ts\nfunction mediaTypeToExtension(mediaType) {\n  var _a;\n  const [_type, subtype = \"\"] = mediaType.toLowerCase().split(\"/\");\n  return (_a = {\n    mpeg: \"mp3\",\n    \"x-wav\": \"wav\",\n    opus: \"ogg\",\n    mp4: \"m4a\",\n    \"x-m4a\": \"m4a\"\n  }[subtype]) != null ? _a : subtype;\n}\n\n// src/parse-json.ts\nimport {\n  JSONParseError,\n  TypeValidationError as TypeValidationError3\n} from \"@ai-sdk/provider\";\n\n// src/secure-json-parse.ts\nvar suspectProtoRx = /\"__proto__\"\\s*:/;\nvar suspectConstructorRx = /\"constructor\"\\s*:/;\nfunction _parse(text) {\n  const obj = JSON.parse(text);\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n    return obj;\n  }\n  return filter(obj);\n}\nfunction filter(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, \"constructor\") && Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === \"object\") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse(text) {\n  const { stackTraceLimit } = Error;\n  try {\n    Error.stackTraceLimit = 0;\n  } catch (e) {\n    return _parse(text);\n  }\n  try {\n    return _parse(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\n\n// src/validate-types.ts\nimport { TypeValidationError as TypeValidationError2 } from \"@ai-sdk/provider\";\n\n// src/validator.ts\nimport { TypeValidationError } from \"@ai-sdk/provider\";\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction lazyValidator(createValidator) {\n  let validator2;\n  return () => {\n    if (validator2 == null) {\n      validator2 = createValidator();\n    }\n    return validator2;\n  };\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : typeof value === \"function\" ? value() : standardSchemaValidator(value);\n}\nfunction standardSchemaValidator(standardSchema) {\n  return validator(async (value) => {\n    const result = await standardSchema[\"~standard\"].validate(value);\n    return result.issues == null ? { success: true, value: result.value } : {\n      success: false,\n      error: new TypeValidationError({\n        value,\n        cause: result.issues\n      })\n    };\n  });\n}\n\n// src/validate-types.ts\nasync function validateTypes({\n  value,\n  schema\n}) {\n  const result = await safeValidateTypes({ value, schema });\n  if (!result.success) {\n    throw TypeValidationError2.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nasync function safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const result = await validator2.validate(value);\n    if (result.success) {\n      return { success: true, value: result.value, rawValue: value };\n    }\n    return {\n      success: false,\n      error: TypeValidationError2.wrap({ value, cause: result.error }),\n      rawValue: value\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError2.wrap({ value, cause: error }),\n      rawValue: value\n    };\n  }\n}\n\n// src/parse-json.ts\nasync function parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (JSONParseError.isInstance(error) || TypeValidationError3.isInstance(error)) {\n      throw error;\n    }\n    throw new JSONParseError({ text, cause: error });\n  }\n}\nasync function safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    return await safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text, cause: error }),\n      rawValue: void 0\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secureJsonParse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// src/parse-json-event-stream.ts\nimport {\n  EventSourceParserStream\n} from \"eventsource-parser/stream\";\nfunction parseJsonEventStream({\n  stream,\n  schema\n}) {\n  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(\n    new TransformStream({\n      async transform({ data }, controller) {\n        if (data === \"[DONE]\") {\n          return;\n        }\n        controller.enqueue(await safeParseJSON({ text: data, schema }));\n      }\n    })\n  );\n}\n\n// src/parse-provider-options.ts\nimport { InvalidArgumentError as InvalidArgumentError2 } from \"@ai-sdk/provider\";\nasync function parseProviderOptions({\n  provider,\n  providerOptions,\n  schema\n}) {\n  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {\n    return void 0;\n  }\n  const parsedProviderOptions = await safeValidateTypes({\n    value: providerOptions[provider],\n    schema\n  });\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError2({\n      argument: \"providerOptions\",\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error\n    });\n  }\n  return parsedProviderOptions.value;\n}\n\n// src/post-to-api.ts\nimport { APICallError as APICallError3 } from \"@ai-sdk/provider\";\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postFormDataToApi = async ({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers,\n  body: {\n    content: formData,\n    values: Object.fromEntries(formData.entries())\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/provider-utils/${VERSION}`,\n        getRuntimeEnvironmentUserAgent()\n      ),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError3.isInstance(error)) {\n          throw error;\n        }\n        throw new APICallError3({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError3.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new APICallError3({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: body.values });\n  }\n};\n\n// src/types/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\nfunction dynamicTool(tool2) {\n  return { ...tool2, type: \"dynamic\" };\n}\n\n// src/provider-defined-tool-factory.ts\nfunction createProviderDefinedToolFactory({\n  id,\n  name,\n  inputSchema\n}) {\n  return ({\n    execute,\n    outputSchema,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }) => tool({\n    type: \"provider-defined\",\n    id,\n    name,\n    args,\n    inputSchema,\n    outputSchema,\n    execute,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable\n  });\n}\nfunction createProviderDefinedToolFactoryWithOutputSchema({\n  id,\n  name,\n  inputSchema,\n  outputSchema\n}) {\n  return ({\n    execute,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable,\n    ...args\n  }) => tool({\n    type: \"provider-defined\",\n    id,\n    name,\n    args,\n    inputSchema,\n    outputSchema,\n    execute,\n    toModelOutput,\n    onInputStart,\n    onInputDelta,\n    onInputAvailable\n  });\n}\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/resolve.ts\nasync function resolve(value) {\n  if (typeof value === \"function\") {\n    value = value();\n  }\n  return Promise.resolve(value);\n}\n\n// src/response-handler.ts\nimport { APICallError as APICallError4, EmptyResponseBodyError } from \"@ai-sdk/provider\";\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new APICallError4({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = await parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new APICallError4({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new APICallError4({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: parseJsonEventStream({\n      stream: response.body,\n      schema: chunkSchema\n    })\n  };\n};\nvar createJsonStreamResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n      new TransformStream({\n        async transform(chunkText, controller) {\n          if (chunkText.endsWith(\"\\n\")) {\n            controller.enqueue(\n              await safeParseJSON({\n                text: buffer + chunkText,\n                schema: chunkSchema\n              })\n            );\n            buffer = \"\";\n          } else {\n            buffer += chunkText;\n          }\n        }\n      })\n    )\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = await safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new APICallError4({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (!response.body) {\n    throw new APICallError4({\n      message: \"Response body is empty\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0\n    });\n  }\n  try {\n    const buffer = await response.arrayBuffer();\n    return {\n      responseHeaders,\n      value: new Uint8Array(buffer)\n    };\n  } catch (error) {\n    throw new APICallError4({\n      message: \"Failed to read response as array buffer\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0,\n      cause: error\n    });\n  }\n};\nvar createStatusCodeErrorResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  const responseBody = await response.text();\n  return {\n    responseHeaders,\n    value: new APICallError4({\n      message: response.statusText,\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody\n    })\n  };\n};\n\n// src/zod-schema.ts\nimport * as z4 from \"zod/v4\";\n\n// src/add-additional-properties-to-json-schema.ts\nfunction addAdditionalPropertiesToJsonSchema(jsonSchema2) {\n  if (jsonSchema2.type === \"object\") {\n    jsonSchema2.additionalProperties = false;\n    const properties = jsonSchema2.properties;\n    if (properties != null) {\n      for (const property in properties) {\n        properties[property] = addAdditionalPropertiesToJsonSchema(\n          properties[property]\n        );\n      }\n    }\n  }\n  if (jsonSchema2.type === \"array\" && jsonSchema2.items != null) {\n    if (Array.isArray(jsonSchema2.items)) {\n      jsonSchema2.items = jsonSchema2.items.map(\n        (item) => addAdditionalPropertiesToJsonSchema(item)\n      );\n    } else {\n      jsonSchema2.items = addAdditionalPropertiesToJsonSchema(\n        jsonSchema2.items\n      );\n    }\n  }\n  return jsonSchema2;\n}\n\n// src/zod-to-json-schema/get-relative-path.ts\nvar getRelativePath = (pathA, pathB) => {\n  let i = 0;\n  for (; i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i]) break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\n\n// src/zod-to-json-schema/options.ts\nvar ignoreOverride = Symbol(\n  \"Let zodToJsonSchema decide on which parser to use\"\n);\nvar defaultOptions = {\n  name: void 0,\n  $refStrategy: \"root\",\n  basePath: [\"#\"],\n  effectStrategy: \"input\",\n  pipeStrategy: \"all\",\n  dateStrategy: \"format:date-time\",\n  mapStrategy: \"entries\",\n  removeAdditionalStrategy: \"passthrough\",\n  allowedAdditionalProperties: true,\n  rejectedAdditionalProperties: false,\n  definitionPath: \"definitions\",\n  strictUnions: false,\n  definitions: {},\n  errorMessages: false,\n  patternStrategy: \"escape\",\n  applyRegexFlags: false,\n  emailStrategy: \"format:email\",\n  base64Strategy: \"contentEncoding:base64\",\n  nameStrategy: \"ref\"\n};\nvar getDefaultOptions = (options) => typeof options === \"string\" ? {\n  ...defaultOptions,\n  name: options\n} : {\n  ...defaultOptions,\n  ...options\n};\n\n// src/zod-to-json-schema/select-parser.ts\nimport { ZodFirstPartyTypeKind as ZodFirstPartyTypeKind3 } from \"zod/v3\";\n\n// src/zod-to-json-schema/parsers/any.ts\nfunction parseAnyDef() {\n  return {};\n}\n\n// src/zod-to-json-schema/parsers/array.ts\nimport { ZodFirstPartyTypeKind } from \"zod/v3\";\nfunction parseArrayDef(def, refs) {\n  var _a, _b, _c;\n  const res = {\n    type: \"array\"\n  };\n  if (((_a = def.type) == null ? void 0 : _a._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {\n    res.items = parseDef(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"items\"]\n    });\n  }\n  if (def.minLength) {\n    res.minItems = def.minLength.value;\n  }\n  if (def.maxLength) {\n    res.maxItems = def.maxLength.value;\n  }\n  if (def.exactLength) {\n    res.minItems = def.exactLength.value;\n    res.maxItems = def.exactLength.value;\n  }\n  return res;\n}\n\n// src/zod-to-json-schema/parsers/bigint.ts\nfunction parseBigintDef(def) {\n  const res = {\n    type: \"integer\",\n    format: \"int64\"\n  };\n  if (!def.checks) return res;\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        if (check.inclusive) {\n          res.minimum = check.value;\n        } else {\n          res.exclusiveMinimum = check.value;\n        }\n        break;\n      case \"max\":\n        if (check.inclusive) {\n          res.maximum = check.value;\n        } else {\n          res.exclusiveMaximum = check.value;\n        }\n        break;\n      case \"multipleOf\":\n        res.multipleOf = check.value;\n        break;\n    }\n  }\n  return res;\n}\n\n// src/zod-to-json-schema/parsers/boolean.ts\nfunction parseBooleanDef() {\n  return { type: \"boolean\" };\n}\n\n// src/zod-to-json-schema/parsers/branded.ts\nfunction parseBrandedDef(_def, refs) {\n  return parseDef(_def.type._def, refs);\n}\n\n// src/zod-to-json-schema/parsers/catch.ts\nvar parseCatchDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n\n// src/zod-to-json-schema/parsers/date.ts\nfunction parseDateDef(def, refs, overrideDateStrategy) {\n  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))\n    };\n  }\n  switch (strategy) {\n    case \"string\":\n    case \"format:date-time\":\n      return {\n        type: \"string\",\n        format: \"date-time\"\n      };\n    case \"format:date\":\n      return {\n        type: \"string\",\n        format: \"date\"\n      };\n    case \"integer\":\n      return integerDateParser(def);\n  }\n}\nvar integerDateParser = (def) => {\n  const res = {\n    type: \"integer\",\n    format: \"unix-time\"\n  };\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        res.minimum = check.value;\n        break;\n      case \"max\":\n        res.maximum = check.value;\n        break;\n    }\n  }\n  return res;\n};\n\n// src/zod-to-json-schema/parsers/default.ts\nfunction parseDefaultDef(_def, refs) {\n  return {\n    ...parseDef(_def.innerType._def, refs),\n    default: _def.defaultValue()\n  };\n}\n\n// src/zod-to-json-schema/parsers/effects.ts\nfunction parseEffectsDef(_def, refs) {\n  return refs.effectStrategy === \"input\" ? parseDef(_def.schema._def, refs) : parseAnyDef();\n}\n\n// src/zod-to-json-schema/parsers/enum.ts\nfunction parseEnumDef(def) {\n  return {\n    type: \"string\",\n    enum: Array.from(def.values)\n  };\n}\n\n// src/zod-to-json-schema/parsers/intersection.ts\nvar isJsonSchema7AllOfType = (type) => {\n  if (\"type\" in type && type.type === \"string\") return false;\n  return \"allOf\" in type;\n};\nfunction parseIntersectionDef(def, refs) {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"1\"]\n    })\n  ].filter((x) => !!x);\n  const mergedAllOf = [];\n  allOf.forEach((schema) => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n    } else {\n      let nestedSchema = schema;\n      if (\"additionalProperties\" in schema && schema.additionalProperties === false) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;\n}\n\n// src/zod-to-json-schema/parsers/literal.ts\nfunction parseLiteralDef(def) {\n  const parsedType = typeof def.value;\n  if (parsedType !== \"bigint\" && parsedType !== \"number\" && parsedType !== \"boolean\" && parsedType !== \"string\") {\n    return {\n      type: Array.isArray(def.value) ? \"array\" : \"object\"\n    };\n  }\n  return {\n    type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n    const: def.value\n  };\n}\n\n// src/zod-to-json-schema/parsers/record.ts\nimport {\n  ZodFirstPartyTypeKind as ZodFirstPartyTypeKind2\n} from \"zod/v3\";\n\n// src/zod-to-json-schema/parsers/string.ts\nvar emojiRegex = void 0;\nvar zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === void 0) {\n      emojiRegex = RegExp(\n        \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\",\n        \"u\"\n      );\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/\n};\nfunction parseStringDef(def, refs) {\n  const res = {\n    type: \"string\"\n  };\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case \"min\":\n          res.minLength = typeof res.minLength === \"number\" ? Math.max(res.minLength, check.value) : check.value;\n          break;\n        case \"max\":\n          res.maxLength = typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check.value) : check.value;\n          break;\n        case \"email\":\n          switch (refs.emailStrategy) {\n            case \"format:email\":\n              addFormat(res, \"email\", check.message, refs);\n              break;\n            case \"format:idn-email\":\n              addFormat(res, \"idn-email\", check.message, refs);\n              break;\n            case \"pattern:zod\":\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n          break;\n        case \"url\":\n          addFormat(res, \"uri\", check.message, refs);\n          break;\n        case \"uuid\":\n          addFormat(res, \"uuid\", check.message, refs);\n          break;\n        case \"regex\":\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case \"cuid\":\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case \"cuid2\":\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case \"startsWith\":\n          addPattern(\n            res,\n            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),\n            check.message,\n            refs\n          );\n          break;\n        case \"endsWith\":\n          addPattern(\n            res,\n            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),\n            check.message,\n            refs\n          );\n          break;\n        case \"datetime\":\n          addFormat(res, \"date-time\", check.message, refs);\n          break;\n        case \"date\":\n          addFormat(res, \"date\", check.message, refs);\n          break;\n        case \"time\":\n          addFormat(res, \"time\", check.message, refs);\n          break;\n        case \"duration\":\n          addFormat(res, \"duration\", check.message, refs);\n          break;\n        case \"length\":\n          res.minLength = typeof res.minLength === \"number\" ? Math.max(res.minLength, check.value) : check.value;\n          res.maxLength = typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check.value) : check.value;\n          break;\n        case \"includes\": {\n          addPattern(\n            res,\n            RegExp(escapeLiteralCheckValue(check.value, refs)),\n            check.message,\n            refs\n          );\n          break;\n        }\n        case \"ip\": {\n          if (check.version !== \"v6\") {\n            addFormat(res, \"ipv4\", check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addFormat(res, \"ipv6\", check.message, refs);\n          }\n          break;\n        }\n        case \"base64url\":\n          addPattern(res, zodPatterns.base64url, check.message, refs);\n          break;\n        case \"jwt\":\n          addPattern(res, zodPatterns.jwt, check.message, refs);\n          break;\n        case \"cidr\": {\n          if (check.version !== \"v6\") {\n            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n          }\n          break;\n        }\n        case \"emoji\":\n          addPattern(res, zodPatterns.emoji(), check.message, refs);\n          break;\n        case \"ulid\": {\n          addPattern(res, zodPatterns.ulid, check.message, refs);\n          break;\n        }\n        case \"base64\": {\n          switch (refs.base64Strategy) {\n            case \"format:binary\": {\n              addFormat(res, \"binary\", check.message, refs);\n              break;\n            }\n            case \"contentEncoding:base64\": {\n              res.contentEncoding = \"base64\";\n              break;\n            }\n            case \"pattern:zod\": {\n              addPattern(res, zodPatterns.base64, check.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case \"nanoid\": {\n          addPattern(res, zodPatterns.nanoid, check.message, refs);\n        }\n        case \"toLowerCase\":\n        case \"toUpperCase\":\n        case \"trim\":\n          break;\n        default:\n          /* @__PURE__ */ ((_) => {\n          })(check);\n      }\n    }\n  }\n  return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n  return refs.patternStrategy === \"escape\" ? escapeNonAlphaNumeric(literal) : literal;\n}\nvar ALPHA_NUMERIC = new Set(\n  \"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\"\n);\nfunction escapeNonAlphaNumeric(source) {\n  let result = \"\";\n  for (let i = 0; i < source.length; i++) {\n    if (!ALPHA_NUMERIC.has(source[i])) {\n      result += \"\\\\\";\n    }\n    result += source[i];\n  }\n  return result;\n}\nfunction addFormat(schema, value, message, refs) {\n  var _a;\n  if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n    if (schema.format) {\n      schema.anyOf.push({\n        format: schema.format\n      });\n      delete schema.format;\n    }\n    schema.anyOf.push({\n      format: value,\n      ...message && refs.errorMessages && { errorMessage: { format: message } }\n    });\n  } else {\n    schema.format = value;\n  }\n}\nfunction addPattern(schema, regex, message, refs) {\n  var _a;\n  if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n    if (schema.pattern) {\n      schema.allOf.push({\n        pattern: schema.pattern\n      });\n      delete schema.pattern;\n    }\n    schema.allOf.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...message && refs.errorMessages && { errorMessage: { pattern: message } }\n    });\n  } else {\n    schema.pattern = stringifyRegExpWithFlags(regex, refs);\n  }\n}\nfunction stringifyRegExpWithFlags(regex, refs) {\n  var _a;\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n  const flags = {\n    i: regex.flags.includes(\"i\"),\n    // Case-insensitive\n    m: regex.flags.includes(\"m\"),\n    // `^` and `$` matches adjacent to newline characters\n    s: regex.flags.includes(\"s\")\n    // `.` matches newlines\n  };\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = \"\";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === \"-\" && ((_a = source[i + 2]) == null ? void 0 : _a.match(/[a-z]/))) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n    if (flags.m) {\n      if (source[i] === \"^\") {\n        pattern += `(^|(?<=[\\r\n]))`;\n        continue;\n      } else if (source[i] === \"$\") {\n        pattern += `($|(?=[\\r\n]))`;\n        continue;\n      }\n    }\n    if (flags.s && source[i] === \".\") {\n      pattern += inCharGroup ? `${source[i]}\\r\n` : `[${source[i]}\\r\n]`;\n      continue;\n    }\n    pattern += source[i];\n    if (source[i] === \"\\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === \"]\") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === \"[\") {\n      inCharGroup = true;\n    }\n  }\n  try {\n    new RegExp(pattern);\n  } catch (e) {\n    console.warn(\n      `Could not convert regex pattern at ${refs.currentPath.join(\n        \"/\"\n      )} to a flag-independent form! Falling back to the flag-ignorant source`\n    );\n    return regex.source;\n  }\n  return pattern;\n}\n\n// src/zod-to-json-schema/parsers/record.ts\nfunction parseRecordDef(def, refs) {\n  var _a, _b, _c, _d, _e, _f;\n  const schema = {\n    type: \"object\",\n    additionalProperties: (_a = parseDef(def.valueType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    })) != null ? _a : refs.allowedAdditionalProperties\n  };\n  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind2.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {\n    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind2.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values\n      }\n    };\n  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind2.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind2.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {\n    const { type, ...keyType } = parseBrandedDef(\n      def.keyType._def,\n      refs\n    );\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  }\n  return schema;\n}\n\n// src/zod-to-json-schema/parsers/map.ts\nfunction parseMapDef(def, refs) {\n  if (refs.mapStrategy === \"record\") {\n    return parseRecordDef(def, refs);\n  }\n  const keys = parseDef(def.keyType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"]\n  }) || parseAnyDef();\n  const values = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"]\n  }) || parseAnyDef();\n  return {\n    type: \"array\",\n    maxItems: 125,\n    items: {\n      type: \"array\",\n      items: [keys, values],\n      minItems: 2,\n      maxItems: 2\n    }\n  };\n}\n\n// src/zod-to-json-schema/parsers/native-enum.ts\nfunction parseNativeEnumDef(def) {\n  const object = def.values;\n  const actualKeys = Object.keys(def.values).filter((key) => {\n    return typeof object[object[key]] !== \"number\";\n  });\n  const actualValues = actualKeys.map((key) => object[key]);\n  const parsedTypes = Array.from(\n    new Set(actualValues.map((values) => typeof values))\n  );\n  return {\n    type: parsedTypes.length === 1 ? parsedTypes[0] === \"string\" ? \"string\" : \"number\" : [\"string\", \"number\"],\n    enum: actualValues\n  };\n}\n\n// src/zod-to-json-schema/parsers/never.ts\nfunction parseNeverDef() {\n  return { not: parseAnyDef() };\n}\n\n// src/zod-to-json-schema/parsers/null.ts\nfunction parseNullDef() {\n  return {\n    type: \"null\"\n  };\n}\n\n// src/zod-to-json-schema/parsers/union.ts\nvar primitiveMappings = {\n  ZodString: \"string\",\n  ZodNumber: \"number\",\n  ZodBigInt: \"integer\",\n  ZodBoolean: \"boolean\",\n  ZodNull: \"null\"\n};\nfunction parseUnionDef(def, refs) {\n  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n  if (options.every(\n    (x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length)\n  )) {\n    const types = options.reduce((types2, x) => {\n      const type = primitiveMappings[x._def.typeName];\n      return type && !types2.includes(type) ? [...types2, type] : types2;\n    }, []);\n    return {\n      type: types.length > 1 ? types : types[0]\n    };\n  } else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n    const types = options.reduce(\n      (acc, x) => {\n        const type = typeof x._def.value;\n        switch (type) {\n          case \"string\":\n          case \"number\":\n          case \"boolean\":\n            return [...acc, type];\n          case \"bigint\":\n            return [...acc, \"integer\"];\n          case \"object\":\n            if (x._def.value === null) return [...acc, \"null\"];\n          case \"symbol\":\n          case \"undefined\":\n          case \"function\":\n          default:\n            return acc;\n        }\n      },\n      []\n    );\n    if (types.length === options.length) {\n      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce(\n          (acc, x) => {\n            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n          },\n          []\n        )\n      };\n    }\n  } else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n    return {\n      type: \"string\",\n      enum: options.reduce(\n        (acc, x) => [\n          ...acc,\n          ...x._def.values.filter((x2) => !acc.includes(x2))\n        ],\n        []\n      )\n    };\n  }\n  return asAnyOf(def, refs);\n}\nvar asAnyOf = (def, refs) => {\n  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(\n    (x, i) => parseDef(x._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"anyOf\", `${i}`]\n    })\n  ).filter(\n    (x) => !!x && (!refs.strictUnions || typeof x === \"object\" && Object.keys(x).length > 0)\n  );\n  return anyOf.length ? { anyOf } : void 0;\n};\n\n// src/zod-to-json-schema/parsers/nullable.ts\nfunction parseNullableDef(def, refs) {\n  if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(\n    def.innerType._def.typeName\n  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n    return {\n      type: [\n        primitiveMappings[def.innerType._def.typeName],\n        \"null\"\n      ]\n    };\n  }\n  const base = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"0\"]\n  });\n  return base && { anyOf: [base, { type: \"null\" }] };\n}\n\n// src/zod-to-json-schema/parsers/number.ts\nfunction parseNumberDef(def) {\n  const res = {\n    type: \"number\"\n  };\n  if (!def.checks) return res;\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"int\":\n        res.type = \"integer\";\n        break;\n      case \"min\":\n        if (check.inclusive) {\n          res.minimum = check.value;\n        } else {\n          res.exclusiveMinimum = check.value;\n        }\n        break;\n      case \"max\":\n        if (check.inclusive) {\n          res.maximum = check.value;\n        } else {\n          res.exclusiveMaximum = check.value;\n        }\n        break;\n      case \"multipleOf\":\n        res.multipleOf = check.value;\n        break;\n    }\n  }\n  return res;\n}\n\n// src/zod-to-json-schema/parsers/object.ts\nfunction parseObjectDef(def, refs) {\n  const result = {\n    type: \"object\",\n    properties: {}\n  };\n  const required = [];\n  const shape = def.shape();\n  for (const propName in shape) {\n    let propDef = shape[propName];\n    if (propDef === void 0 || propDef._def === void 0) {\n      continue;\n    }\n    const propOptional = safeIsOptional(propDef);\n    const parsedDef = parseDef(propDef._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"properties\", propName],\n      propertyPath: [...refs.currentPath, \"properties\", propName]\n    });\n    if (parsedDef === void 0) {\n      continue;\n    }\n    result.properties[propName] = parsedDef;\n    if (!propOptional) {\n      required.push(propName);\n    }\n  }\n  if (required.length) {\n    result.required = required;\n  }\n  const additionalProperties = decideAdditionalProperties(def, refs);\n  if (additionalProperties !== void 0) {\n    result.additionalProperties = additionalProperties;\n  }\n  return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n  if (def.catchall._def.typeName !== \"ZodNever\") {\n    return parseDef(def.catchall._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    });\n  }\n  switch (def.unknownKeys) {\n    case \"passthrough\":\n      return refs.allowedAdditionalProperties;\n    case \"strict\":\n      return refs.rejectedAdditionalProperties;\n    case \"strip\":\n      return refs.removeAdditionalStrategy === \"strict\" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;\n  }\n}\nfunction safeIsOptional(schema) {\n  try {\n    return schema.isOptional();\n  } catch (e) {\n    return true;\n  }\n}\n\n// src/zod-to-json-schema/parsers/optional.ts\nvar parseOptionalDef = (def, refs) => {\n  var _a;\n  if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {\n    return parseDef(def.innerType._def, refs);\n  }\n  const innerSchema = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"1\"]\n  });\n  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();\n};\n\n// src/zod-to-json-schema/parsers/pipeline.ts\nvar parsePipelineDef = (def, refs) => {\n  if (refs.pipeStrategy === \"input\") {\n    return parseDef(def.in._def, refs);\n  } else if (refs.pipeStrategy === \"output\") {\n    return parseDef(def.out._def, refs);\n  }\n  const a = parseDef(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n  });\n  const b = parseDef(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"]\n  });\n  return {\n    allOf: [a, b].filter((x) => x !== void 0)\n  };\n};\n\n// src/zod-to-json-schema/parsers/promise.ts\nfunction parsePromiseDef(def, refs) {\n  return parseDef(def.type._def, refs);\n}\n\n// src/zod-to-json-schema/parsers/set.ts\nfunction parseSetDef(def, refs) {\n  const items = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\"]\n  });\n  const schema = {\n    type: \"array\",\n    uniqueItems: true,\n    items\n  };\n  if (def.minSize) {\n    schema.minItems = def.minSize.value;\n  }\n  if (def.maxSize) {\n    schema.maxItems = def.maxSize.value;\n  }\n  return schema;\n}\n\n// src/zod-to-json-schema/parsers/tuple.ts\nfunction parseTupleDef(def, refs) {\n  if (def.rest) {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      items: def.items.map(\n        (x, i) => parseDef(x._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, \"items\", `${i}`]\n        })\n      ).reduce(\n        (acc, x) => x === void 0 ? acc : [...acc, x],\n        []\n      ),\n      additionalItems: parseDef(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"additionalItems\"]\n      })\n    };\n  } else {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items.map(\n        (x, i) => parseDef(x._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, \"items\", `${i}`]\n        })\n      ).reduce(\n        (acc, x) => x === void 0 ? acc : [...acc, x],\n        []\n      )\n    };\n  }\n}\n\n// src/zod-to-json-schema/parsers/undefined.ts\nfunction parseUndefinedDef() {\n  return {\n    not: parseAnyDef()\n  };\n}\n\n// src/zod-to-json-schema/parsers/unknown.ts\nfunction parseUnknownDef() {\n  return parseAnyDef();\n}\n\n// src/zod-to-json-schema/parsers/readonly.ts\nvar parseReadonlyDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n\n// src/zod-to-json-schema/select-parser.ts\nvar selectParser = (def, typeName, refs) => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind3.ZodString:\n      return parseStringDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodNumber:\n      return parseNumberDef(def);\n    case ZodFirstPartyTypeKind3.ZodObject:\n      return parseObjectDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodBigInt:\n      return parseBigintDef(def);\n    case ZodFirstPartyTypeKind3.ZodBoolean:\n      return parseBooleanDef();\n    case ZodFirstPartyTypeKind3.ZodDate:\n      return parseDateDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodUndefined:\n      return parseUndefinedDef();\n    case ZodFirstPartyTypeKind3.ZodNull:\n      return parseNullDef();\n    case ZodFirstPartyTypeKind3.ZodArray:\n      return parseArrayDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodUnion:\n    case ZodFirstPartyTypeKind3.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodTuple:\n      return parseTupleDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodRecord:\n      return parseRecordDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodLiteral:\n      return parseLiteralDef(def);\n    case ZodFirstPartyTypeKind3.ZodEnum:\n      return parseEnumDef(def);\n    case ZodFirstPartyTypeKind3.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case ZodFirstPartyTypeKind3.ZodNullable:\n      return parseNullableDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodMap:\n      return parseMapDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodSet:\n      return parseSetDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodLazy:\n      return () => def.getter()._def;\n    case ZodFirstPartyTypeKind3.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodNaN:\n    case ZodFirstPartyTypeKind3.ZodNever:\n      return parseNeverDef();\n    case ZodFirstPartyTypeKind3.ZodEffects:\n      return parseEffectsDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodAny:\n      return parseAnyDef();\n    case ZodFirstPartyTypeKind3.ZodUnknown:\n      return parseUnknownDef();\n    case ZodFirstPartyTypeKind3.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodCatch:\n      return parseCatchDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case ZodFirstPartyTypeKind3.ZodFunction:\n    case ZodFirstPartyTypeKind3.ZodVoid:\n    case ZodFirstPartyTypeKind3.ZodSymbol:\n      return void 0;\n    default:\n      return /* @__PURE__ */ ((_) => void 0)(typeName);\n  }\n};\n\n// src/zod-to-json-schema/parse-def.ts\nfunction parseDef(def, refs, forceResolution = false) {\n  var _a;\n  const seenItem = refs.seen.get(def);\n  if (refs.override) {\n    const overrideResult = (_a = refs.override) == null ? void 0 : _a.call(\n      refs,\n      def,\n      refs,\n      seenItem,\n      forceResolution\n    );\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n    if (seenSchema !== void 0) {\n      return seenSchema;\n    }\n  }\n  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };\n  refs.seen.set(def, newItem);\n  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n  const jsonSchema2 = typeof jsonSchemaOrGetter === \"function\" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;\n  if (jsonSchema2) {\n    addMeta(def, refs, jsonSchema2);\n  }\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);\n    newItem.jsonSchema = jsonSchema2;\n    return postProcessResult;\n  }\n  newItem.jsonSchema = jsonSchema2;\n  return jsonSchema2;\n}\nvar get$ref = (item, refs) => {\n  switch (refs.$refStrategy) {\n    case \"root\":\n      return { $ref: item.path.join(\"/\") };\n    case \"relative\":\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case \"none\":\n    case \"seen\": {\n      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n        console.warn(\n          `Recursive reference detected at ${refs.currentPath.join(\n            \"/\"\n          )}! Defaulting to any`\n        );\n        return parseAnyDef();\n      }\n      return refs.$refStrategy === \"seen\" ? parseAnyDef() : void 0;\n    }\n  }\n};\nvar addMeta = (def, refs, jsonSchema2) => {\n  if (def.description) {\n    jsonSchema2.description = def.description;\n  }\n  return jsonSchema2;\n};\n\n// src/zod-to-json-schema/refs.ts\nvar getRefs = (options) => {\n  const _options = getDefaultOptions(options);\n  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;\n  return {\n    ..._options,\n    currentPath,\n    propertyPath: void 0,\n    seen: new Map(\n      Object.entries(_options.definitions).map(([name, def]) => [\n        def._def,\n        {\n          def: def._def,\n          path: [..._options.basePath, _options.definitionPath, name],\n          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n          jsonSchema: void 0\n        }\n      ])\n    )\n  };\n};\n\n// src/zod-to-json-schema/zod-to-json-schema.ts\nvar zodToJsonSchema = (schema, options) => {\n  var _a;\n  const refs = getRefs(options);\n  let definitions = typeof options === \"object\" && options.definitions ? Object.entries(options.definitions).reduce(\n    (acc, [name2, schema2]) => {\n      var _a2;\n      return {\n        ...acc,\n        [name2]: (_a2 = parseDef(\n          schema2._def,\n          {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name2]\n          },\n          true\n        )) != null ? _a2 : parseAnyDef()\n      };\n    },\n    {}\n  ) : void 0;\n  const name = typeof options === \"string\" ? options : (options == null ? void 0 : options.nameStrategy) === \"title\" ? void 0 : options == null ? void 0 : options.name;\n  const main = (_a = parseDef(\n    schema._def,\n    name === void 0 ? refs : {\n      ...refs,\n      currentPath: [...refs.basePath, refs.definitionPath, name]\n    },\n    false\n  )) != null ? _a : parseAnyDef();\n  const title = typeof options === \"object\" && options.name !== void 0 && options.nameStrategy === \"title\" ? options.name : void 0;\n  if (title !== void 0) {\n    main.title = title;\n  }\n  const combined = name === void 0 ? definitions ? {\n    ...main,\n    [refs.definitionPath]: definitions\n  } : main : {\n    $ref: [\n      ...refs.$refStrategy === \"relative\" ? [] : refs.basePath,\n      refs.definitionPath,\n      name\n    ].join(\"/\"),\n    [refs.definitionPath]: {\n      ...definitions,\n      [name]: main\n    }\n  };\n  combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n  return combined;\n};\n\n// src/zod-to-json-schema/index.ts\nvar zod_to_json_schema_default = zodToJsonSchema;\n\n// src/zod-schema.ts\nfunction zod3Schema(zodSchema2, options) {\n  var _a;\n  const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;\n  return jsonSchema(\n    // defer json schema creation to avoid unnecessary computation when only validation is needed\n    () => zod_to_json_schema_default(zodSchema2, {\n      $refStrategy: useReferences ? \"root\" : \"none\"\n    }),\n    {\n      validate: async (value) => {\n        const result = await zodSchema2.safeParseAsync(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\nfunction zod4Schema(zodSchema2, options) {\n  var _a;\n  const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;\n  return jsonSchema(\n    // defer json schema creation to avoid unnecessary computation when only validation is needed\n    () => addAdditionalPropertiesToJsonSchema(\n      z4.toJSONSchema(zodSchema2, {\n        target: \"draft-7\",\n        io: \"input\",\n        reused: useReferences ? \"ref\" : \"inline\"\n      })\n    ),\n    {\n      validate: async (value) => {\n        const result = await z4.safeParseAsync(zodSchema2, value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\nfunction isZod4Schema(zodSchema2) {\n  return \"_zod\" in zodSchema2;\n}\nfunction zodSchema(zodSchema2, options) {\n  if (isZod4Schema(zodSchema2)) {\n    return zod4Schema(zodSchema2, options);\n  } else {\n    return zod3Schema(zodSchema2, options);\n  }\n}\n\n// src/schema.ts\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction lazySchema(createSchema) {\n  let schema;\n  return () => {\n    if (schema == null) {\n      schema = createSchema();\n    }\n    return schema;\n  };\n}\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: void 0,\n    // should never be used directly\n    [validatorSymbol]: true,\n    get jsonSchema() {\n      if (typeof jsonSchema2 === \"function\") {\n        jsonSchema2 = jsonSchema2();\n      }\n      return jsonSchema2;\n    },\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return schema == null ? jsonSchema({\n    properties: {},\n    additionalProperties: false\n  }) : isSchema(schema) ? schema : typeof schema === \"function\" ? schema() : zodSchema(schema);\n}\n\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\nfunction convertToBase64(value) {\n  return value instanceof Uint8Array ? convertUint8ArrayToBase64(value) : value;\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n// src/is-async-iterable.ts\nfunction isAsyncIterable(obj) {\n  return obj != null && typeof obj[Symbol.asyncIterator] === \"function\";\n}\n\n// src/types/execute-tool.ts\nasync function* executeTool({\n  execute,\n  input,\n  options\n}) {\n  const result = execute(input, options);\n  if (isAsyncIterable(result)) {\n    let lastOutput;\n    for await (const output of result) {\n      lastOutput = output;\n      yield { type: \"preliminary\", output };\n    }\n    yield { type: \"final\", output: lastOutput };\n  } else {\n    yield { type: \"final\", output: await result };\n  }\n}\n\n// src/index.ts\nexport * from \"@standard-schema/spec\";\nimport {\n  EventSourceParserStream as EventSourceParserStream2\n} from \"eventsource-parser/stream\";\nexport {\n  DelayedPromise,\n  EventSourceParserStream2 as EventSourceParserStream,\n  VERSION,\n  asSchema,\n  asValidator,\n  combineHeaders,\n  convertAsyncIteratorToReadableStream,\n  convertBase64ToUint8Array,\n  convertToBase64,\n  convertUint8ArrayToBase64,\n  createBinaryResponseHandler,\n  createEventSourceResponseHandler,\n  createIdGenerator,\n  createJsonErrorResponseHandler,\n  createJsonResponseHandler,\n  createJsonStreamResponseHandler,\n  createProviderDefinedToolFactory,\n  createProviderDefinedToolFactoryWithOutputSchema,\n  createStatusCodeErrorResponseHandler,\n  delay,\n  dynamicTool,\n  executeTool,\n  extractResponseHeaders,\n  generateId,\n  getErrorMessage,\n  getFromApi,\n  getRuntimeEnvironmentUserAgent,\n  injectJsonInstructionIntoMessages,\n  isAbortError,\n  isParsableJson,\n  isUrlSupported,\n  isValidator,\n  jsonSchema,\n  lazySchema,\n  lazyValidator,\n  loadApiKey,\n  loadOptionalSetting,\n  loadSetting,\n  mediaTypeToExtension,\n  normalizeHeaders,\n  parseJSON,\n  parseJsonEventStream,\n  parseProviderOptions,\n  postFormDataToApi,\n  postJsonToApi,\n  postToApi,\n  removeUndefinedEntries,\n  resolve,\n  safeParseJSON,\n  safeValidateTypes,\n  standardSchemaValidator,\n  tool,\n  validateTypes,\n  validator,\n  withUserAgentSuffix,\n  withoutTrailingSlash,\n  zodSchema\n};\n//# sourceMappingURL=index.mjs.map","var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name16 in all)\n    __defProp(target, name16, { get: all[name16], enumerable: true });\n};\n\n// src/index.ts\nimport { createGateway, gateway as gateway2 } from \"@ai-sdk/gateway\";\nimport {\n  asSchema as asSchema5,\n  createIdGenerator as createIdGenerator5,\n  dynamicTool,\n  generateId as generateId2,\n  jsonSchema,\n  parseJsonEventStream as parseJsonEventStream3,\n  tool,\n  zodSchema as zodSchema3\n} from \"@ai-sdk/provider-utils\";\n\n// src/generate-text/generate-text.ts\nimport {\n  createIdGenerator,\n  executeTool,\n  getErrorMessage as getErrorMessage5,\n  withUserAgentSuffix as withUserAgentSuffix2\n} from \"@ai-sdk/provider-utils\";\n\n// src/error/no-output-specified-error.ts\nimport { AISDKError } from \"@ai-sdk/provider\";\nvar name = \"AI_NoOutputSpecifiedError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar NoOutputSpecifiedError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"No output specified.\" } = {}) {\n    super({ name, message });\n    this[_a] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker);\n  }\n};\n_a = symbol;\n\n// src/logger/log-warnings.ts\nfunction formatWarning(warning) {\n  const prefix = \"AI SDK Warning:\";\n  switch (warning.type) {\n    case \"unsupported-setting\": {\n      let message = `${prefix} The \"${warning.setting}\" setting is not supported by this model`;\n      if (warning.details) {\n        message += ` - ${warning.details}`;\n      }\n      return message;\n    }\n    case \"unsupported-tool\": {\n      const toolName = \"name\" in warning.tool ? warning.tool.name : \"unknown tool\";\n      let message = `${prefix} The tool \"${toolName}\" is not supported by this model`;\n      if (warning.details) {\n        message += ` - ${warning.details}`;\n      }\n      return message;\n    }\n    case \"other\": {\n      return `${prefix} ${warning.message}`;\n    }\n    default: {\n      return `${prefix} ${JSON.stringify(warning, null, 2)}`;\n    }\n  }\n}\nvar FIRST_WARNING_INFO_MESSAGE = \"AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.\";\nvar hasLoggedBefore = false;\nvar logWarnings = (warnings) => {\n  if (warnings.length === 0) {\n    return;\n  }\n  const logger = globalThis.AI_SDK_LOG_WARNINGS;\n  if (logger === false) {\n    return;\n  }\n  if (typeof logger === \"function\") {\n    logger(warnings);\n    return;\n  }\n  if (!hasLoggedBefore) {\n    hasLoggedBefore = true;\n    console.info(FIRST_WARNING_INFO_MESSAGE);\n  }\n  for (const warning of warnings) {\n    console.warn(formatWarning(warning));\n  }\n};\n\n// src/model/resolve-model.ts\nimport { gateway } from \"@ai-sdk/gateway\";\n\n// src/error/index.ts\nimport {\n  AISDKError as AISDKError17,\n  APICallError,\n  EmptyResponseBodyError,\n  InvalidPromptError,\n  InvalidResponseDataError,\n  JSONParseError,\n  LoadAPIKeyError,\n  LoadSettingError,\n  NoContentGeneratedError,\n  NoSuchModelError,\n  TooManyEmbeddingValuesForCallError,\n  TypeValidationError,\n  UnsupportedFunctionalityError\n} from \"@ai-sdk/provider\";\n\n// src/error/invalid-argument-error.ts\nimport { AISDKError as AISDKError2 } from \"@ai-sdk/provider\";\nvar name2 = \"AI_InvalidArgumentError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar InvalidArgumentError = class extends AISDKError2 {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name: name2,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a2] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError2.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// src/error/invalid-stream-part-error.ts\nimport { AISDKError as AISDKError3 } from \"@ai-sdk/provider\";\nvar name3 = \"AI_InvalidStreamPartError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidStreamPartError = class extends AISDKError3 {\n  constructor({\n    chunk,\n    message\n  }) {\n    super({ name: name3, message });\n    this[_a3] = true;\n    this.chunk = chunk;\n  }\n  static isInstance(error) {\n    return AISDKError3.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// src/error/invalid-tool-input-error.ts\nimport { AISDKError as AISDKError4, getErrorMessage } from \"@ai-sdk/provider\";\nvar name4 = \"AI_InvalidToolInputError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidToolInputError = class extends AISDKError4 {\n  constructor({\n    toolInput,\n    toolName,\n    cause,\n    message = `Invalid input for tool ${toolName}: ${getErrorMessage(cause)}`\n  }) {\n    super({ name: name4, message, cause });\n    this[_a4] = true;\n    this.toolInput = toolInput;\n    this.toolName = toolName;\n  }\n  static isInstance(error) {\n    return AISDKError4.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/error/no-image-generated-error.ts\nimport { AISDKError as AISDKError5 } from \"@ai-sdk/provider\";\nvar name5 = \"AI_NoImageGeneratedError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar NoImageGeneratedError = class extends AISDKError5 {\n  constructor({\n    message = \"No image generated.\",\n    cause,\n    responses\n  }) {\n    super({ name: name5, message, cause });\n    this[_a5] = true;\n    this.responses = responses;\n  }\n  static isInstance(error) {\n    return AISDKError5.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// src/error/no-object-generated-error.ts\nimport { AISDKError as AISDKError6 } from \"@ai-sdk/provider\";\nvar name6 = \"AI_NoObjectGeneratedError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar NoObjectGeneratedError = class extends AISDKError6 {\n  constructor({\n    message = \"No object generated.\",\n    cause,\n    text: text2,\n    response,\n    usage,\n    finishReason\n  }) {\n    super({ name: name6, message, cause });\n    this[_a6] = true;\n    this.text = text2;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n  static isInstance(error) {\n    return AISDKError6.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// src/error/no-output-generated-error.ts\nimport { AISDKError as AISDKError7 } from \"@ai-sdk/provider\";\nvar name7 = \"AI_NoOutputGeneratedError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoOutputGeneratedError = class extends AISDKError7 {\n  // used in isInstance\n  constructor({\n    message = \"No output generated.\",\n    cause\n  } = {}) {\n    super({ name: name7, message, cause });\n    this[_a7] = true;\n  }\n  static isInstance(error) {\n    return AISDKError7.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// src/error/no-speech-generated-error.ts\nimport { AISDKError as AISDKError8 } from \"@ai-sdk/provider\";\nvar NoSpeechGeneratedError = class extends AISDKError8 {\n  constructor(options) {\n    super({\n      name: \"AI_NoSpeechGeneratedError\",\n      message: \"No speech audio generated.\"\n    });\n    this.responses = options.responses;\n  }\n};\n\n// src/error/no-such-tool-error.ts\nimport { AISDKError as AISDKError9 } from \"@ai-sdk/provider\";\nvar name8 = \"AI_NoSuchToolError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar NoSuchToolError = class extends AISDKError9 {\n  constructor({\n    toolName,\n    availableTools = void 0,\n    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}`\n  }) {\n    super({ name: name8, message });\n    this[_a8] = true;\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n  static isInstance(error) {\n    return AISDKError9.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// src/error/tool-call-repair-error.ts\nimport { AISDKError as AISDKError10, getErrorMessage as getErrorMessage2 } from \"@ai-sdk/provider\";\nvar name9 = \"AI_ToolCallRepairError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar ToolCallRepairError = class extends AISDKError10 {\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${getErrorMessage2(cause)}`\n  }) {\n    super({ name: name9, message, cause });\n    this[_a9] = true;\n    this.originalError = originalError;\n  }\n  static isInstance(error) {\n    return AISDKError10.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// src/error/unsupported-model-version-error.ts\nimport { AISDKError as AISDKError11 } from \"@ai-sdk/provider\";\nvar UnsupportedModelVersionError = class extends AISDKError11 {\n  constructor(options) {\n    super({\n      name: \"AI_UnsupportedModelVersionError\",\n      message: `Unsupported model version ${options.version} for provider \"${options.provider}\" and model \"${options.modelId}\". AI SDK 5 only supports models that implement specification version \"v2\".`\n    });\n    this.version = options.version;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n  }\n};\n\n// src/prompt/invalid-data-content-error.ts\nimport { AISDKError as AISDKError12 } from \"@ai-sdk/provider\";\nvar name10 = \"AI_InvalidDataContentError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar InvalidDataContentError = class extends AISDKError12 {\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  }) {\n    super({ name: name10, message, cause });\n    this[_a10] = true;\n    this.content = content;\n  }\n  static isInstance(error) {\n    return AISDKError12.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// src/prompt/invalid-message-role-error.ts\nimport { AISDKError as AISDKError13 } from \"@ai-sdk/provider\";\nvar name11 = \"AI_InvalidMessageRoleError\";\nvar marker11 = `vercel.ai.error.${name11}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar InvalidMessageRoleError = class extends AISDKError13 {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({ name: name11, message });\n    this[_a11] = true;\n    this.role = role;\n  }\n  static isInstance(error) {\n    return AISDKError13.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// src/prompt/message-conversion-error.ts\nimport { AISDKError as AISDKError14 } from \"@ai-sdk/provider\";\nvar name12 = \"AI_MessageConversionError\";\nvar marker12 = `vercel.ai.error.${name12}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar MessageConversionError = class extends AISDKError14 {\n  constructor({\n    originalMessage,\n    message\n  }) {\n    super({ name: name12, message });\n    this[_a12] = true;\n    this.originalMessage = originalMessage;\n  }\n  static isInstance(error) {\n    return AISDKError14.hasMarker(error, marker12);\n  }\n};\n_a12 = symbol12;\n\n// src/util/download/download-error.ts\nimport { AISDKError as AISDKError15 } from \"@ai-sdk/provider\";\nvar name13 = \"AI_DownloadError\";\nvar marker13 = `vercel.ai.error.${name13}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar DownloadError = class extends AISDKError15 {\n  constructor({\n    url,\n    statusCode,\n    statusText,\n    cause,\n    message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}`\n  }) {\n    super({ name: name13, message, cause });\n    this[_a13] = true;\n    this.url = url;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n  }\n  static isInstance(error) {\n    return AISDKError15.hasMarker(error, marker13);\n  }\n};\n_a13 = symbol13;\n\n// src/util/retry-error.ts\nimport { AISDKError as AISDKError16 } from \"@ai-sdk/provider\";\nvar name14 = \"AI_RetryError\";\nvar marker14 = `vercel.ai.error.${name14}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar RetryError = class extends AISDKError16 {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({ name: name14, message });\n    this[_a14] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error) {\n    return AISDKError16.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// src/model/resolve-model.ts\nfunction resolveLanguageModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v2\") {\n      throw new UnsupportedModelVersionError({\n        version: model.specificationVersion,\n        provider: model.provider,\n        modelId: model.modelId\n      });\n    }\n    return model;\n  }\n  return getGlobalProvider().languageModel(model);\n}\nfunction resolveEmbeddingModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v2\") {\n      throw new UnsupportedModelVersionError({\n        version: model.specificationVersion,\n        provider: model.provider,\n        modelId: model.modelId\n      });\n    }\n    return model;\n  }\n  return getGlobalProvider().textEmbeddingModel(\n    model\n  );\n}\nfunction resolveImageModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v2\") {\n      throw new UnsupportedModelVersionError({\n        version: model.specificationVersion,\n        provider: model.provider,\n        modelId: model.modelId\n      });\n    }\n    return model;\n  }\n  return getGlobalProvider().imageModel(model);\n}\nfunction getGlobalProvider() {\n  var _a16;\n  return (_a16 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a16 : gateway;\n}\n\n// src/prompt/convert-to-language-model-prompt.ts\nimport {\n  isUrlSupported\n} from \"@ai-sdk/provider-utils\";\n\n// src/util/detect-media-type.ts\nimport { convertBase64ToUint8Array } from \"@ai-sdk/provider-utils\";\nvar imageMediaTypeSignatures = [\n  {\n    mediaType: \"image/gif\",\n    bytesPrefix: [71, 73, 70]\n    // GIF\n  },\n  {\n    mediaType: \"image/png\",\n    bytesPrefix: [137, 80, 78, 71]\n    // PNG\n  },\n  {\n    mediaType: \"image/jpeg\",\n    bytesPrefix: [255, 216]\n    // JPEG\n  },\n  {\n    mediaType: \"image/webp\",\n    bytesPrefix: [\n      82,\n      73,\n      70,\n      70,\n      // \"RIFF\"\n      null,\n      null,\n      null,\n      null,\n      // file size (variable)\n      87,\n      69,\n      66,\n      80\n      // \"WEBP\"\n    ]\n  },\n  {\n    mediaType: \"image/bmp\",\n    bytesPrefix: [66, 77]\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [73, 73, 42, 0]\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [77, 77, 0, 42]\n  },\n  {\n    mediaType: \"image/avif\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      97,\n      118,\n      105,\n      102\n    ]\n  },\n  {\n    mediaType: \"image/heic\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      104,\n      101,\n      105,\n      99\n    ]\n  }\n];\nvar audioMediaTypeSignatures = [\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 251]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 250]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 243]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 242]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 227]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 226]\n  },\n  {\n    mediaType: \"audio/wav\",\n    bytesPrefix: [\n      82,\n      // R\n      73,\n      // I\n      70,\n      // F\n      70,\n      // F\n      null,\n      null,\n      null,\n      null,\n      87,\n      // W\n      65,\n      // A\n      86,\n      // V\n      69\n      // E\n    ]\n  },\n  {\n    mediaType: \"audio/ogg\",\n    bytesPrefix: [79, 103, 103, 83]\n  },\n  {\n    mediaType: \"audio/flac\",\n    bytesPrefix: [102, 76, 97, 67]\n  },\n  {\n    mediaType: \"audio/aac\",\n    bytesPrefix: [64, 21, 0, 0]\n  },\n  {\n    mediaType: \"audio/mp4\",\n    bytesPrefix: [102, 116, 121, 112]\n  },\n  {\n    mediaType: \"audio/webm\",\n    bytesPrefix: [26, 69, 223, 163]\n  }\n];\nvar stripID3 = (data) => {\n  const bytes = typeof data === \"string\" ? convertBase64ToUint8Array(data) : data;\n  const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n  return bytes.slice(id3Size + 10);\n};\nfunction stripID3TagsIfPresent(data) {\n  const hasId3 = typeof data === \"string\" && data.startsWith(\"SUQz\") || typeof data !== \"string\" && data.length > 10 && data[0] === 73 && // 'I'\n  data[1] === 68 && // 'D'\n  data[2] === 51;\n  return hasId3 ? stripID3(data) : data;\n}\nfunction detectMediaType({\n  data,\n  signatures\n}) {\n  const processedData = stripID3TagsIfPresent(data);\n  const bytes = typeof processedData === \"string\" ? convertBase64ToUint8Array(\n    processedData.substring(0, Math.min(processedData.length, 24))\n  ) : processedData;\n  for (const signature of signatures) {\n    if (bytes.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(\n      (byte, index) => byte === null || bytes[index] === byte\n    )) {\n      return signature.mediaType;\n    }\n  }\n  return void 0;\n}\n\n// src/util/download/download.ts\nimport {\n  withUserAgentSuffix,\n  getRuntimeEnvironmentUserAgent\n} from \"@ai-sdk/provider-utils\";\n\n// src/version.ts\nvar VERSION = true ? \"5.0.116\" : \"0.0.0-test\";\n\n// src/util/download/download.ts\nvar download = async ({ url }) => {\n  var _a16;\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText, {\n      headers: withUserAgentSuffix(\n        {},\n        `ai-sdk/${VERSION}`,\n        getRuntimeEnvironmentUserAgent()\n      )\n    });\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mediaType: (_a16 = response.headers.get(\"content-type\")) != null ? _a16 : void 0\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n};\n\n// src/util/download/download-function.ts\nvar createDefaultDownloadFunction = (download2 = download) => (requestedDownloads) => Promise.all(\n  requestedDownloads.map(\n    async (requestedDownload) => requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)\n  )\n);\n\n// src/prompt/data-content.ts\nimport { AISDKError as AISDKError18 } from \"@ai-sdk/provider\";\nimport {\n  convertBase64ToUint8Array as convertBase64ToUint8Array2,\n  convertUint8ArrayToBase64\n} from \"@ai-sdk/provider-utils\";\nimport { z } from \"zod/v4\";\n\n// src/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n  try {\n    const [header, base64Content] = dataUrl.split(\",\");\n    return {\n      mediaType: header.split(\";\")[0].split(\":\")[1],\n      base64Content\n    };\n  } catch (error) {\n    return {\n      mediaType: void 0,\n      base64Content: void 0\n    };\n  }\n}\n\n// src/prompt/data-content.ts\nvar dataContentSchema = z.union([\n  z.string(),\n  z.instanceof(Uint8Array),\n  z.instanceof(ArrayBuffer),\n  z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value) => {\n      var _a16, _b;\n      return (_b = (_a16 = globalThis.Buffer) == null ? void 0 : _a16.isBuffer(value)) != null ? _b : false;\n    },\n    { message: \"Must be a Buffer\" }\n  )\n]);\nfunction convertToLanguageModelV2DataContent(content) {\n  if (content instanceof Uint8Array) {\n    return { data: content, mediaType: void 0 };\n  }\n  if (content instanceof ArrayBuffer) {\n    return { data: new Uint8Array(content), mediaType: void 0 };\n  }\n  if (typeof content === \"string\") {\n    try {\n      content = new URL(content);\n    } catch (error) {\n    }\n  }\n  if (content instanceof URL && content.protocol === \"data:\") {\n    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(\n      content.toString()\n    );\n    if (dataUrlMediaType == null || base64Content == null) {\n      throw new AISDKError18({\n        name: \"InvalidDataContentError\",\n        message: `Invalid data URL format in content ${content.toString()}`\n      });\n    }\n    return { data: base64Content, mediaType: dataUrlMediaType };\n  }\n  return { data: content, mediaType: void 0 };\n}\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n  return convertUint8ArrayToBase64(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return convertBase64ToUint8Array2(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded media.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new InvalidDataContentError({ content });\n}\n\n// src/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({\n  prompt,\n  supportedUrls,\n  download: download2 = createDefaultDownloadFunction()\n}) {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    download2,\n    supportedUrls\n  );\n  return [\n    ...prompt.system != null ? [{ role: \"system\", content: prompt.system }] : [],\n    ...prompt.messages.map(\n      (message) => convertToLanguageModelMessage({ message, downloadedAssets })\n    )\n  ];\n}\nfunction convertToLanguageModelMessage({\n  message,\n  downloadedAssets\n}) {\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return {\n        role: \"system\",\n        content: message.content,\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== \"text\" || part.text !== \"\"),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts (no text, and no provider options):\n          (part) => part.type !== \"text\" || part.text !== \"\" || part.providerOptions != null\n        ).map((part) => {\n          const providerOptions = part.providerOptions;\n          switch (part.type) {\n            case \"file\": {\n              const { data, mediaType } = convertToLanguageModelV2DataContent(\n                part.data\n              );\n              return {\n                type: \"file\",\n                data,\n                filename: part.filename,\n                mediaType: mediaType != null ? mediaType : part.mediaType,\n                providerOptions\n              };\n            }\n            case \"reasoning\": {\n              return {\n                type: \"reasoning\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"text\": {\n              return {\n                type: \"text\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"tool-call\": {\n              return {\n                type: \"tool-call\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                input: part.input,\n                providerExecuted: part.providerExecuted,\n                providerOptions\n              };\n            }\n            case \"tool-result\": {\n              return {\n                type: \"tool-result\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                output: part.output,\n                providerOptions\n              };\n            }\n          }\n        }),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"tool\": {\n      return {\n        role: \"tool\",\n        content: message.content.map((part) => ({\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output: part.output,\n          providerOptions: part.providerOptions\n        })),\n        providerOptions: message.providerOptions\n      };\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\nasync function downloadAssets(messages, download2, supportedUrls) {\n  const plannedDownloads = messages.filter((message) => message.role === \"user\").map((message) => message.content).filter(\n    (content) => Array.isArray(content)\n  ).flat().filter(\n    (part) => part.type === \"image\" || part.type === \"file\"\n  ).map((part) => {\n    var _a16;\n    const mediaType = (_a16 = part.mediaType) != null ? _a16 : part.type === \"image\" ? \"image/*\" : void 0;\n    let data = part.type === \"image\" ? part.image : part.data;\n    if (typeof data === \"string\") {\n      try {\n        data = new URL(data);\n      } catch (ignored) {\n      }\n    }\n    return { mediaType, data };\n  }).filter(\n    (part) => part.data instanceof URL\n  ).map((part) => ({\n    url: part.data,\n    isUrlSupportedByModel: part.mediaType != null && isUrlSupported({\n      url: part.data.toString(),\n      mediaType: part.mediaType,\n      supportedUrls\n    })\n  }));\n  const downloadedFiles = await download2(plannedDownloads);\n  return Object.fromEntries(\n    downloadedFiles.map(\n      (file, index) => file == null ? null : [\n        plannedDownloads[index].url.toString(),\n        { data: file.data, mediaType: file.mediaType }\n      ]\n    ).filter((file) => file != null)\n  );\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n  var _a16;\n  if (part.type === \"text\") {\n    return {\n      type: \"text\",\n      text: part.text,\n      providerOptions: part.providerOptions\n    };\n  }\n  let originalData;\n  const type = part.type;\n  switch (type) {\n    case \"image\":\n      originalData = part.image;\n      break;\n    case \"file\":\n      originalData = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n  const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV2DataContent(originalData);\n  let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;\n  let data = convertedData;\n  if (data instanceof URL) {\n    const downloadedFile = downloadedAssets[data.toString()];\n    if (downloadedFile) {\n      data = downloadedFile.data;\n      mediaType != null ? mediaType : mediaType = downloadedFile.mediaType;\n    }\n  }\n  switch (type) {\n    case \"image\": {\n      if (data instanceof Uint8Array || typeof data === \"string\") {\n        mediaType = (_a16 = detectMediaType({ data, signatures: imageMediaTypeSignatures })) != null ? _a16 : mediaType;\n      }\n      return {\n        type: \"file\",\n        mediaType: mediaType != null ? mediaType : \"image/*\",\n        // any image\n        filename: void 0,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n    case \"file\": {\n      if (mediaType == null) {\n        throw new Error(`Media type is missing for file part`);\n      }\n      return {\n        type: \"file\",\n        mediaType,\n        filename: part.filename,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n  }\n}\n\n// src/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({\n  maxOutputTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  stopSequences\n}) {\n  if (maxOutputTokens != null) {\n    if (!Number.isInteger(maxOutputTokens)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be an integer\"\n      });\n    }\n    if (maxOutputTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (topK != null) {\n    if (typeof topK !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topK\",\n        value: topK,\n        message: \"topK must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  return {\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences,\n    seed\n  };\n}\n\n// src/prompt/prepare-tools-and-tool-choice.ts\nimport { asSchema } from \"@ai-sdk/provider-utils\";\n\n// src/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object2) {\n  return object2 != null && Object.keys(object2).length > 0;\n}\n\n// src/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({\n  tools,\n  toolChoice,\n  activeTools\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  const filteredTools = activeTools != null ? Object.entries(tools).filter(\n    ([name16]) => activeTools.includes(name16)\n  ) : Object.entries(tools);\n  return {\n    tools: filteredTools.map(([name16, tool2]) => {\n      const toolType = tool2.type;\n      switch (toolType) {\n        case void 0:\n        case \"dynamic\":\n        case \"function\":\n          return {\n            type: \"function\",\n            name: name16,\n            description: tool2.description,\n            inputSchema: asSchema(tool2.inputSchema).jsonSchema,\n            providerOptions: tool2.providerOptions\n          };\n        case \"provider-defined\":\n          return {\n            type: \"provider-defined\",\n            name: name16,\n            id: tool2.id,\n            args: tool2.args\n          };\n        default: {\n          const exhaustiveCheck = toolType;\n          throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n        }\n      }\n    }),\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// src/prompt/standardize-prompt.ts\nimport { InvalidPromptError as InvalidPromptError2 } from \"@ai-sdk/provider\";\nimport { safeValidateTypes } from \"@ai-sdk/provider-utils\";\nimport { z as z6 } from \"zod/v4\";\n\n// src/prompt/message.ts\nimport { z as z5 } from \"zod/v4\";\n\n// src/types/provider-metadata.ts\nimport { z as z3 } from \"zod/v4\";\n\n// src/types/json-value.ts\nimport { z as z2 } from \"zod/v4\";\nvar jsonValueSchema = z2.lazy(\n  () => z2.union([\n    z2.null(),\n    z2.string(),\n    z2.number(),\n    z2.boolean(),\n    z2.record(z2.string(), jsonValueSchema),\n    z2.array(jsonValueSchema)\n  ])\n);\n\n// src/types/provider-metadata.ts\nvar providerMetadataSchema = z3.record(\n  z3.string(),\n  z3.record(z3.string(), jsonValueSchema)\n);\n\n// src/prompt/content-part.ts\nimport { z as z4 } from \"zod/v4\";\nvar textPartSchema = z4.object({\n  type: z4.literal(\"text\"),\n  text: z4.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar imagePartSchema = z4.object({\n  type: z4.literal(\"image\"),\n  image: z4.union([dataContentSchema, z4.instanceof(URL)]),\n  mediaType: z4.string().optional(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar filePartSchema = z4.object({\n  type: z4.literal(\"file\"),\n  data: z4.union([dataContentSchema, z4.instanceof(URL)]),\n  filename: z4.string().optional(),\n  mediaType: z4.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = z4.object({\n  type: z4.literal(\"reasoning\"),\n  text: z4.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = z4.object({\n  type: z4.literal(\"tool-call\"),\n  toolCallId: z4.string(),\n  toolName: z4.string(),\n  input: z4.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  providerExecuted: z4.boolean().optional()\n});\nvar outputSchema = z4.discriminatedUnion(\"type\", [\n  z4.object({\n    type: z4.literal(\"text\"),\n    value: z4.string()\n  }),\n  z4.object({\n    type: z4.literal(\"json\"),\n    value: jsonValueSchema\n  }),\n  z4.object({\n    type: z4.literal(\"error-text\"),\n    value: z4.string()\n  }),\n  z4.object({\n    type: z4.literal(\"error-json\"),\n    value: jsonValueSchema\n  }),\n  z4.object({\n    type: z4.literal(\"content\"),\n    value: z4.array(\n      z4.union([\n        z4.object({\n          type: z4.literal(\"text\"),\n          text: z4.string()\n        }),\n        z4.object({\n          type: z4.literal(\"media\"),\n          data: z4.string(),\n          mediaType: z4.string()\n        })\n      ])\n    )\n  })\n]);\nvar toolResultPartSchema = z4.object({\n  type: z4.literal(\"tool-result\"),\n  toolCallId: z4.string(),\n  toolName: z4.string(),\n  output: outputSchema,\n  providerOptions: providerMetadataSchema.optional()\n});\n\n// src/prompt/message.ts\nvar systemModelMessageSchema = z5.object(\n  {\n    role: z5.literal(\"system\"),\n    content: z5.string(),\n    providerOptions: providerMetadataSchema.optional()\n  }\n);\nvar coreSystemMessageSchema = systemModelMessageSchema;\nvar userModelMessageSchema = z5.object({\n  role: z5.literal(\"user\"),\n  content: z5.union([\n    z5.string(),\n    z5.array(z5.union([textPartSchema, imagePartSchema, filePartSchema]))\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = userModelMessageSchema;\nvar assistantModelMessageSchema = z5.object({\n  role: z5.literal(\"assistant\"),\n  content: z5.union([\n    z5.string(),\n    z5.array(\n      z5.union([\n        textPartSchema,\n        filePartSchema,\n        reasoningPartSchema,\n        toolCallPartSchema,\n        toolResultPartSchema\n      ])\n    )\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = assistantModelMessageSchema;\nvar toolModelMessageSchema = z5.object({\n  role: z5.literal(\"tool\"),\n  content: z5.array(toolResultPartSchema),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = toolModelMessageSchema;\nvar modelMessageSchema = z5.union([\n  systemModelMessageSchema,\n  userModelMessageSchema,\n  assistantModelMessageSchema,\n  toolModelMessageSchema\n]);\nvar coreMessageSchema = modelMessageSchema;\n\n// src/prompt/standardize-prompt.ts\nasync function standardizePrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new InvalidPromptError2({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new InvalidPromptError2({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.system != null && typeof prompt.system !== \"string\") {\n    throw new InvalidPromptError2({\n      prompt,\n      message: \"system must be a string\"\n    });\n  }\n  let messages;\n  if (prompt.prompt != null && typeof prompt.prompt === \"string\") {\n    messages = [{ role: \"user\", content: prompt.prompt }];\n  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {\n    messages = prompt.prompt;\n  } else if (prompt.messages != null) {\n    messages = prompt.messages;\n  } else {\n    throw new InvalidPromptError2({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (messages.length === 0) {\n    throw new InvalidPromptError2({\n      prompt,\n      message: \"messages must not be empty\"\n    });\n  }\n  const validationResult = await safeValidateTypes({\n    value: messages,\n    schema: z6.array(modelMessageSchema)\n  });\n  if (!validationResult.success) {\n    throw new InvalidPromptError2({\n      prompt,\n      message: \"The messages must be a ModelMessage[]. If you have passed a UIMessage[], you can use convertToModelMessages to convert them.\",\n      cause: validationResult.error\n    });\n  }\n  return {\n    messages,\n    system: prompt.system\n  };\n}\n\n// src/prompt/wrap-gateway-error.ts\nimport { GatewayAuthenticationError } from \"@ai-sdk/gateway\";\nimport { AISDKError as AISDKError19 } from \"@ai-sdk/provider\";\nfunction wrapGatewayError(error) {\n  if (!GatewayAuthenticationError.isInstance(error))\n    return error;\n  const isProductionEnv = (process == null ? void 0 : process.env.NODE_ENV) === \"production\";\n  const moreInfoURL = \"https://ai-sdk.dev/unauthenticated-ai-gateway\";\n  if (isProductionEnv) {\n    return new AISDKError19({\n      name: \"GatewayError\",\n      message: `Unauthenticated. Configure AI_GATEWAY_API_KEY or use a provider module. Learn more: ${moreInfoURL}`\n    });\n  }\n  return Object.assign(\n    new Error(`\\x1B[1m\\x1B[31mUnauthenticated request to AI Gateway.\\x1B[0m\n\nTo authenticate, set the \\x1B[33mAI_GATEWAY_API_KEY\\x1B[0m environment variable with your API key.\n\nAlternatively, you can use a provider module instead of the AI Gateway.\n\nLearn more: \\x1B[34m${moreInfoURL}\\x1B[0m\n\n`),\n    { name: \"GatewayAuthenticationError\" }\n  );\n}\n\n// src/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({\n  operationId,\n  telemetry\n}) {\n  return {\n    // standardized operation and resource name:\n    \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n    \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n    // detailed, AI SDK specific data:\n    \"ai.operationId\": operationId,\n    \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n  };\n}\n\n// src/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers\n}) {\n  var _a16;\n  return {\n    \"ai.model.provider\": model.provider,\n    \"ai.model.id\": model.modelId,\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {}),\n    // add metadata as attributes:\n    ...Object.entries((_a16 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a16 : {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {}\n    ),\n    // request headers\n    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {\n      if (value !== void 0) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {})\n  };\n}\n\n// src/telemetry/get-tracer.ts\nimport { trace } from \"@opentelemetry/api\";\n\n// src/telemetry/noop-tracer.ts\nvar noopTracer = {\n  startSpan() {\n    return noopSpan;\n  },\n  startActiveSpan(name16, arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === \"function\") {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === \"function\") {\n      return arg3(noopSpan);\n    }\n  }\n};\nvar noopSpan = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  }\n};\nvar noopSpanContext = {\n  traceId: \"\",\n  spanId: \"\",\n  traceFlags: 0\n};\n\n// src/telemetry/get-tracer.ts\nfunction getTracer({\n  isEnabled = false,\n  tracer\n} = {}) {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n  if (tracer) {\n    return tracer;\n  }\n  return trace.getTracer(\"ai\");\n}\n\n// src/telemetry/record-span.ts\nimport { SpanStatusCode } from \"@opentelemetry/api\";\nfunction recordSpan({\n  name: name16,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true\n}) {\n  return tracer.startActiveSpan(name16, { attributes }, async (span) => {\n    try {\n      const result = await fn(span);\n      if (endWhenDone) {\n        span.end();\n      }\n      return result;\n    } catch (error) {\n      try {\n        recordErrorOnSpan(span, error);\n      } finally {\n        span.end();\n      }\n      throw error;\n    }\n  });\n}\nfunction recordErrorOnSpan(span, error) {\n  if (error instanceof Error) {\n    span.recordException({\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    });\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: error.message\n    });\n  } else {\n    span.setStatus({ code: SpanStatusCode.ERROR });\n  }\n}\n\n// src/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({\n  telemetry,\n  attributes\n}) {\n  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n    return {};\n  }\n  return Object.entries(attributes).reduce((attributes2, [key, value]) => {\n    if (value == null) {\n      return attributes2;\n    }\n    if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n        return attributes2;\n      }\n      const result = value.input();\n      return result == null ? attributes2 : { ...attributes2, [key]: result };\n    }\n    if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n        return attributes2;\n      }\n      const result = value.output();\n      return result == null ? attributes2 : { ...attributes2, [key]: result };\n    }\n    return { ...attributes2, [key]: value };\n  }, {});\n}\n\n// src/telemetry/stringify-for-telemetry.ts\nfunction stringifyForTelemetry(prompt) {\n  return JSON.stringify(\n    prompt.map((message) => ({\n      ...message,\n      content: typeof message.content === \"string\" ? message.content : message.content.map(\n        (part) => part.type === \"file\" ? {\n          ...part,\n          data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data\n        } : part\n      )\n    }))\n  );\n}\n\n// src/types/usage.ts\nfunction addLanguageModelUsage(usage1, usage2) {\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n    reasoningTokens: addTokenCounts(\n      usage1.reasoningTokens,\n      usage2.reasoningTokens\n    ),\n    cachedInputTokens: addTokenCounts(\n      usage1.cachedInputTokens,\n      usage2.cachedInputTokens\n    )\n  };\n}\nfunction addTokenCounts(tokenCount1, tokenCount2) {\n  return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);\n}\n\n// src/util/as-array.ts\nfunction asArray(value) {\n  return value === void 0 ? [] : Array.isArray(value) ? value : [value];\n}\n\n// src/util/retry-with-exponential-backoff.ts\nimport { APICallError as APICallError2 } from \"@ai-sdk/provider\";\nimport { delay, getErrorMessage as getErrorMessage3, isAbortError } from \"@ai-sdk/provider-utils\";\nfunction getRetryDelayInMs({\n  error,\n  exponentialBackoffDelay\n}) {\n  const headers = error.responseHeaders;\n  if (!headers)\n    return exponentialBackoffDelay;\n  let ms;\n  const retryAfterMs = headers[\"retry-after-ms\"];\n  if (retryAfterMs) {\n    const timeoutMs = parseFloat(retryAfterMs);\n    if (!Number.isNaN(timeoutMs)) {\n      ms = timeoutMs;\n    }\n  }\n  const retryAfter = headers[\"retry-after\"];\n  if (retryAfter && ms === void 0) {\n    const timeoutSeconds = parseFloat(retryAfter);\n    if (!Number.isNaN(timeoutSeconds)) {\n      ms = timeoutSeconds * 1e3;\n    } else {\n      ms = Date.parse(retryAfter) - Date.now();\n    }\n  }\n  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {\n    return ms;\n  }\n  return exponentialBackoffDelay;\n}\nvar retryWithExponentialBackoffRespectingRetryHeaders = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2,\n  abortSignal\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor,\n  abortSignal\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor,\n  abortSignal\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = getErrorMessage3(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && APICallError2.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await delay(\n        getRetryDelayInMs({\n          error,\n          exponentialBackoffDelay: delayInMs\n        }),\n        { abortSignal }\n      );\n      return _retryWithExponentialBackoff(\n        f,\n        {\n          maxRetries,\n          delayInMs: backoffFactor * delayInMs,\n          backoffFactor,\n          abortSignal\n        },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// src/util/prepare-retries.ts\nfunction prepareRetries({\n  maxRetries,\n  abortSignal\n}) {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoffRespectingRetryHeaders({\n      maxRetries: maxRetriesResult,\n      abortSignal\n    })\n  };\n}\n\n// src/generate-text/extract-text-content.ts\nfunction extractTextContent(content) {\n  const parts = content.filter(\n    (content2) => content2.type === \"text\"\n  );\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map((content2) => content2.text).join(\"\");\n}\n\n// src/generate-text/generated-file.ts\nimport {\n  convertBase64ToUint8Array as convertBase64ToUint8Array3,\n  convertUint8ArrayToBase64 as convertUint8ArrayToBase642\n} from \"@ai-sdk/provider-utils\";\nvar DefaultGeneratedFile = class {\n  constructor({\n    data,\n    mediaType\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? void 0 : data;\n    this.uint8ArrayData = isUint8Array ? data : void 0;\n    this.mediaType = mediaType;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = convertUint8ArrayToBase642(this.uint8ArrayData);\n    }\n    return this.base64Data;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = convertBase64ToUint8Array3(this.base64Data);\n    }\n    return this.uint8ArrayData;\n  }\n};\nvar DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {\n  constructor(options) {\n    super(options);\n    this.type = \"file\";\n  }\n};\n\n// src/generate-text/parse-tool-call.ts\nimport {\n  asSchema as asSchema2,\n  safeParseJSON,\n  safeValidateTypes as safeValidateTypes2\n} from \"@ai-sdk/provider-utils\";\nasync function parseToolCall({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages\n}) {\n  try {\n    if (tools == null) {\n      throw new NoSuchToolError({ toolName: toolCall.toolName });\n    }\n    try {\n      return await doParseToolCall({ toolCall, tools });\n    } catch (error) {\n      if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolInputError.isInstance(error))) {\n        throw error;\n      }\n      let repairedToolCall = null;\n      try {\n        repairedToolCall = await repairToolCall({\n          toolCall,\n          tools,\n          inputSchema: ({ toolName }) => {\n            const { inputSchema } = tools[toolName];\n            return asSchema2(inputSchema).jsonSchema;\n          },\n          system,\n          messages,\n          error\n        });\n      } catch (repairError) {\n        throw new ToolCallRepairError({\n          cause: repairError,\n          originalError: error\n        });\n      }\n      if (repairedToolCall == null) {\n        throw error;\n      }\n      return await doParseToolCall({ toolCall: repairedToolCall, tools });\n    }\n  } catch (error) {\n    const parsedInput = await safeParseJSON({ text: toolCall.input });\n    const input = parsedInput.success ? parsedInput.value : toolCall.input;\n    return {\n      type: \"tool-call\",\n      toolCallId: toolCall.toolCallId,\n      toolName: toolCall.toolName,\n      input,\n      dynamic: true,\n      invalid: true,\n      error,\n      providerMetadata: toolCall.providerMetadata\n    };\n  }\n}\nasync function doParseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const schema = asSchema2(tool2.inputSchema);\n  const parseResult = toolCall.input.trim() === \"\" ? await safeValidateTypes2({ value: {}, schema }) : await safeParseJSON({ text: toolCall.input, schema });\n  if (parseResult.success === false) {\n    throw new InvalidToolInputError({\n      toolName,\n      toolInput: toolCall.input,\n      cause: parseResult.error\n    });\n  }\n  return tool2.type === \"dynamic\" ? {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: parseResult.value,\n    providerExecuted: toolCall.providerExecuted,\n    providerMetadata: toolCall.providerMetadata,\n    dynamic: true\n  } : {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    input: parseResult.value,\n    providerExecuted: toolCall.providerExecuted,\n    providerMetadata: toolCall.providerMetadata\n  };\n}\n\n// src/generate-text/step-result.ts\nvar DefaultStepResult = class {\n  constructor({\n    content,\n    finishReason,\n    usage,\n    warnings,\n    request,\n    response,\n    providerMetadata\n  }) {\n    this.content = content;\n    this.finishReason = finishReason;\n    this.usage = usage;\n    this.warnings = warnings;\n    this.request = request;\n    this.response = response;\n    this.providerMetadata = providerMetadata;\n  }\n  get text() {\n    return this.content.filter((part) => part.type === \"text\").map((part) => part.text).join(\"\");\n  }\n  get reasoning() {\n    return this.content.filter((part) => part.type === \"reasoning\");\n  }\n  get reasoningText() {\n    return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part) => part.text).join(\"\");\n  }\n  get files() {\n    return this.content.filter((part) => part.type === \"file\").map((part) => part.file);\n  }\n  get sources() {\n    return this.content.filter((part) => part.type === \"source\");\n  }\n  get toolCalls() {\n    return this.content.filter((part) => part.type === \"tool-call\");\n  }\n  get staticToolCalls() {\n    return this.toolCalls.filter(\n      (toolCall) => toolCall.dynamic !== true\n    );\n  }\n  get dynamicToolCalls() {\n    return this.toolCalls.filter(\n      (toolCall) => toolCall.dynamic === true\n    );\n  }\n  get toolResults() {\n    return this.content.filter((part) => part.type === \"tool-result\");\n  }\n  get staticToolResults() {\n    return this.toolResults.filter(\n      (toolResult) => toolResult.dynamic !== true\n    );\n  }\n  get dynamicToolResults() {\n    return this.toolResults.filter(\n      (toolResult) => toolResult.dynamic === true\n    );\n  }\n};\n\n// src/generate-text/stop-condition.ts\nfunction stepCountIs(stepCount) {\n  return ({ steps }) => steps.length === stepCount;\n}\nfunction hasToolCall(toolName) {\n  return ({ steps }) => {\n    var _a16, _b, _c;\n    return (_c = (_b = (_a16 = steps[steps.length - 1]) == null ? void 0 : _a16.toolCalls) == null ? void 0 : _b.some(\n      (toolCall) => toolCall.toolName === toolName\n    )) != null ? _c : false;\n  };\n}\nasync function isStopConditionMet({\n  stopConditions,\n  steps\n}) {\n  return (await Promise.all(stopConditions.map((condition) => condition({ steps })))).some((result) => result);\n}\n\n// src/prompt/create-tool-model-output.ts\nimport {\n  getErrorMessage as getErrorMessage4\n} from \"@ai-sdk/provider\";\nfunction createToolModelOutput({\n  output,\n  tool: tool2,\n  errorMode\n}) {\n  if (errorMode === \"text\") {\n    return { type: \"error-text\", value: getErrorMessage4(output) };\n  } else if (errorMode === \"json\") {\n    return { type: \"error-json\", value: toJSONValue(output) };\n  }\n  if (tool2 == null ? void 0 : tool2.toModelOutput) {\n    return tool2.toModelOutput(output);\n  }\n  return typeof output === \"string\" ? { type: \"text\", value: output } : { type: \"json\", value: toJSONValue(output) };\n}\nfunction toJSONValue(value) {\n  return value === void 0 ? null : value;\n}\n\n// src/generate-text/to-response-messages.ts\nfunction toResponseMessages({\n  content: inputContent,\n  tools\n}) {\n  const responseMessages = [];\n  const content = inputContent.filter((part) => part.type !== \"source\").filter(\n    (part) => (part.type !== \"tool-result\" || part.providerExecuted) && (part.type !== \"tool-error\" || part.providerExecuted)\n  ).filter((part) => part.type !== \"text\" || part.text.length > 0).map((part) => {\n    switch (part.type) {\n      case \"text\":\n        return {\n          type: \"text\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        };\n      case \"reasoning\":\n        return {\n          type: \"reasoning\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        };\n      case \"file\":\n        return {\n          type: \"file\",\n          data: part.file.base64,\n          mediaType: part.file.mediaType,\n          providerOptions: part.providerMetadata\n        };\n      case \"tool-call\":\n        return {\n          type: \"tool-call\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          input: part.input,\n          providerExecuted: part.providerExecuted,\n          providerOptions: part.providerMetadata\n        };\n      case \"tool-result\":\n        return {\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output: createToolModelOutput({\n            tool: tools == null ? void 0 : tools[part.toolName],\n            output: part.output,\n            errorMode: \"none\"\n          }),\n          providerExecuted: true,\n          providerOptions: part.providerMetadata\n        };\n      case \"tool-error\":\n        return {\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output: createToolModelOutput({\n            tool: tools == null ? void 0 : tools[part.toolName],\n            output: part.error,\n            errorMode: \"json\"\n          }),\n          providerOptions: part.providerMetadata\n        };\n    }\n  });\n  if (content.length > 0) {\n    responseMessages.push({\n      role: \"assistant\",\n      content\n    });\n  }\n  const toolResultContent = inputContent.filter((part) => part.type === \"tool-result\" || part.type === \"tool-error\").filter((part) => !part.providerExecuted).map((toolResult) => ({\n    type: \"tool-result\",\n    toolCallId: toolResult.toolCallId,\n    toolName: toolResult.toolName,\n    output: createToolModelOutput({\n      tool: tools == null ? void 0 : tools[toolResult.toolName],\n      output: toolResult.type === \"tool-result\" ? toolResult.output : toolResult.error,\n      errorMode: toolResult.type === \"tool-error\" ? \"text\" : \"none\"\n    }),\n    ...toolResult.providerMetadata != null ? { providerOptions: toolResult.providerMetadata } : {}\n  }));\n  if (toolResultContent.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      content: toolResultContent\n    });\n  }\n  return responseMessages;\n}\n\n// src/generate-text/generate-text.ts\nvar originalGenerateId = createIdGenerator({\n  prefix: \"aitxt\",\n  size: 24\n});\nasync function generateText({\n  model: modelArg,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output: output,\n  experimental_telemetry: telemetry,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_prepareStep,\n  prepareStep = experimental_prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  experimental_download: download2,\n  experimental_context,\n  _internal: {\n    generateId: generateId3 = originalGenerateId,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  onStepFinish,\n  ...settings\n}) {\n  const model = resolveLanguageModel(modelArg);\n  const stopConditions = asArray(stopWhen);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const callSettings = prepareCallSettings(settings);\n  const headersWithUserAgent = withUserAgentSuffix2(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { ...callSettings, maxRetries }\n  });\n  const initialPrompt = await standardizePrompt({\n    system,\n    prompt,\n    messages\n  });\n  const tracer = getTracer(telemetry);\n  try {\n    return await recordSpan({\n      name: \"ai.generateText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.generateText\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // model:\n          \"ai.model.provider\": model.provider,\n          \"ai.model.id\": model.modelId,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          }\n        }\n      }),\n      tracer,\n      fn: async (span) => {\n        var _a16, _b, _c, _d, _e, _f, _g;\n        const callSettings2 = prepareCallSettings(settings);\n        let currentModelResponse;\n        let clientToolCalls = [];\n        let clientToolOutputs = [];\n        const responseMessages = [];\n        const steps = [];\n        do {\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages\n          ];\n          const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n            model,\n            steps,\n            stepNumber: steps.length,\n            messages: stepInputMessages\n          }));\n          const stepModel = resolveLanguageModel(\n            (_a16 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a16 : model\n          );\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              system: (_b = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b : initialPrompt.system,\n              messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages\n            },\n            supportedUrls: await stepModel.supportedUrls,\n            download: download2\n          });\n          const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({\n            tools,\n            toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,\n            activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools\n          });\n          currentModelResponse = await retry(\n            () => {\n              var _a17;\n              return recordSpan({\n                name: \"ai.generateText.doGenerate\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.generateText.doGenerate\",\n                      telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // model:\n                    \"ai.model.provider\": stepModel.provider,\n                    \"ai.model.id\": stepModel.modelId,\n                    // prompt:\n                    \"ai.prompt.messages\": {\n                      input: () => stringifyForTelemetry(promptMessages)\n                    },\n                    \"ai.prompt.tools\": {\n                      // convert the language model level tools:\n                      input: () => stepTools == null ? void 0 : stepTools.map((tool2) => JSON.stringify(tool2))\n                    },\n                    \"ai.prompt.toolChoice\": {\n                      input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                    },\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.system\": stepModel.provider,\n                    \"gen_ai.request.model\": stepModel.modelId,\n                    \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                    \"gen_ai.request.max_tokens\": settings.maxOutputTokens,\n                    \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                    \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                    \"gen_ai.request.temperature\": (_a17 = settings.temperature) != null ? _a17 : void 0,\n                    \"gen_ai.request.top_k\": settings.topK,\n                    \"gen_ai.request.top_p\": settings.topP\n                  }\n                }),\n                tracer,\n                fn: async (span2) => {\n                  var _a18, _b2, _c2, _d2, _e2, _f2, _g2, _h;\n                  const result = await stepModel.doGenerate({\n                    ...callSettings2,\n                    tools: stepTools,\n                    toolChoice: stepToolChoice,\n                    responseFormat: output == null ? void 0 : output.responseFormat,\n                    prompt: promptMessages,\n                    providerOptions,\n                    abortSignal,\n                    headers: headersWithUserAgent\n                  });\n                  const responseData = {\n                    id: (_b2 = (_a18 = result.response) == null ? void 0 : _a18.id) != null ? _b2 : generateId3(),\n                    timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                    modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId,\n                    headers: (_g2 = result.response) == null ? void 0 : _g2.headers,\n                    body: (_h = result.response) == null ? void 0 : _h.body\n                  };\n                  span2.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        \"ai.response.finishReason\": result.finishReason,\n                        \"ai.response.text\": {\n                          output: () => extractTextContent(result.content)\n                        },\n                        \"ai.response.toolCalls\": {\n                          output: () => {\n                            const toolCalls = asToolCalls(result.content);\n                            return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                          }\n                        },\n                        \"ai.response.id\": responseData.id,\n                        \"ai.response.model\": responseData.modelId,\n                        \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                        \"ai.response.providerMetadata\": JSON.stringify(\n                          result.providerMetadata\n                        ),\n                        // TODO rename telemetry attributes to inputTokens and outputTokens\n                        \"ai.usage.promptTokens\": result.usage.inputTokens,\n                        \"ai.usage.completionTokens\": result.usage.outputTokens,\n                        // standardized gen-ai llm span attributes:\n                        \"gen_ai.response.finish_reasons\": [result.finishReason],\n                        \"gen_ai.response.id\": responseData.id,\n                        \"gen_ai.response.model\": responseData.modelId,\n                        \"gen_ai.usage.input_tokens\": result.usage.inputTokens,\n                        \"gen_ai.usage.output_tokens\": result.usage.outputTokens\n                      }\n                    })\n                  );\n                  return { ...result, response: responseData };\n                }\n              });\n            }\n          );\n          const stepToolCalls = await Promise.all(\n            currentModelResponse.content.filter(\n              (part) => part.type === \"tool-call\"\n            ).map(\n              (toolCall) => parseToolCall({\n                toolCall,\n                tools,\n                repairToolCall,\n                system,\n                messages: stepInputMessages\n              })\n            )\n          );\n          for (const toolCall of stepToolCalls) {\n            if (toolCall.invalid) {\n              continue;\n            }\n            const tool2 = tools[toolCall.toolName];\n            if ((tool2 == null ? void 0 : tool2.onInputAvailable) != null) {\n              await tool2.onInputAvailable({\n                input: toolCall.input,\n                toolCallId: toolCall.toolCallId,\n                messages: stepInputMessages,\n                abortSignal,\n                experimental_context\n              });\n            }\n          }\n          const invalidToolCalls = stepToolCalls.filter(\n            (toolCall) => toolCall.invalid && toolCall.dynamic\n          );\n          clientToolOutputs = [];\n          for (const toolCall of invalidToolCalls) {\n            clientToolOutputs.push({\n              type: \"tool-error\",\n              toolCallId: toolCall.toolCallId,\n              toolName: toolCall.toolName,\n              input: toolCall.input,\n              error: getErrorMessage5(toolCall.error),\n              dynamic: true\n            });\n          }\n          clientToolCalls = stepToolCalls.filter(\n            (toolCall) => !toolCall.providerExecuted\n          );\n          if (tools != null) {\n            clientToolOutputs.push(\n              ...await executeTools({\n                toolCalls: clientToolCalls.filter(\n                  (toolCall) => !toolCall.invalid\n                ),\n                tools,\n                tracer,\n                telemetry,\n                messages: stepInputMessages,\n                abortSignal,\n                experimental_context\n              })\n            );\n          }\n          const stepContent = asContent({\n            content: currentModelResponse.content,\n            toolCalls: stepToolCalls,\n            toolOutputs: clientToolOutputs\n          });\n          responseMessages.push(\n            ...toResponseMessages({\n              content: stepContent,\n              tools\n            })\n          );\n          const currentStepResult = new DefaultStepResult({\n            content: stepContent,\n            finishReason: currentModelResponse.finishReason,\n            usage: currentModelResponse.usage,\n            warnings: currentModelResponse.warnings,\n            providerMetadata: currentModelResponse.providerMetadata,\n            request: (_f = currentModelResponse.request) != null ? _f : {},\n            response: {\n              ...currentModelResponse.response,\n              // deep clone msgs to avoid mutating past messages in multi-step:\n              messages: structuredClone(responseMessages)\n            }\n          });\n          logWarnings((_g = currentModelResponse.warnings) != null ? _g : []);\n          steps.push(currentStepResult);\n          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n        } while (\n          // there are tool calls:\n          clientToolCalls.length > 0 && // all current tool calls have outputs (incl. execution errors):\n          clientToolOutputs.length === clientToolCalls.length && // continue until a stop condition is met:\n          !await isStopConditionMet({ stopConditions, steps })\n        );\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.response.finishReason\": currentModelResponse.finishReason,\n              \"ai.response.text\": {\n                output: () => extractTextContent(currentModelResponse.content)\n              },\n              \"ai.response.toolCalls\": {\n                output: () => {\n                  const toolCalls = asToolCalls(currentModelResponse.content);\n                  return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                }\n              },\n              \"ai.response.providerMetadata\": JSON.stringify(\n                currentModelResponse.providerMetadata\n              ),\n              // TODO rename telemetry attributes to inputTokens and outputTokens\n              \"ai.usage.promptTokens\": currentModelResponse.usage.inputTokens,\n              \"ai.usage.completionTokens\": currentModelResponse.usage.outputTokens\n            }\n          })\n        );\n        const lastStep = steps[steps.length - 1];\n        let resolvedOutput;\n        if (lastStep.finishReason === \"stop\") {\n          resolvedOutput = await (output == null ? void 0 : output.parseOutput(\n            { text: lastStep.text },\n            {\n              response: lastStep.response,\n              usage: lastStep.usage,\n              finishReason: lastStep.finishReason\n            }\n          ));\n        }\n        return new DefaultGenerateTextResult({\n          steps,\n          resolvedOutput\n        });\n      }\n    });\n  } catch (error) {\n    throw wrapGatewayError(error);\n  }\n}\nasync function executeTools({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n  experimental_context\n}) {\n  const toolOutputs = await Promise.all(\n    toolCalls.map(async ({ toolCallId, toolName, input }) => {\n      const tool2 = tools[toolName];\n      if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n      }\n      return recordSpan({\n        name: \"ai.toolCall\",\n        attributes: selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            ...assembleOperationName({\n              operationId: \"ai.toolCall\",\n              telemetry\n            }),\n            \"ai.toolCall.name\": toolName,\n            \"ai.toolCall.id\": toolCallId,\n            \"ai.toolCall.args\": {\n              output: () => JSON.stringify(input)\n            }\n          }\n        }),\n        tracer,\n        fn: async (span) => {\n          try {\n            const stream = executeTool({\n              execute: tool2.execute.bind(tool2),\n              input,\n              options: {\n                toolCallId,\n                messages,\n                abortSignal,\n                experimental_context\n              }\n            });\n            let output;\n            for await (const part of stream) {\n              if (part.type === \"final\") {\n                output = part.output;\n              }\n            }\n            try {\n              span.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.toolCall.result\": {\n                      output: () => JSON.stringify(output)\n                    }\n                  }\n                })\n              );\n            } catch (ignored) {\n            }\n            return {\n              type: \"tool-result\",\n              toolCallId,\n              toolName,\n              input,\n              output,\n              dynamic: tool2.type === \"dynamic\"\n            };\n          } catch (error) {\n            recordErrorOnSpan(span, error);\n            return {\n              type: \"tool-error\",\n              toolCallId,\n              toolName,\n              input,\n              error,\n              dynamic: tool2.type === \"dynamic\"\n            };\n          }\n        }\n      });\n    })\n  );\n  return toolOutputs.filter(\n    (output) => output != null\n  );\n}\nvar DefaultGenerateTextResult = class {\n  constructor(options) {\n    this.steps = options.steps;\n    this.resolvedOutput = options.resolvedOutput;\n  }\n  get finalStep() {\n    return this.steps[this.steps.length - 1];\n  }\n  get content() {\n    return this.finalStep.content;\n  }\n  get text() {\n    return this.finalStep.text;\n  }\n  get files() {\n    return this.finalStep.files;\n  }\n  get reasoningText() {\n    return this.finalStep.reasoningText;\n  }\n  get reasoning() {\n    return this.finalStep.reasoning;\n  }\n  get toolCalls() {\n    return this.finalStep.toolCalls;\n  }\n  get staticToolCalls() {\n    return this.finalStep.staticToolCalls;\n  }\n  get dynamicToolCalls() {\n    return this.finalStep.dynamicToolCalls;\n  }\n  get toolResults() {\n    return this.finalStep.toolResults;\n  }\n  get staticToolResults() {\n    return this.finalStep.staticToolResults;\n  }\n  get dynamicToolResults() {\n    return this.finalStep.dynamicToolResults;\n  }\n  get sources() {\n    return this.finalStep.sources;\n  }\n  get finishReason() {\n    return this.finalStep.finishReason;\n  }\n  get warnings() {\n    return this.finalStep.warnings;\n  }\n  get providerMetadata() {\n    return this.finalStep.providerMetadata;\n  }\n  get response() {\n    return this.finalStep.response;\n  }\n  get request() {\n    return this.finalStep.request;\n  }\n  get usage() {\n    return this.finalStep.usage;\n  }\n  get totalUsage() {\n    return this.steps.reduce(\n      (totalUsage, step) => {\n        return addLanguageModelUsage(totalUsage, step.usage);\n      },\n      {\n        inputTokens: void 0,\n        outputTokens: void 0,\n        totalTokens: void 0,\n        reasoningTokens: void 0,\n        cachedInputTokens: void 0\n      }\n    );\n  }\n  get experimental_output() {\n    if (this.resolvedOutput == null) {\n      throw new NoOutputSpecifiedError();\n    }\n    return this.resolvedOutput;\n  }\n};\nfunction asToolCalls(content) {\n  const parts = content.filter(\n    (part) => part.type === \"tool-call\"\n  );\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map((toolCall) => ({\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: toolCall.input\n  }));\n}\nfunction asContent({\n  content,\n  toolCalls,\n  toolOutputs\n}) {\n  return [\n    ...content.map((part) => {\n      switch (part.type) {\n        case \"text\":\n        case \"reasoning\":\n        case \"source\":\n          return part;\n        case \"file\": {\n          return {\n            type: \"file\",\n            file: new DefaultGeneratedFile(part)\n          };\n        }\n        case \"tool-call\": {\n          return toolCalls.find(\n            (toolCall) => toolCall.toolCallId === part.toolCallId\n          );\n        }\n        case \"tool-result\": {\n          const toolCall = toolCalls.find(\n            (toolCall2) => toolCall2.toolCallId === part.toolCallId\n          );\n          if (toolCall == null) {\n            throw new Error(`Tool call ${part.toolCallId} not found.`);\n          }\n          if (part.isError) {\n            return {\n              type: \"tool-error\",\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              input: toolCall.input,\n              error: part.result,\n              providerExecuted: true,\n              dynamic: toolCall.dynamic\n            };\n          }\n          return {\n            type: \"tool-result\",\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            input: toolCall.input,\n            output: part.result,\n            providerExecuted: true,\n            dynamic: toolCall.dynamic\n          };\n        }\n      }\n    }),\n    ...toolOutputs\n  ];\n}\n\n// src/generate-text/stream-text.ts\nimport {\n  getErrorMessage as getErrorMessage7\n} from \"@ai-sdk/provider\";\nimport {\n  createIdGenerator as createIdGenerator2,\n  DelayedPromise,\n  isAbortError as isAbortError2\n} from \"@ai-sdk/provider-utils\";\n\n// src/util/prepare-headers.ts\nfunction prepareHeaders(headers, defaultHeaders) {\n  const responseHeaders = new Headers(headers != null ? headers : {});\n  for (const [key, value] of Object.entries(defaultHeaders)) {\n    if (!responseHeaders.has(key)) {\n      responseHeaders.set(key, value);\n    }\n  }\n  return responseHeaders;\n}\n\n// src/text-stream/create-text-stream-response.ts\nfunction createTextStreamResponse({\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  return new Response(textStream.pipeThrough(new TextEncoderStream()), {\n    status: status != null ? status : 200,\n    statusText,\n    headers: prepareHeaders(headers, {\n      \"content-type\": \"text/plain; charset=utf-8\"\n    })\n  });\n}\n\n// src/util/write-to-server-response.ts\nfunction writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream\n}) {\n  const statusCode = status != null ? status : 200;\n  if (statusText !== void 0) {\n    response.writeHead(statusCode, statusText, headers);\n  } else {\n    response.writeHead(statusCode, headers);\n  }\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done)\n          break;\n        const canContinue = response.write(value);\n        if (!canContinue) {\n          await new Promise((resolve2) => {\n            response.once(\"drain\", resolve2);\n          });\n        }\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n  read();\n}\n\n// src/text-stream/pipe-text-stream-to-response.ts\nfunction pipeTextStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, {\n        \"content-type\": \"text/plain; charset=utf-8\"\n      }).entries()\n    ),\n    stream: textStream.pipeThrough(new TextEncoderStream())\n  });\n}\n\n// src/ui-message-stream/json-to-sse-transform-stream.ts\nvar JsonToSseTransformStream = class extends TransformStream {\n  constructor() {\n    super({\n      transform(part, controller) {\n        controller.enqueue(`data: ${JSON.stringify(part)}\n\n`);\n      },\n      flush(controller) {\n        controller.enqueue(\"data: [DONE]\\n\\n\");\n      }\n    });\n  }\n};\n\n// src/ui-message-stream/ui-message-stream-headers.ts\nvar UI_MESSAGE_STREAM_HEADERS = {\n  \"content-type\": \"text/event-stream\",\n  \"cache-control\": \"no-cache\",\n  connection: \"keep-alive\",\n  \"x-vercel-ai-ui-message-stream\": \"v1\",\n  \"x-accel-buffering\": \"no\"\n  // disable nginx buffering\n};\n\n// src/ui-message-stream/create-ui-message-stream-response.ts\nfunction createUIMessageStreamResponse({\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream\n}) {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({ stream: stream2 });\n  }\n  return new Response(sseStream.pipeThrough(new TextEncoderStream()), {\n    status,\n    statusText,\n    headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)\n  });\n}\n\n// src/ui-message-stream/get-response-ui-message-id.ts\nfunction getResponseUIMessageId({\n  originalMessages,\n  responseMessageId\n}) {\n  if (originalMessages == null) {\n    return void 0;\n  }\n  const lastMessage = originalMessages[originalMessages.length - 1];\n  return (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage.id : typeof responseMessageId === \"function\" ? responseMessageId() : responseMessageId;\n}\n\n// src/ui/process-ui-message-stream.ts\nimport {\n  validateTypes\n} from \"@ai-sdk/provider-utils\";\n\n// src/ui-message-stream/ui-message-chunks.ts\nimport { z as z7 } from \"zod/v4\";\nimport { lazyValidator, zodSchema } from \"@ai-sdk/provider-utils\";\nvar uiMessageChunkSchema = lazyValidator(\n  () => zodSchema(\n    z7.union([\n      z7.strictObject({\n        type: z7.literal(\"text-start\"),\n        id: z7.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"text-delta\"),\n        id: z7.string(),\n        delta: z7.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"text-end\"),\n        id: z7.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"error\"),\n        errorText: z7.string()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"tool-input-start\"),\n        toolCallId: z7.string(),\n        toolName: z7.string(),\n        providerExecuted: z7.boolean().optional(),\n        dynamic: z7.boolean().optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"tool-input-delta\"),\n        toolCallId: z7.string(),\n        inputTextDelta: z7.string()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"tool-input-available\"),\n        toolCallId: z7.string(),\n        toolName: z7.string(),\n        input: z7.unknown(),\n        providerExecuted: z7.boolean().optional(),\n        providerMetadata: providerMetadataSchema.optional(),\n        dynamic: z7.boolean().optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"tool-input-error\"),\n        toolCallId: z7.string(),\n        toolName: z7.string(),\n        input: z7.unknown(),\n        providerExecuted: z7.boolean().optional(),\n        providerMetadata: providerMetadataSchema.optional(),\n        dynamic: z7.boolean().optional(),\n        errorText: z7.string()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"tool-output-available\"),\n        toolCallId: z7.string(),\n        output: z7.unknown(),\n        providerExecuted: z7.boolean().optional(),\n        dynamic: z7.boolean().optional(),\n        preliminary: z7.boolean().optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"tool-output-error\"),\n        toolCallId: z7.string(),\n        errorText: z7.string(),\n        providerExecuted: z7.boolean().optional(),\n        dynamic: z7.boolean().optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"reasoning-start\"),\n        id: z7.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"reasoning-delta\"),\n        id: z7.string(),\n        delta: z7.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"reasoning-end\"),\n        id: z7.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"source-url\"),\n        sourceId: z7.string(),\n        url: z7.string(),\n        title: z7.string().optional(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"source-document\"),\n        sourceId: z7.string(),\n        mediaType: z7.string(),\n        title: z7.string(),\n        filename: z7.string().optional(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"file\"),\n        url: z7.string(),\n        mediaType: z7.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      z7.strictObject({\n        type: z7.custom(\n          (value) => typeof value === \"string\" && value.startsWith(\"data-\"),\n          { message: 'Type must start with \"data-\"' }\n        ),\n        id: z7.string().optional(),\n        data: z7.unknown(),\n        transient: z7.boolean().optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"start-step\")\n      }),\n      z7.strictObject({\n        type: z7.literal(\"finish-step\")\n      }),\n      z7.strictObject({\n        type: z7.literal(\"start\"),\n        messageId: z7.string().optional(),\n        messageMetadata: z7.unknown().optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"finish\"),\n        finishReason: z7.enum([\n          \"stop\",\n          \"length\",\n          \"content-filter\",\n          \"tool-calls\",\n          \"error\",\n          \"other\",\n          \"unknown\"\n        ]).optional(),\n        messageMetadata: z7.unknown().optional()\n      }),\n      z7.strictObject({\n        type: z7.literal(\"abort\")\n      }),\n      z7.strictObject({\n        type: z7.literal(\"message-metadata\"),\n        messageMetadata: z7.unknown()\n      })\n    ])\n  )\n);\nfunction isDataUIMessageChunk(chunk) {\n  return chunk.type.startsWith(\"data-\");\n}\n\n// src/util/merge-objects.ts\nfunction mergeObjects(base, overrides) {\n  if (base === void 0 && overrides === void 0) {\n    return void 0;\n  }\n  if (base === void 0) {\n    return overrides;\n  }\n  if (overrides === void 0) {\n    return base;\n  }\n  const result = { ...base };\n  for (const key in overrides) {\n    if (Object.prototype.hasOwnProperty.call(overrides, key)) {\n      const overridesValue = overrides[key];\n      if (overridesValue === void 0)\n        continue;\n      const baseValue = key in base ? base[key] : void 0;\n      const isSourceObject = overridesValue !== null && typeof overridesValue === \"object\" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);\n      const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === \"object\" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);\n      if (isSourceObject && isTargetObject) {\n        result[key] = mergeObjects(\n          baseValue,\n          overridesValue\n        );\n      } else {\n        result[key] = overridesValue;\n      }\n    }\n  }\n  return result;\n}\n\n// src/util/parse-partial-json.ts\nimport { safeParseJSON as safeParseJSON2 } from \"@ai-sdk/provider-utils\";\n\n// src/util/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// src/util/parse-partial-json.ts\nasync function parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return { value: void 0, state: \"undefined-input\" };\n  }\n  let result = await safeParseJSON2({ text: jsonText });\n  if (result.success) {\n    return { value: result.value, state: \"successful-parse\" };\n  }\n  result = await safeParseJSON2({ text: fixJson(jsonText) });\n  if (result.success) {\n    return { value: result.value, state: \"repaired-parse\" };\n  }\n  return { value: void 0, state: \"failed-parse\" };\n}\n\n// src/ui/ui-messages.ts\nfunction isDataUIPart(part) {\n  return part.type.startsWith(\"data-\");\n}\nfunction isTextUIPart(part) {\n  return part.type === \"text\";\n}\nfunction isFileUIPart(part) {\n  return part.type === \"file\";\n}\nfunction isReasoningUIPart(part) {\n  return part.type === \"reasoning\";\n}\nfunction isToolUIPart(part) {\n  return part.type.startsWith(\"tool-\");\n}\nfunction isDynamicToolUIPart(part) {\n  return part.type === \"dynamic-tool\";\n}\nfunction isToolOrDynamicToolUIPart(part) {\n  return isToolUIPart(part) || isDynamicToolUIPart(part);\n}\nfunction getToolName(part) {\n  return part.type.split(\"-\").slice(1).join(\"-\");\n}\nfunction getToolOrDynamicToolName(part) {\n  return isDynamicToolUIPart(part) ? part.toolName : getToolName(part);\n}\n\n// src/ui/process-ui-message-stream.ts\nfunction createStreamingUIMessageState({\n  lastMessage,\n  messageId\n}) {\n  return {\n    message: (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage : {\n      id: messageId,\n      metadata: void 0,\n      role: \"assistant\",\n      parts: []\n    },\n    activeTextParts: {},\n    activeReasoningParts: {},\n    partialToolCalls: {}\n  };\n}\nfunction processUIMessageStream({\n  stream,\n  messageMetadataSchema,\n  dataPartSchemas,\n  runUpdateMessageJob,\n  onError,\n  onToolCall,\n  onData\n}) {\n  return stream.pipeThrough(\n    new TransformStream({\n      async transform(chunk, controller) {\n        await runUpdateMessageJob(async ({ state, write }) => {\n          var _a16, _b, _c, _d;\n          function getToolInvocation(toolCallId) {\n            const toolInvocations = state.message.parts.filter(isToolUIPart);\n            const toolInvocation = toolInvocations.find(\n              (invocation) => invocation.toolCallId === toolCallId\n            );\n            if (toolInvocation == null) {\n              throw new Error(\n                \"tool-output-error must be preceded by a tool-input-available\"\n              );\n            }\n            return toolInvocation;\n          }\n          function getDynamicToolInvocation(toolCallId) {\n            const toolInvocations = state.message.parts.filter(\n              (part) => part.type === \"dynamic-tool\"\n            );\n            const toolInvocation = toolInvocations.find(\n              (invocation) => invocation.toolCallId === toolCallId\n            );\n            if (toolInvocation == null) {\n              throw new Error(\n                \"tool-output-error must be preceded by a tool-input-available\"\n              );\n            }\n            return toolInvocation;\n          }\n          function updateToolPart(options) {\n            var _a17;\n            const part = state.message.parts.find(\n              (part2) => isToolUIPart(part2) && part2.toolCallId === options.toolCallId\n            );\n            const anyOptions = options;\n            const anyPart = part;\n            if (part != null) {\n              part.state = options.state;\n              anyPart.input = anyOptions.input;\n              anyPart.output = anyOptions.output;\n              anyPart.errorText = anyOptions.errorText;\n              anyPart.rawInput = anyOptions.rawInput;\n              anyPart.preliminary = anyOptions.preliminary;\n              anyPart.providerExecuted = (_a17 = anyOptions.providerExecuted) != null ? _a17 : part.providerExecuted;\n              if (anyOptions.providerMetadata != null && part.state === \"input-available\") {\n                part.callProviderMetadata = anyOptions.providerMetadata;\n              }\n            } else {\n              state.message.parts.push({\n                type: `tool-${options.toolName}`,\n                toolCallId: options.toolCallId,\n                state: options.state,\n                input: anyOptions.input,\n                output: anyOptions.output,\n                rawInput: anyOptions.rawInput,\n                errorText: anyOptions.errorText,\n                providerExecuted: anyOptions.providerExecuted,\n                preliminary: anyOptions.preliminary,\n                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n              });\n            }\n          }\n          function updateDynamicToolPart(options) {\n            var _a17, _b2;\n            const part = state.message.parts.find(\n              (part2) => part2.type === \"dynamic-tool\" && part2.toolCallId === options.toolCallId\n            );\n            const anyOptions = options;\n            const anyPart = part;\n            if (part != null) {\n              part.state = options.state;\n              anyPart.toolName = options.toolName;\n              anyPart.input = anyOptions.input;\n              anyPart.output = anyOptions.output;\n              anyPart.errorText = anyOptions.errorText;\n              anyPart.rawInput = (_a17 = anyOptions.rawInput) != null ? _a17 : anyPart.rawInput;\n              anyPart.preliminary = anyOptions.preliminary;\n              anyPart.providerExecuted = (_b2 = anyOptions.providerExecuted) != null ? _b2 : part.providerExecuted;\n              if (anyOptions.providerMetadata != null && part.state === \"input-available\") {\n                part.callProviderMetadata = anyOptions.providerMetadata;\n              }\n            } else {\n              state.message.parts.push({\n                type: \"dynamic-tool\",\n                toolName: options.toolName,\n                toolCallId: options.toolCallId,\n                state: options.state,\n                input: anyOptions.input,\n                output: anyOptions.output,\n                errorText: anyOptions.errorText,\n                preliminary: anyOptions.preliminary,\n                providerExecuted: anyOptions.providerExecuted,\n                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n              });\n            }\n          }\n          async function updateMessageMetadata(metadata) {\n            if (metadata != null) {\n              const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;\n              if (messageMetadataSchema != null) {\n                await validateTypes({\n                  value: mergedMetadata,\n                  schema: messageMetadataSchema\n                });\n              }\n              state.message.metadata = mergedMetadata;\n            }\n          }\n          switch (chunk.type) {\n            case \"text-start\": {\n              const textPart = {\n                type: \"text\",\n                text: \"\",\n                providerMetadata: chunk.providerMetadata,\n                state: \"streaming\"\n              };\n              state.activeTextParts[chunk.id] = textPart;\n              state.message.parts.push(textPart);\n              write();\n              break;\n            }\n            case \"text-delta\": {\n              const textPart = state.activeTextParts[chunk.id];\n              textPart.text += chunk.delta;\n              textPart.providerMetadata = (_a16 = chunk.providerMetadata) != null ? _a16 : textPart.providerMetadata;\n              write();\n              break;\n            }\n            case \"text-end\": {\n              const textPart = state.activeTextParts[chunk.id];\n              textPart.state = \"done\";\n              textPart.providerMetadata = (_b = chunk.providerMetadata) != null ? _b : textPart.providerMetadata;\n              delete state.activeTextParts[chunk.id];\n              write();\n              break;\n            }\n            case \"reasoning-start\": {\n              const reasoningPart = {\n                type: \"reasoning\",\n                text: \"\",\n                providerMetadata: chunk.providerMetadata,\n                state: \"streaming\"\n              };\n              state.activeReasoningParts[chunk.id] = reasoningPart;\n              state.message.parts.push(reasoningPart);\n              write();\n              break;\n            }\n            case \"reasoning-delta\": {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              reasoningPart.text += chunk.delta;\n              reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;\n              write();\n              break;\n            }\n            case \"reasoning-end\": {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;\n              reasoningPart.state = \"done\";\n              delete state.activeReasoningParts[chunk.id];\n              write();\n              break;\n            }\n            case \"file\": {\n              state.message.parts.push({\n                type: \"file\",\n                mediaType: chunk.mediaType,\n                url: chunk.url\n              });\n              write();\n              break;\n            }\n            case \"source-url\": {\n              state.message.parts.push({\n                type: \"source-url\",\n                sourceId: chunk.sourceId,\n                url: chunk.url,\n                title: chunk.title,\n                providerMetadata: chunk.providerMetadata\n              });\n              write();\n              break;\n            }\n            case \"source-document\": {\n              state.message.parts.push({\n                type: \"source-document\",\n                sourceId: chunk.sourceId,\n                mediaType: chunk.mediaType,\n                title: chunk.title,\n                filename: chunk.filename,\n                providerMetadata: chunk.providerMetadata\n              });\n              write();\n              break;\n            }\n            case \"tool-input-start\": {\n              const toolInvocations = state.message.parts.filter(isToolUIPart);\n              state.partialToolCalls[chunk.toolCallId] = {\n                text: \"\",\n                toolName: chunk.toolName,\n                index: toolInvocations.length,\n                dynamic: chunk.dynamic\n              };\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-streaming\",\n                  input: void 0,\n                  providerExecuted: chunk.providerExecuted\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-streaming\",\n                  input: void 0,\n                  providerExecuted: chunk.providerExecuted\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-input-delta\": {\n              const partialToolCall = state.partialToolCalls[chunk.toolCallId];\n              partialToolCall.text += chunk.inputTextDelta;\n              const { value: partialArgs } = await parsePartialJson(\n                partialToolCall.text\n              );\n              if (partialToolCall.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: \"input-streaming\",\n                  input: partialArgs\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: \"input-streaming\",\n                  input: partialArgs\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-input-available\": {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-available\",\n                  input: chunk.input,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-available\",\n                  input: chunk.input,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              }\n              write();\n              if (onToolCall && !chunk.providerExecuted) {\n                await onToolCall({\n                  toolCall: chunk\n                });\n              }\n              break;\n            }\n            case \"tool-input-error\": {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"output-error\",\n                  input: chunk.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"output-error\",\n                  input: void 0,\n                  rawInput: chunk.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-output-available\": {\n              if (chunk.dynamic) {\n                const toolInvocation = getDynamicToolInvocation(\n                  chunk.toolCallId\n                );\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: \"output-available\",\n                  input: toolInvocation.input,\n                  output: chunk.output,\n                  preliminary: chunk.preliminary\n                });\n              } else {\n                const toolInvocation = getToolInvocation(chunk.toolCallId);\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getToolName(toolInvocation),\n                  state: \"output-available\",\n                  input: toolInvocation.input,\n                  output: chunk.output,\n                  providerExecuted: chunk.providerExecuted,\n                  preliminary: chunk.preliminary\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-output-error\": {\n              if (chunk.dynamic) {\n                const toolInvocation = getDynamicToolInvocation(\n                  chunk.toolCallId\n                );\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: \"output-error\",\n                  input: toolInvocation.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted\n                });\n              } else {\n                const toolInvocation = getToolInvocation(chunk.toolCallId);\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getToolName(toolInvocation),\n                  state: \"output-error\",\n                  input: toolInvocation.input,\n                  rawInput: toolInvocation.rawInput,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted\n                });\n              }\n              write();\n              break;\n            }\n            case \"start-step\": {\n              state.message.parts.push({ type: \"step-start\" });\n              break;\n            }\n            case \"finish-step\": {\n              state.activeTextParts = {};\n              state.activeReasoningParts = {};\n              break;\n            }\n            case \"start\": {\n              if (chunk.messageId != null) {\n                state.message.id = chunk.messageId;\n              }\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageId != null || chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"finish\": {\n              if (chunk.finishReason != null) {\n                state.finishReason = chunk.finishReason;\n              }\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"message-metadata\": {\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"error\": {\n              onError == null ? void 0 : onError(new Error(chunk.errorText));\n              break;\n            }\n            default: {\n              if (isDataUIMessageChunk(chunk)) {\n                if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {\n                  await validateTypes({\n                    value: chunk.data,\n                    schema: dataPartSchemas[chunk.type]\n                  });\n                }\n                const dataChunk = chunk;\n                if (dataChunk.transient) {\n                  onData == null ? void 0 : onData(dataChunk);\n                  break;\n                }\n                const existingUIPart = dataChunk.id != null ? state.message.parts.find(\n                  (chunkArg) => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id\n                ) : void 0;\n                if (existingUIPart != null) {\n                  existingUIPart.data = dataChunk.data;\n                } else {\n                  state.message.parts.push(dataChunk);\n                }\n                onData == null ? void 0 : onData(dataChunk);\n                write();\n              }\n            }\n          }\n          controller.enqueue(chunk);\n        });\n      }\n    })\n  );\n}\n\n// src/ui-message-stream/handle-ui-message-stream-finish.ts\nfunction handleUIMessageStreamFinish({\n  messageId,\n  originalMessages = [],\n  onFinish,\n  onError,\n  stream\n}) {\n  let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];\n  if ((lastMessage == null ? void 0 : lastMessage.role) !== \"assistant\") {\n    lastMessage = void 0;\n  } else {\n    messageId = lastMessage.id;\n  }\n  let isAborted = false;\n  const idInjectedStream = stream.pipeThrough(\n    new TransformStream({\n      transform(chunk, controller) {\n        if (chunk.type === \"start\") {\n          const startChunk = chunk;\n          if (startChunk.messageId == null && messageId != null) {\n            startChunk.messageId = messageId;\n          }\n        }\n        if (chunk.type === \"abort\") {\n          isAborted = true;\n        }\n        controller.enqueue(chunk);\n      }\n    })\n  );\n  if (onFinish == null) {\n    return idInjectedStream;\n  }\n  const state = createStreamingUIMessageState({\n    lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,\n    messageId: messageId != null ? messageId : \"\"\n    // will be overridden by the stream\n  });\n  const runUpdateMessageJob = async (job) => {\n    await job({ state, write: () => {\n    } });\n  };\n  let finishCalled = false;\n  const callOnFinish = async () => {\n    if (finishCalled || !onFinish) {\n      return;\n    }\n    finishCalled = true;\n    const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);\n    await onFinish({\n      isAborted,\n      isContinuation,\n      responseMessage: state.message,\n      messages: [\n        ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,\n        state.message\n      ],\n      finishReason: state.finishReason\n    });\n  };\n  return processUIMessageStream({\n    stream: idInjectedStream,\n    runUpdateMessageJob,\n    onError\n  }).pipeThrough(\n    new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      },\n      // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility\n      async cancel() {\n        await callOnFinish();\n      },\n      async flush() {\n        await callOnFinish();\n      }\n    })\n  );\n}\n\n// src/ui-message-stream/pipe-ui-message-stream-to-response.ts\nfunction pipeUIMessageStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream\n}) {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({ stream: stream2 });\n  }\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()\n    ),\n    stream: sseStream.pipeThrough(new TextEncoderStream())\n  });\n}\n\n// src/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source) {\n  const stream = source.pipeThrough(new TransformStream());\n  stream[Symbol.asyncIterator] = function() {\n    const reader = this.getReader();\n    let finished = false;\n    async function cleanup(cancelStream) {\n      var _a16;\n      finished = true;\n      try {\n        if (cancelStream) {\n          await ((_a16 = reader.cancel) == null ? void 0 : _a16.call(reader));\n        }\n      } finally {\n        try {\n          reader.releaseLock();\n        } catch (e) {\n        }\n      }\n    }\n    return {\n      /**\n       * Reads the next chunk from the stream.\n       * @returns A promise resolving to the next IteratorResult.\n       */\n      async next() {\n        if (finished) {\n          return { done: true, value: void 0 };\n        }\n        const { done, value } = await reader.read();\n        if (done) {\n          await cleanup(true);\n          return { done: true, value: void 0 };\n        }\n        return { done: false, value };\n      },\n      /**\n       * Called on early exit (e.g., break from for-await).\n       * Ensures the stream is cancelled and resources are released.\n       * @returns A promise resolving to a completed IteratorResult.\n       */\n      async return() {\n        await cleanup(true);\n        return { done: true, value: void 0 };\n      },\n      /**\n       * Called on early exit with error.\n       * Ensures the stream is cancelled and resources are released, then rethrows the error.\n       * @param err The error to throw.\n       * @returns A promise that rejects with the provided error.\n       */\n      async throw(err) {\n        await cleanup(true);\n        throw err;\n      }\n    };\n  };\n  return stream;\n}\n\n// src/util/consume-stream.ts\nasync function consumeStream({\n  stream,\n  onError\n}) {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done)\n        break;\n    }\n  } catch (error) {\n    onError == null ? void 0 : onError(error);\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n  let resolve2;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve2 = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve: resolve2,\n    reject\n  };\n}\n\n// src/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n  let innerStreamReaders = [];\n  let controller = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise();\n  const terminate = () => {\n    isClosed = true;\n    waitForNewStream.resolve();\n    innerStreamReaders.forEach((reader) => reader.cancel());\n    innerStreamReaders = [];\n    controller == null ? void 0 : controller.close();\n  };\n  const processPull = async () => {\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller == null ? void 0 : controller.close();\n      return;\n    }\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n      if (done) {\n        innerStreamReaders.shift();\n        if (innerStreamReaders.length > 0) {\n          await processPull();\n        } else if (isClosed) {\n          controller == null ? void 0 : controller.close();\n        }\n      } else {\n        controller == null ? void 0 : controller.enqueue(value);\n      }\n    } catch (error) {\n      controller == null ? void 0 : controller.error(error);\n      innerStreamReaders.shift();\n      terminate();\n    }\n  };\n  return {\n    stream: new ReadableStream({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      }\n    }),\n    addStream: (innerStream) => {\n      if (isClosed) {\n        throw new Error(\"Cannot add inner stream: outer stream is closed\");\n      }\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n      if (innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    },\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate\n  };\n}\n\n// src/util/now.ts\nfunction now() {\n  var _a16, _b;\n  return (_b = (_a16 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a16.now()) != null ? _b : Date.now();\n}\n\n// src/generate-text/run-tools-transformation.ts\nimport {\n  executeTool as executeTool2,\n  generateId,\n  getErrorMessage as getErrorMessage6\n} from \"@ai-sdk/provider-utils\";\nfunction runToolsTransformation({\n  tools,\n  generatorStream,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall,\n  experimental_context\n}) {\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const outstandingToolResults = /* @__PURE__ */ new Set();\n  const toolInputs = /* @__PURE__ */ new Map();\n  let canClose = false;\n  let finishChunk = void 0;\n  function attemptClose() {\n    if (canClose && outstandingToolResults.size === 0) {\n      if (finishChunk != null) {\n        toolResultsStreamController.enqueue(finishChunk);\n      }\n      toolResultsStreamController.close();\n    }\n  }\n  const forwardStream = new TransformStream({\n    async transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"stream-start\":\n        case \"text-start\":\n        case \"text-delta\":\n        case \"text-end\":\n        case \"reasoning-start\":\n        case \"reasoning-delta\":\n        case \"reasoning-end\":\n        case \"tool-input-start\":\n        case \"tool-input-delta\":\n        case \"tool-input-end\":\n        case \"source\":\n        case \"response-metadata\":\n        case \"error\":\n        case \"raw\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"file\": {\n          controller.enqueue({\n            type: \"file\",\n            file: new DefaultGeneratedFileWithType({\n              data: chunk.data,\n              mediaType: chunk.mediaType\n            })\n          });\n          break;\n        }\n        case \"finish\": {\n          finishChunk = {\n            type: \"finish\",\n            finishReason: chunk.finishReason,\n            usage: chunk.usage,\n            providerMetadata: chunk.providerMetadata\n          };\n          break;\n        }\n        case \"tool-call\": {\n          try {\n            const toolCall = await parseToolCall({\n              toolCall: chunk,\n              tools,\n              repairToolCall,\n              system,\n              messages\n            });\n            controller.enqueue(toolCall);\n            if (toolCall.invalid) {\n              toolResultsStreamController.enqueue({\n                type: \"tool-error\",\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                input: toolCall.input,\n                error: getErrorMessage6(toolCall.error),\n                dynamic: true\n              });\n              break;\n            }\n            const tool2 = tools[toolCall.toolName];\n            toolInputs.set(toolCall.toolCallId, toolCall.input);\n            if (tool2.onInputAvailable != null) {\n              await tool2.onInputAvailable({\n                input: toolCall.input,\n                toolCallId: toolCall.toolCallId,\n                messages,\n                abortSignal,\n                experimental_context\n              });\n            }\n            if (tool2.execute != null && toolCall.providerExecuted !== true) {\n              const toolExecutionId = generateId();\n              outstandingToolResults.add(toolExecutionId);\n              recordSpan({\n                name: \"ai.toolCall\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.toolCall\",\n                      telemetry\n                    }),\n                    \"ai.toolCall.name\": toolCall.toolName,\n                    \"ai.toolCall.id\": toolCall.toolCallId,\n                    \"ai.toolCall.args\": {\n                      output: () => JSON.stringify(toolCall.input)\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (span) => {\n                  let output;\n                  try {\n                    const stream = executeTool2({\n                      execute: tool2.execute.bind(tool2),\n                      input: toolCall.input,\n                      options: {\n                        toolCallId: toolCall.toolCallId,\n                        messages,\n                        abortSignal,\n                        experimental_context\n                      }\n                    });\n                    for await (const part of stream) {\n                      toolResultsStreamController.enqueue({\n                        ...toolCall,\n                        type: \"tool-result\",\n                        output: part.output,\n                        ...part.type === \"preliminary\" && {\n                          preliminary: true\n                        }\n                      });\n                      if (part.type === \"final\") {\n                        output = part.output;\n                      }\n                    }\n                  } catch (error) {\n                    recordErrorOnSpan(span, error);\n                    toolResultsStreamController.enqueue({\n                      ...toolCall,\n                      type: \"tool-error\",\n                      error\n                    });\n                    outstandingToolResults.delete(toolExecutionId);\n                    attemptClose();\n                    return;\n                  }\n                  outstandingToolResults.delete(toolExecutionId);\n                  attemptClose();\n                  try {\n                    span.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          \"ai.toolCall.result\": {\n                            output: () => JSON.stringify(output)\n                          }\n                        }\n                      })\n                    );\n                  } catch (ignored) {\n                  }\n                }\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({ type: \"error\", error });\n          }\n          break;\n        }\n        case \"tool-result\": {\n          const toolName = chunk.toolName;\n          if (chunk.isError) {\n            toolResultsStreamController.enqueue({\n              type: \"tool-error\",\n              toolCallId: chunk.toolCallId,\n              toolName,\n              input: toolInputs.get(chunk.toolCallId),\n              providerExecuted: chunk.providerExecuted,\n              error: chunk.result\n            });\n          } else {\n            controller.enqueue({\n              type: \"tool-result\",\n              toolCallId: chunk.toolCallId,\n              toolName,\n              input: toolInputs.get(chunk.toolCallId),\n              output: chunk.result,\n              providerExecuted: chunk.providerExecuted\n            });\n          }\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      attemptClose();\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// src/generate-text/stream-text.ts\nvar originalGenerateId2 = createIdGenerator2({\n  prefix: \"aitxt\",\n  size: 24\n});\nfunction streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output: output,\n  experimental_telemetry: telemetry,\n  prepareStep,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  experimental_download: download2,\n  includeRawChunks = false,\n  onChunk,\n  onError = ({ error }) => {\n    console.error(error);\n  },\n  onFinish,\n  onAbort,\n  onStepFinish,\n  experimental_context,\n  _internal: {\n    now: now2 = now,\n    generateId: generateId3 = originalGenerateId2,\n    currentDate = () => /* @__PURE__ */ new Date()\n  } = {},\n  ...settings\n}) {\n  return new DefaultStreamTextResult({\n    model: resolveLanguageModel(model),\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    stopConditions: asArray(stopWhen),\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    now: now2,\n    currentDate,\n    generateId: generateId3,\n    experimental_context,\n    download: download2\n  });\n}\nfunction createOutputTransformStream(output) {\n  if (!output) {\n    return new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n      }\n    });\n  }\n  let firstTextChunkId = void 0;\n  let text2 = \"\";\n  let textChunk = \"\";\n  let lastPublishedJson = \"\";\n  function publishTextChunk({\n    controller,\n    partialOutput = void 0\n  }) {\n    controller.enqueue({\n      part: {\n        type: \"text-delta\",\n        id: firstTextChunkId,\n        text: textChunk\n      },\n      partialOutput\n    });\n    textChunk = \"\";\n  }\n  return new TransformStream({\n    async transform(chunk, controller) {\n      if (chunk.type === \"finish-step\" && textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n      if (chunk.type !== \"text-delta\" && chunk.type !== \"text-start\" && chunk.type !== \"text-end\") {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (firstTextChunkId == null) {\n        firstTextChunkId = chunk.id;\n      } else if (chunk.id !== firstTextChunkId) {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (chunk.type === \"text-start\") {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (chunk.type === \"text-end\") {\n        if (textChunk.length > 0) {\n          publishTextChunk({ controller });\n        }\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      text2 += chunk.text;\n      textChunk += chunk.text;\n      const result = await output.parsePartial({ text: text2 });\n      if (result != null) {\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    }\n  });\n}\nvar DefaultStreamTextResult = class {\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms,\n    activeTools,\n    repairToolCall,\n    stopConditions,\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    now: now2,\n    currentDate,\n    generateId: generateId3,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    experimental_context,\n    download: download2\n  }) {\n    this._totalUsage = new DelayedPromise();\n    this._finishReason = new DelayedPromise();\n    this._steps = new DelayedPromise();\n    this.output = output;\n    this.includeRawChunks = includeRawChunks;\n    this.tools = tools;\n    let stepFinish;\n    let recordedContent = [];\n    const recordedResponseMessages = [];\n    let recordedFinishReason = void 0;\n    let recordedTotalUsage = void 0;\n    let recordedRequest = {};\n    let recordedWarnings = [];\n    const recordedSteps = [];\n    let rootSpan;\n    let activeTextContent = {};\n    let activeReasoningContent = {};\n    const eventProcessor = new TransformStream({\n      async transform(chunk, controller) {\n        var _a16, _b, _c, _d;\n        controller.enqueue(chunk);\n        const { part } = chunk;\n        if (part.type === \"text-delta\" || part.type === \"reasoning-delta\" || part.type === \"source\" || part.type === \"tool-call\" || part.type === \"tool-result\" || part.type === \"tool-input-start\" || part.type === \"tool-input-delta\" || part.type === \"raw\") {\n          await (onChunk == null ? void 0 : onChunk({ chunk: part }));\n        }\n        if (part.type === \"error\") {\n          await onError({ error: wrapGatewayError(part.error) });\n        }\n        if (part.type === \"text-start\") {\n          activeTextContent[part.id] = {\n            type: \"text\",\n            text: \"\",\n            providerMetadata: part.providerMetadata\n          };\n          recordedContent.push(activeTextContent[part.id]);\n        }\n        if (part.type === \"text-delta\") {\n          const activeText = activeTextContent[part.id];\n          if (activeText == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `text part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeText.text += part.text;\n          activeText.providerMetadata = (_a16 = part.providerMetadata) != null ? _a16 : activeText.providerMetadata;\n        }\n        if (part.type === \"text-end\") {\n          const activeText = activeTextContent[part.id];\n          if (activeText == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `text part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeText.providerMetadata = (_b = part.providerMetadata) != null ? _b : activeText.providerMetadata;\n          delete activeTextContent[part.id];\n        }\n        if (part.type === \"reasoning-start\") {\n          activeReasoningContent[part.id] = {\n            type: \"reasoning\",\n            text: \"\",\n            providerMetadata: part.providerMetadata\n          };\n          recordedContent.push(activeReasoningContent[part.id]);\n        }\n        if (part.type === \"reasoning-delta\") {\n          const activeReasoning = activeReasoningContent[part.id];\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `reasoning part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeReasoning.text += part.text;\n          activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;\n        }\n        if (part.type === \"reasoning-end\") {\n          const activeReasoning = activeReasoningContent[part.id];\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `reasoning part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeReasoning.providerMetadata = (_d = part.providerMetadata) != null ? _d : activeReasoning.providerMetadata;\n          delete activeReasoningContent[part.id];\n        }\n        if (part.type === \"file\") {\n          recordedContent.push({ type: \"file\", file: part.file });\n        }\n        if (part.type === \"source\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-call\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-result\" && !part.preliminary) {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-error\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"start-step\") {\n          recordedRequest = part.request;\n          recordedWarnings = part.warnings;\n        }\n        if (part.type === \"finish-step\") {\n          const stepMessages = toResponseMessages({\n            content: recordedContent,\n            tools\n          });\n          const currentStepResult = new DefaultStepResult({\n            content: recordedContent,\n            finishReason: part.finishReason,\n            usage: part.usage,\n            warnings: recordedWarnings,\n            request: recordedRequest,\n            response: {\n              ...part.response,\n              messages: [...recordedResponseMessages, ...stepMessages]\n            },\n            providerMetadata: part.providerMetadata\n          });\n          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n          logWarnings(recordedWarnings);\n          recordedSteps.push(currentStepResult);\n          recordedContent = [];\n          activeReasoningContent = {};\n          activeTextContent = {};\n          recordedResponseMessages.push(...stepMessages);\n          stepFinish.resolve();\n        }\n        if (part.type === \"finish\") {\n          recordedTotalUsage = part.totalUsage;\n          recordedFinishReason = part.finishReason;\n        }\n      },\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            const error = new NoOutputGeneratedError({\n              message: \"No output generated. Check the stream for errors.\"\n            });\n            self._finishReason.reject(error);\n            self._totalUsage.reject(error);\n            self._steps.reject(error);\n            return;\n          }\n          const finishReason = recordedFinishReason != null ? recordedFinishReason : \"unknown\";\n          const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          };\n          self._finishReason.resolve(finishReason);\n          self._totalUsage.resolve(totalUsage);\n          self._steps.resolve(recordedSteps);\n          const finalStep = recordedSteps[recordedSteps.length - 1];\n          await (onFinish == null ? void 0 : onFinish({\n            finishReason,\n            totalUsage,\n            usage: finalStep.usage,\n            content: finalStep.content,\n            text: finalStep.text,\n            reasoningText: finalStep.reasoningText,\n            reasoning: finalStep.reasoning,\n            files: finalStep.files,\n            sources: finalStep.sources,\n            toolCalls: finalStep.toolCalls,\n            staticToolCalls: finalStep.staticToolCalls,\n            dynamicToolCalls: finalStep.dynamicToolCalls,\n            toolResults: finalStep.toolResults,\n            staticToolResults: finalStep.staticToolResults,\n            dynamicToolResults: finalStep.dynamicToolResults,\n            request: finalStep.request,\n            response: finalStep.response,\n            warnings: finalStep.warnings,\n            providerMetadata: finalStep.providerMetadata,\n            steps: recordedSteps\n          }));\n          rootSpan.setAttributes(\n            selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                \"ai.response.finishReason\": finishReason,\n                \"ai.response.text\": { output: () => finalStep.text },\n                \"ai.response.toolCalls\": {\n                  output: () => {\n                    var _a16;\n                    return ((_a16 = finalStep.toolCalls) == null ? void 0 : _a16.length) ? JSON.stringify(finalStep.toolCalls) : void 0;\n                  }\n                },\n                \"ai.response.providerMetadata\": JSON.stringify(\n                  finalStep.providerMetadata\n                ),\n                \"ai.usage.inputTokens\": totalUsage.inputTokens,\n                \"ai.usage.outputTokens\": totalUsage.outputTokens,\n                \"ai.usage.totalTokens\": totalUsage.totalTokens,\n                \"ai.usage.reasoningTokens\": totalUsage.reasoningTokens,\n                \"ai.usage.cachedInputTokens\": totalUsage.cachedInputTokens\n              }\n            })\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      }\n    });\n    const stitchableStream = createStitchableStream();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n    const reader = stitchableStream.stream.getReader();\n    let stream = new ReadableStream({\n      async start(controller) {\n        controller.enqueue({ type: \"start\" });\n      },\n      async pull(controller) {\n        function abort() {\n          onAbort == null ? void 0 : onAbort({ steps: recordedSteps });\n          controller.enqueue({ type: \"abort\" });\n          controller.close();\n        }\n        try {\n          const { done, value } = await reader.read();\n          if (done) {\n            controller.close();\n            return;\n          }\n          if (abortSignal == null ? void 0 : abortSignal.aborted) {\n            abort();\n            return;\n          }\n          controller.enqueue(value);\n        } catch (error) {\n          if (isAbortError2(error) && (abortSignal == null ? void 0 : abortSignal.aborted)) {\n            abort();\n          } else {\n            controller.error(error);\n          }\n        }\n      },\n      cancel(reason) {\n        return stitchableStream.stream.cancel(reason);\n      }\n    });\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools,\n          stopStream() {\n            stitchableStream.terminate();\n          }\n        })\n      );\n    }\n    this.baseStream = stream.pipeThrough(createOutputTransformStream(output)).pipeThrough(eventProcessor);\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal\n    });\n    const tracer = getTracer(telemetry);\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries }\n    });\n    const self = this;\n    recordSpan({\n      name: \"ai.streamText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: \"ai.streamText\", telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          }\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpanArg) => {\n        rootSpan = rootSpanArg;\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage\n        }) {\n          var _a16, _b, _c, _d, _e;\n          const includeRawChunks2 = self.includeRawChunks;\n          stepFinish = new DelayedPromise();\n          const initialPrompt = await standardizePrompt({\n            system,\n            prompt,\n            messages\n          });\n          const stepInputMessages = [\n            ...initialPrompt.messages,\n            ...responseMessages\n          ];\n          const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n            model,\n            steps: recordedSteps,\n            stepNumber: recordedSteps.length,\n            messages: stepInputMessages\n          }));\n          const stepModel = resolveLanguageModel(\n            (_a16 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a16 : model\n          );\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              system: (_b = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b : initialPrompt.system,\n              messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages\n            },\n            supportedUrls: await stepModel.supportedUrls,\n            download: download2\n          });\n          const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({\n            tools,\n            toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,\n            activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools\n          });\n          const {\n            result: { stream: stream2, response, request },\n            doStreamSpan,\n            startTimestampMs\n          } = await retry(\n            () => recordSpan({\n              name: \"ai.streamText.doStream\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.streamText.doStream\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  // model:\n                  \"ai.model.provider\": stepModel.provider,\n                  \"ai.model.id\": stepModel.modelId,\n                  // prompt:\n                  \"ai.prompt.messages\": {\n                    input: () => stringifyForTelemetry(promptMessages)\n                  },\n                  \"ai.prompt.tools\": {\n                    // convert the language model level tools:\n                    input: () => stepTools == null ? void 0 : stepTools.map((tool2) => JSON.stringify(tool2))\n                  },\n                  \"ai.prompt.toolChoice\": {\n                    input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                  },\n                  // standardized gen-ai llm span attributes:\n                  \"gen_ai.system\": stepModel.provider,\n                  \"gen_ai.request.model\": stepModel.modelId,\n                  \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                  \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                  \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                  \"gen_ai.request.stop_sequences\": callSettings.stopSequences,\n                  \"gen_ai.request.temperature\": callSettings.temperature,\n                  \"gen_ai.request.top_k\": callSettings.topK,\n                  \"gen_ai.request.top_p\": callSettings.topP\n                }\n              }),\n              tracer,\n              endWhenDone: false,\n              fn: async (doStreamSpan2) => {\n                return {\n                  startTimestampMs: now2(),\n                  // get before the call\n                  doStreamSpan: doStreamSpan2,\n                  result: await stepModel.doStream({\n                    ...callSettings,\n                    tools: stepTools,\n                    toolChoice: stepToolChoice,\n                    responseFormat: output == null ? void 0 : output.responseFormat,\n                    prompt: promptMessages,\n                    providerOptions,\n                    abortSignal,\n                    headers,\n                    includeRawChunks: includeRawChunks2\n                  })\n                };\n              }\n            })\n          );\n          const streamWithToolResults = runToolsTransformation({\n            tools,\n            generatorStream: stream2,\n            tracer,\n            telemetry,\n            system,\n            messages: stepInputMessages,\n            repairToolCall,\n            abortSignal,\n            experimental_context\n          });\n          const stepRequest = request != null ? request : {};\n          const stepToolCalls = [];\n          const stepToolOutputs = [];\n          let warnings;\n          const activeToolCallToolNames = {};\n          let stepFinishReason = \"unknown\";\n          let stepUsage = {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          };\n          let stepProviderMetadata;\n          let stepFirstChunk = true;\n          let stepResponse = {\n            id: generateId3(),\n            timestamp: currentDate(),\n            modelId: model.modelId\n          };\n          let activeText = \"\";\n          self.addStream(\n            streamWithToolResults.pipeThrough(\n              new TransformStream({\n                async transform(chunk, controller) {\n                  var _a17, _b2, _c2, _d2;\n                  if (chunk.type === \"stream-start\") {\n                    warnings = chunk.warnings;\n                    return;\n                  }\n                  if (stepFirstChunk) {\n                    const msToFirstChunk = now2() - startTimestampMs;\n                    stepFirstChunk = false;\n                    doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                      \"ai.response.msToFirstChunk\": msToFirstChunk\n                    });\n                    doStreamSpan.setAttributes({\n                      \"ai.response.msToFirstChunk\": msToFirstChunk\n                    });\n                    controller.enqueue({\n                      type: \"start-step\",\n                      request: stepRequest,\n                      warnings: warnings != null ? warnings : []\n                    });\n                  }\n                  const chunkType = chunk.type;\n                  switch (chunkType) {\n                    case \"text-start\":\n                    case \"text-end\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"text-delta\": {\n                      if (chunk.delta.length > 0) {\n                        controller.enqueue({\n                          type: \"text-delta\",\n                          id: chunk.id,\n                          text: chunk.delta,\n                          providerMetadata: chunk.providerMetadata\n                        });\n                        activeText += chunk.delta;\n                      }\n                      break;\n                    }\n                    case \"reasoning-start\":\n                    case \"reasoning-end\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"reasoning-delta\": {\n                      controller.enqueue({\n                        type: \"reasoning-delta\",\n                        id: chunk.id,\n                        text: chunk.delta,\n                        providerMetadata: chunk.providerMetadata\n                      });\n                      break;\n                    }\n                    case \"tool-call\": {\n                      controller.enqueue(chunk);\n                      stepToolCalls.push(chunk);\n                      break;\n                    }\n                    case \"tool-result\": {\n                      controller.enqueue(chunk);\n                      if (!chunk.preliminary) {\n                        stepToolOutputs.push(chunk);\n                      }\n                      break;\n                    }\n                    case \"tool-error\": {\n                      controller.enqueue(chunk);\n                      stepToolOutputs.push(chunk);\n                      break;\n                    }\n                    case \"response-metadata\": {\n                      stepResponse = {\n                        id: (_a17 = chunk.id) != null ? _a17 : stepResponse.id,\n                        timestamp: (_b2 = chunk.timestamp) != null ? _b2 : stepResponse.timestamp,\n                        modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId\n                      };\n                      break;\n                    }\n                    case \"finish\": {\n                      stepUsage = chunk.usage;\n                      stepFinishReason = chunk.finishReason;\n                      stepProviderMetadata = chunk.providerMetadata;\n                      const msToFinish = now2() - startTimestampMs;\n                      doStreamSpan.addEvent(\"ai.stream.finish\");\n                      doStreamSpan.setAttributes({\n                        \"ai.response.msToFinish\": msToFinish,\n                        \"ai.response.avgOutputTokensPerSecond\": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish\n                      });\n                      break;\n                    }\n                    case \"file\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"source\": {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"tool-input-start\": {\n                      activeToolCallToolNames[chunk.id] = chunk.toolName;\n                      const tool2 = tools == null ? void 0 : tools[chunk.toolName];\n                      if ((tool2 == null ? void 0 : tool2.onInputStart) != null) {\n                        await tool2.onInputStart({\n                          toolCallId: chunk.id,\n                          messages: stepInputMessages,\n                          abortSignal,\n                          experimental_context\n                        });\n                      }\n                      controller.enqueue({\n                        ...chunk,\n                        dynamic: (tool2 == null ? void 0 : tool2.type) === \"dynamic\"\n                      });\n                      break;\n                    }\n                    case \"tool-input-end\": {\n                      delete activeToolCallToolNames[chunk.id];\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"tool-input-delta\": {\n                      const toolName = activeToolCallToolNames[chunk.id];\n                      const tool2 = tools == null ? void 0 : tools[toolName];\n                      if ((tool2 == null ? void 0 : tool2.onInputDelta) != null) {\n                        await tool2.onInputDelta({\n                          inputTextDelta: chunk.delta,\n                          toolCallId: chunk.id,\n                          messages: stepInputMessages,\n                          abortSignal,\n                          experimental_context\n                        });\n                      }\n                      controller.enqueue(chunk);\n                      break;\n                    }\n                    case \"error\": {\n                      controller.enqueue(chunk);\n                      stepFinishReason = \"error\";\n                      break;\n                    }\n                    case \"raw\": {\n                      if (includeRawChunks2) {\n                        controller.enqueue(chunk);\n                      }\n                      break;\n                    }\n                    default: {\n                      const exhaustiveCheck = chunkType;\n                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                    }\n                  }\n                },\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush(controller) {\n                  const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                  try {\n                    doStreamSpan.setAttributes(\n                      selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          \"ai.response.finishReason\": stepFinishReason,\n                          \"ai.response.text\": {\n                            output: () => activeText\n                          },\n                          \"ai.response.toolCalls\": {\n                            output: () => stepToolCallsJson\n                          },\n                          \"ai.response.id\": stepResponse.id,\n                          \"ai.response.model\": stepResponse.modelId,\n                          \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                          \"ai.response.providerMetadata\": JSON.stringify(stepProviderMetadata),\n                          \"ai.usage.inputTokens\": stepUsage.inputTokens,\n                          \"ai.usage.outputTokens\": stepUsage.outputTokens,\n                          \"ai.usage.totalTokens\": stepUsage.totalTokens,\n                          \"ai.usage.reasoningTokens\": stepUsage.reasoningTokens,\n                          \"ai.usage.cachedInputTokens\": stepUsage.cachedInputTokens,\n                          // standardized gen-ai llm span attributes:\n                          \"gen_ai.response.finish_reasons\": [stepFinishReason],\n                          \"gen_ai.response.id\": stepResponse.id,\n                          \"gen_ai.response.model\": stepResponse.modelId,\n                          \"gen_ai.usage.input_tokens\": stepUsage.inputTokens,\n                          \"gen_ai.usage.output_tokens\": stepUsage.outputTokens\n                        }\n                      })\n                    );\n                  } catch (error) {\n                  } finally {\n                    doStreamSpan.end();\n                  }\n                  controller.enqueue({\n                    type: \"finish-step\",\n                    finishReason: stepFinishReason,\n                    usage: stepUsage,\n                    providerMetadata: stepProviderMetadata,\n                    response: {\n                      ...stepResponse,\n                      headers: response == null ? void 0 : response.headers\n                    }\n                  });\n                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n                  await stepFinish.promise;\n                  const clientToolCalls = stepToolCalls.filter(\n                    (toolCall) => toolCall.providerExecuted !== true\n                  );\n                  const clientToolOutputs = stepToolOutputs.filter(\n                    (toolOutput) => toolOutput.providerExecuted !== true\n                  );\n                  if (clientToolCalls.length > 0 && // all current tool calls have outputs (incl. execution errors):\n                  clientToolOutputs.length === clientToolCalls.length && // continue until a stop condition is met:\n                  !await isStopConditionMet({\n                    stopConditions,\n                    steps: recordedSteps\n                  })) {\n                    responseMessages.push(\n                      ...toResponseMessages({\n                        content: (\n                          // use transformed content to create the messages for the next step:\n                          recordedSteps[recordedSteps.length - 1].content\n                        ),\n                        tools\n                      })\n                    );\n                    try {\n                      await streamStep({\n                        currentStep: currentStep + 1,\n                        responseMessages,\n                        usage: combinedUsage\n                      });\n                    } catch (error) {\n                      controller.enqueue({\n                        type: \"error\",\n                        error\n                      });\n                      self.closeStream();\n                    }\n                  } else {\n                    controller.enqueue({\n                      type: \"finish\",\n                      finishReason: stepFinishReason,\n                      totalUsage: combinedUsage\n                    });\n                    self.closeStream();\n                  }\n                }\n              })\n            )\n          );\n        }\n        await streamStep({\n          currentStep: 0,\n          responseMessages: [],\n          usage: {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0\n          }\n        });\n      }\n    }).catch((error) => {\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n      self.closeStream();\n    });\n  }\n  get steps() {\n    this.consumeStream();\n    return this._steps.promise;\n  }\n  get finalStep() {\n    return this.steps.then((steps) => steps[steps.length - 1]);\n  }\n  get content() {\n    return this.finalStep.then((step) => step.content);\n  }\n  get warnings() {\n    return this.finalStep.then((step) => step.warnings);\n  }\n  get providerMetadata() {\n    return this.finalStep.then((step) => step.providerMetadata);\n  }\n  get text() {\n    return this.finalStep.then((step) => step.text);\n  }\n  get reasoningText() {\n    return this.finalStep.then((step) => step.reasoningText);\n  }\n  get reasoning() {\n    return this.finalStep.then((step) => step.reasoning);\n  }\n  get sources() {\n    return this.finalStep.then((step) => step.sources);\n  }\n  get files() {\n    return this.finalStep.then((step) => step.files);\n  }\n  get toolCalls() {\n    return this.finalStep.then((step) => step.toolCalls);\n  }\n  get staticToolCalls() {\n    return this.finalStep.then((step) => step.staticToolCalls);\n  }\n  get dynamicToolCalls() {\n    return this.finalStep.then((step) => step.dynamicToolCalls);\n  }\n  get toolResults() {\n    return this.finalStep.then((step) => step.toolResults);\n  }\n  get staticToolResults() {\n    return this.finalStep.then((step) => step.staticToolResults);\n  }\n  get dynamicToolResults() {\n    return this.finalStep.then((step) => step.dynamicToolResults);\n  }\n  get usage() {\n    return this.finalStep.then((step) => step.usage);\n  }\n  get request() {\n    return this.finalStep.then((step) => step.request);\n  }\n  get response() {\n    return this.finalStep.then((step) => step.response);\n  }\n  get totalUsage() {\n    this.consumeStream();\n    return this._totalUsage.promise;\n  }\n  get finishReason() {\n    this.consumeStream();\n    return this._finishReason.promise;\n  }\n  /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */\n  teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            if (part.type === \"text-delta\") {\n              controller.enqueue(part.text);\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          }\n        })\n      )\n    );\n  }\n  async consumeStream(options) {\n    var _a16;\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options == null ? void 0 : options.onError\n      });\n    } catch (error) {\n      (_a16 = options == null ? void 0 : options.onError) == null ? void 0 : _a16.call(options, error);\n    }\n  }\n  get experimental_partialOutputStream() {\n    if (this.output == null) {\n      throw new NoOutputSpecifiedError();\n    }\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          }\n        })\n      )\n    );\n  }\n  toUIMessageStream({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning = true,\n    sendSources = false,\n    sendStart = true,\n    sendFinish = true,\n    onError = getErrorMessage7\n  } = {}) {\n    const responseMessageId = generateMessageId != null ? getResponseUIMessageId({\n      originalMessages,\n      responseMessageId: generateMessageId\n    }) : void 0;\n    const toolNamesByCallId = {};\n    const isDynamic = (toolCallId) => {\n      var _a16, _b;\n      const toolName = toolNamesByCallId[toolCallId];\n      const dynamic = ((_b = (_a16 = this.tools) == null ? void 0 : _a16[toolName]) == null ? void 0 : _b.type) === \"dynamic\";\n      return dynamic ? true : void 0;\n    };\n    const baseStream = this.fullStream.pipeThrough(\n      new TransformStream({\n        transform: async (part, controller) => {\n          const messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({ part });\n          const partType = part.type;\n          switch (partType) {\n            case \"text-start\": {\n              controller.enqueue({\n                type: \"text-start\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"text-delta\": {\n              controller.enqueue({\n                type: \"text-delta\",\n                id: part.id,\n                delta: part.text,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"text-end\": {\n              controller.enqueue({\n                type: \"text-end\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"reasoning-start\": {\n              controller.enqueue({\n                type: \"reasoning-start\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"reasoning-delta\": {\n              if (sendReasoning) {\n                controller.enqueue({\n                  type: \"reasoning-delta\",\n                  id: part.id,\n                  delta: part.text,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              break;\n            }\n            case \"reasoning-end\": {\n              controller.enqueue({\n                type: \"reasoning-end\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"file\": {\n              controller.enqueue({\n                type: \"file\",\n                mediaType: part.file.mediaType,\n                url: `data:${part.file.mediaType};base64,${part.file.base64}`\n              });\n              break;\n            }\n            case \"source\": {\n              if (sendSources && part.sourceType === \"url\") {\n                controller.enqueue({\n                  type: \"source-url\",\n                  sourceId: part.id,\n                  url: part.url,\n                  title: part.title,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              if (sendSources && part.sourceType === \"document\") {\n                controller.enqueue({\n                  type: \"source-document\",\n                  sourceId: part.id,\n                  mediaType: part.mediaType,\n                  title: part.title,\n                  filename: part.filename,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              break;\n            }\n            case \"tool-input-start\": {\n              toolNamesByCallId[part.id] = part.toolName;\n              const dynamic = isDynamic(part.id);\n              controller.enqueue({\n                type: \"tool-input-start\",\n                toolCallId: part.id,\n                toolName: part.toolName,\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"tool-input-delta\": {\n              controller.enqueue({\n                type: \"tool-input-delta\",\n                toolCallId: part.id,\n                inputTextDelta: part.delta\n              });\n              break;\n            }\n            case \"tool-call\": {\n              toolNamesByCallId[part.toolCallId] = part.toolName;\n              const dynamic = isDynamic(part.toolCallId);\n              if (part.invalid) {\n                controller.enqueue({\n                  type: \"tool-input-error\",\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},\n                  ...dynamic != null ? { dynamic } : {},\n                  errorText: onError(part.error)\n                });\n              } else {\n                controller.enqueue({\n                  type: \"tool-input-available\",\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},\n                  ...dynamic != null ? { dynamic } : {}\n                });\n              }\n              break;\n            }\n            case \"tool-result\": {\n              const dynamic = isDynamic(part.toolCallId);\n              controller.enqueue({\n                type: \"tool-output-available\",\n                toolCallId: part.toolCallId,\n                output: part.output,\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...part.preliminary != null ? { preliminary: part.preliminary } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"tool-error\": {\n              const dynamic = isDynamic(part.toolCallId);\n              controller.enqueue({\n                type: \"tool-output-error\",\n                toolCallId: part.toolCallId,\n                errorText: onError(part.error),\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"error\": {\n              controller.enqueue({\n                type: \"error\",\n                errorText: onError(part.error)\n              });\n              break;\n            }\n            case \"start-step\": {\n              controller.enqueue({ type: \"start-step\" });\n              break;\n            }\n            case \"finish-step\": {\n              controller.enqueue({ type: \"finish-step\" });\n              break;\n            }\n            case \"start\": {\n              if (sendStart) {\n                controller.enqueue({\n                  type: \"start\",\n                  ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {},\n                  ...responseMessageId != null ? { messageId: responseMessageId } : {}\n                });\n              }\n              break;\n            }\n            case \"finish\": {\n              if (sendFinish) {\n                controller.enqueue({\n                  type: \"finish\",\n                  finishReason: part.finishReason,\n                  ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {}\n                });\n              }\n              break;\n            }\n            case \"abort\": {\n              controller.enqueue(part);\n              break;\n            }\n            case \"tool-input-end\": {\n              break;\n            }\n            case \"raw\": {\n              break;\n            }\n            default: {\n              const exhaustiveCheck = partType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n          if (messageMetadataValue != null && partType !== \"start\" && partType !== \"finish\") {\n            controller.enqueue({\n              type: \"message-metadata\",\n              messageMetadata: messageMetadataValue\n            });\n          }\n        }\n      })\n    );\n    return createAsyncIterableStream(\n      handleUIMessageStreamFinish({\n        stream: baseStream,\n        messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),\n        originalMessages,\n        onFinish,\n        onError\n      })\n    );\n  }\n  pipeUIMessageStreamToResponse(response, {\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  } = {}) {\n    pipeUIMessageStreamToResponse({\n      response,\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toUIMessageStreamResponse({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  } = {}) {\n    return createUIMessageStreamResponse({\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\n\n// src/ui/convert-to-model-messages.ts\nfunction convertToModelMessages(messages, options) {\n  const modelMessages = [];\n  if (options == null ? void 0 : options.ignoreIncompleteToolCalls) {\n    messages = messages.map((message) => ({\n      ...message,\n      parts: message.parts.filter(\n        (part) => !isToolOrDynamicToolUIPart(part) || part.state !== \"input-streaming\" && part.state !== \"input-available\"\n      )\n    }));\n  }\n  for (const message of messages) {\n    switch (message.role) {\n      case \"system\": {\n        const textParts = message.parts.filter(\n          (part) => part.type === \"text\"\n        );\n        const providerMetadata = textParts.reduce((acc, part) => {\n          if (part.providerMetadata != null) {\n            return { ...acc, ...part.providerMetadata };\n          }\n          return acc;\n        }, {});\n        modelMessages.push({\n          role: \"system\",\n          content: textParts.map((part) => part.text).join(\"\"),\n          ...Object.keys(providerMetadata).length > 0 ? { providerOptions: providerMetadata } : {}\n        });\n        break;\n      }\n      case \"user\": {\n        modelMessages.push({\n          role: \"user\",\n          content: message.parts.map((part) => {\n            var _a16;\n            if (isTextUIPart(part)) {\n              return {\n                type: \"text\",\n                text: part.text,\n                ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n              };\n            }\n            if (isFileUIPart(part)) {\n              return {\n                type: \"file\",\n                mediaType: part.mediaType,\n                filename: part.filename,\n                data: part.url,\n                ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n              };\n            }\n            if (isDataUIPart(part)) {\n              return (_a16 = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _a16.call(\n                options,\n                part\n              );\n            }\n          }).filter((part) => part != null)\n        });\n        break;\n      }\n      case \"assistant\": {\n        if (message.parts != null) {\n          let processBlock2 = function() {\n            var _a16, _b, _c;\n            if (block.length === 0) {\n              return;\n            }\n            const content = [];\n            for (const part of block) {\n              if (isTextUIPart(part)) {\n                content.push({\n                  type: \"text\",\n                  text: part.text,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                });\n              } else if (isFileUIPart(part)) {\n                content.push({\n                  type: \"file\",\n                  mediaType: part.mediaType,\n                  filename: part.filename,\n                  data: part.url\n                });\n              } else if (isReasoningUIPart(part)) {\n                content.push({\n                  type: \"reasoning\",\n                  text: part.text,\n                  providerOptions: part.providerMetadata\n                });\n              } else if (isDynamicToolUIPart(part)) {\n                const toolName = part.toolName;\n                if (part.state !== \"input-streaming\") {\n                  content.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input: part.input,\n                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                  });\n                }\n              } else if (isToolUIPart(part)) {\n                const toolName = getToolName(part);\n                if (part.state !== \"input-streaming\") {\n                  content.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input: part.state === \"output-error\" ? (_a16 = part.input) != null ? _a16 : part.rawInput : part.input,\n                    providerExecuted: part.providerExecuted,\n                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                  });\n                  if (part.providerExecuted === true && (part.state === \"output-available\" || part.state === \"output-error\")) {\n                    content.push({\n                      type: \"tool-result\",\n                      toolCallId: part.toolCallId,\n                      toolName,\n                      output: createToolModelOutput({\n                        output: part.state === \"output-error\" ? part.errorText : part.output,\n                        tool: (_b = options == null ? void 0 : options.tools) == null ? void 0 : _b[toolName],\n                        errorMode: part.state === \"output-error\" ? \"json\" : \"none\"\n                      }),\n                      ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                    });\n                  }\n                }\n              } else if (isDataUIPart(part)) {\n                const dataPart = (_c = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _c.call(\n                  options,\n                  part\n                );\n                if (dataPart != null) {\n                  content.push(dataPart);\n                }\n              } else {\n                const _exhaustiveCheck = part;\n                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n              }\n            }\n            modelMessages.push({\n              role: \"assistant\",\n              content\n            });\n            const toolParts = block.filter(\n              (part) => isToolUIPart(part) && part.providerExecuted !== true || part.type === \"dynamic-tool\"\n            );\n            if (toolParts.length > 0) {\n              modelMessages.push({\n                role: \"tool\",\n                content: toolParts.map((toolPart) => {\n                  var _a17;\n                  switch (toolPart.state) {\n                    case \"output-error\":\n                    case \"output-available\": {\n                      const toolName = getToolOrDynamicToolName(toolPart);\n                      return {\n                        type: \"tool-result\",\n                        toolCallId: toolPart.toolCallId,\n                        toolName,\n                        output: createToolModelOutput({\n                          output: toolPart.state === \"output-error\" ? toolPart.errorText : toolPart.output,\n                          tool: (_a17 = options == null ? void 0 : options.tools) == null ? void 0 : _a17[toolName],\n                          errorMode: toolPart.state === \"output-error\" ? \"text\" : \"none\"\n                        }),\n                        ...toolPart.callProviderMetadata != null ? { providerOptions: toolPart.callProviderMetadata } : {}\n                      };\n                    }\n                    default: {\n                      return null;\n                    }\n                  }\n                }).filter(\n                  (output) => output != null\n                )\n              });\n            }\n            block = [];\n          };\n          var processBlock = processBlock2;\n          let block = [];\n          for (const part of message.parts) {\n            if (isTextUIPart(part) || isReasoningUIPart(part) || isFileUIPart(part) || isToolOrDynamicToolUIPart(part) || isDataUIPart(part)) {\n              block.push(part);\n            } else if (part.type === \"step-start\") {\n              processBlock2();\n            }\n          }\n          processBlock2();\n          break;\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = message.role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`\n        });\n      }\n    }\n  }\n  return modelMessages;\n}\nvar convertToCoreMessages = convertToModelMessages;\n\n// src/agent/agent.ts\nvar Agent = class {\n  constructor(settings) {\n    this.settings = settings;\n  }\n  get tools() {\n    return this.settings.tools;\n  }\n  async generate(options) {\n    return generateText({ ...this.settings, ...options });\n  }\n  stream(options) {\n    return streamText({ ...this.settings, ...options });\n  }\n  /**\n   * Creates a response object that streams UI messages to the client.\n   */\n  respond(options) {\n    return this.stream({\n      prompt: convertToModelMessages(options.messages)\n    }).toUIMessageStreamResponse();\n  }\n};\n\n// src/embed/embed.ts\nimport { withUserAgentSuffix as withUserAgentSuffix3 } from \"@ai-sdk/provider-utils\";\nasync function embed({\n  model: modelArg,\n  value,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  const model = resolveEmbeddingModel(modelArg);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const headersWithUserAgent = withUserAgentSuffix3(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embed\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embed\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.value\": { input: () => JSON.stringify(value) }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const { embedding, usage, response, providerMetadata } = await retry(\n        () => (\n          // nested spans to align with the embedMany telemetry data:\n          recordSpan({\n            name: \"ai.embed.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embed.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": { input: () => [JSON.stringify(value)] }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a16;\n              const modelResponse = await model.doEmbed({\n                values: [value],\n                abortSignal,\n                headers: headersWithUserAgent,\n                providerOptions\n              });\n              const embedding2 = modelResponse.embeddings[0];\n              const usage2 = (_a16 = modelResponse.usage) != null ? _a16 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => modelResponse.embeddings.map(\n                        (embedding3) => JSON.stringify(embedding3)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embedding: embedding2,\n                usage: usage2,\n                providerMetadata: modelResponse.providerMetadata,\n                response: modelResponse.response\n              };\n            }\n          })\n        )\n      );\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embedding\": { output: () => JSON.stringify(embedding) },\n            \"ai.usage.tokens\": usage.tokens\n          }\n        })\n      );\n      return new DefaultEmbedResult({\n        value,\n        embedding,\n        usage,\n        providerMetadata,\n        response\n      });\n    }\n  });\n}\nvar DefaultEmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n  }\n};\n\n// src/embed/embed-many.ts\nimport { withUserAgentSuffix as withUserAgentSuffix4 } from \"@ai-sdk/provider-utils\";\n\n// src/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n  return result;\n}\n\n// src/embed/embed-many.ts\nasync function embedMany({\n  model: modelArg,\n  values,\n  maxParallelCalls = Infinity,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  providerOptions,\n  experimental_telemetry: telemetry\n}) {\n  const model = resolveEmbeddingModel(modelArg);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const headersWithUserAgent = withUserAgentSuffix4(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embedMany\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embedMany\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.values\": {\n          input: () => values.map((value) => JSON.stringify(value))\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a16;\n      const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([\n        model.maxEmbeddingsPerCall,\n        model.supportsParallelCalls\n      ]);\n      if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {\n        const { embeddings: embeddings2, usage, response, providerMetadata: providerMetadata2 } = await retry(\n          () => {\n            return recordSpan({\n              name: \"ai.embedMany.doEmbed\",\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: \"ai.embedMany.doEmbed\",\n                    telemetry\n                  }),\n                  ...baseTelemetryAttributes,\n                  // specific settings that only make sense on the outer level:\n                  \"ai.values\": {\n                    input: () => values.map((value) => JSON.stringify(value))\n                  }\n                }\n              }),\n              tracer,\n              fn: async (doEmbedSpan) => {\n                var _a17;\n                const modelResponse = await model.doEmbed({\n                  values,\n                  abortSignal,\n                  headers: headersWithUserAgent,\n                  providerOptions\n                });\n                const embeddings3 = modelResponse.embeddings;\n                const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : { tokens: NaN };\n                doEmbedSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.embeddings\": {\n                        output: () => embeddings3.map(\n                          (embedding) => JSON.stringify(embedding)\n                        )\n                      },\n                      \"ai.usage.tokens\": usage2.tokens\n                    }\n                  })\n                );\n                return {\n                  embeddings: embeddings3,\n                  usage: usage2,\n                  providerMetadata: modelResponse.providerMetadata,\n                  response: modelResponse.response\n                };\n              }\n            });\n          }\n        );\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.embeddings\": {\n                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n              },\n              \"ai.usage.tokens\": usage.tokens\n            }\n          })\n        );\n        return new DefaultEmbedManyResult({\n          values,\n          embeddings: embeddings2,\n          usage,\n          providerMetadata: providerMetadata2,\n          responses: [response]\n        });\n      }\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n      const embeddings = [];\n      const responses = [];\n      let tokens = 0;\n      let providerMetadata;\n      const parallelChunks = splitArray(\n        valueChunks,\n        supportsParallelCalls ? maxParallelCalls : 1\n      );\n      for (const parallelChunk of parallelChunks) {\n        const results = await Promise.all(\n          parallelChunk.map((chunk) => {\n            return retry(() => {\n              return recordSpan({\n                name: \"ai.embedMany.doEmbed\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.embedMany.doEmbed\",\n                      telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.values\": {\n                      input: () => chunk.map((value) => JSON.stringify(value))\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (doEmbedSpan) => {\n                  var _a17;\n                  const modelResponse = await model.doEmbed({\n                    values: chunk,\n                    abortSignal,\n                    headers: headersWithUserAgent,\n                    providerOptions\n                  });\n                  const embeddings2 = modelResponse.embeddings;\n                  const usage = (_a17 = modelResponse.usage) != null ? _a17 : { tokens: NaN };\n                  doEmbedSpan.setAttributes(\n                    selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        \"ai.embeddings\": {\n                          output: () => embeddings2.map(\n                            (embedding) => JSON.stringify(embedding)\n                          )\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                      }\n                    })\n                  );\n                  return {\n                    embeddings: embeddings2,\n                    usage,\n                    providerMetadata: modelResponse.providerMetadata,\n                    response: modelResponse.response\n                  };\n                }\n              });\n            });\n          })\n        );\n        for (const result of results) {\n          embeddings.push(...result.embeddings);\n          responses.push(result.response);\n          tokens += result.usage.tokens;\n          if (result.providerMetadata) {\n            if (!providerMetadata) {\n              providerMetadata = { ...result.providerMetadata };\n            } else {\n              for (const [providerName, metadata] of Object.entries(\n                result.providerMetadata\n              )) {\n                providerMetadata[providerName] = {\n                  ...(_a16 = providerMetadata[providerName]) != null ? _a16 : {},\n                  ...metadata\n                };\n              }\n            }\n          }\n        }\n      }\n      span.setAttributes(\n        selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embeddings\": {\n              output: () => embeddings.map((embedding) => JSON.stringify(embedding))\n            },\n            \"ai.usage.tokens\": tokens\n          }\n        })\n      );\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens },\n        providerMetadata,\n        responses\n      });\n    }\n  });\n}\nvar DefaultEmbedManyResult = class {\n  constructor(options) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n    this.providerMetadata = options.providerMetadata;\n    this.responses = options.responses;\n  }\n};\n\n// src/generate-image/generate-image.ts\nimport { withUserAgentSuffix as withUserAgentSuffix5 } from \"@ai-sdk/provider-utils\";\nasync function generateImage({\n  model: modelArg,\n  prompt,\n  n = 1,\n  maxImagesPerCall,\n  size,\n  aspectRatio,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a16, _b;\n  const model = resolveImageModel(modelArg);\n  const headersWithUserAgent = withUserAgentSuffix5(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const maxImagesPerCallWithDefault = (_a16 = maxImagesPerCall != null ? maxImagesPerCall : await invokeModelMaxImagesPerCall(model)) != null ? _a16 : 1;\n  const callCount = Math.ceil(n / maxImagesPerCallWithDefault);\n  const callImageCounts = Array.from({ length: callCount }, (_, i) => {\n    if (i < callCount - 1) {\n      return maxImagesPerCallWithDefault;\n    }\n    const remainder = n % maxImagesPerCallWithDefault;\n    return remainder === 0 ? maxImagesPerCallWithDefault : remainder;\n  });\n  const results = await Promise.all(\n    callImageCounts.map(\n      async (callImageCount) => retry(\n        () => model.doGenerate({\n          prompt,\n          n: callImageCount,\n          abortSignal,\n          headers: headersWithUserAgent,\n          size,\n          aspectRatio,\n          seed,\n          providerOptions: providerOptions != null ? providerOptions : {}\n        })\n      )\n    )\n  );\n  const images = [];\n  const warnings = [];\n  const responses = [];\n  const providerMetadata = {};\n  for (const result of results) {\n    images.push(\n      ...result.images.map(\n        (image) => {\n          var _a17;\n          return new DefaultGeneratedFile({\n            data: image,\n            mediaType: (_a17 = detectMediaType({\n              data: image,\n              signatures: imageMediaTypeSignatures\n            })) != null ? _a17 : \"image/png\"\n          });\n        }\n      )\n    );\n    warnings.push(...result.warnings);\n    if (result.providerMetadata) {\n      for (const [providerName, metadata] of Object.entries(result.providerMetadata)) {\n        if (providerName === \"gateway\") {\n          const currentEntry = providerMetadata[providerName];\n          if (currentEntry != null && typeof currentEntry === \"object\") {\n            providerMetadata[providerName] = {\n              ...currentEntry,\n              ...metadata\n            };\n          } else {\n            providerMetadata[providerName] = metadata;\n          }\n          const imagesValue = providerMetadata[providerName].images;\n          if (Array.isArray(imagesValue) && imagesValue.length === 0) {\n            delete providerMetadata[providerName].images;\n          }\n        } else {\n          (_b = providerMetadata[providerName]) != null ? _b : providerMetadata[providerName] = { images: [] };\n          providerMetadata[providerName].images.push(\n            ...result.providerMetadata[providerName].images\n          );\n        }\n      }\n    }\n    responses.push(result.response);\n  }\n  logWarnings(warnings);\n  if (!images.length) {\n    throw new NoImageGeneratedError({ responses });\n  }\n  return new DefaultGenerateImageResult({\n    images,\n    warnings,\n    responses,\n    providerMetadata\n  });\n}\nvar DefaultGenerateImageResult = class {\n  constructor(options) {\n    this.images = options.images;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata;\n  }\n  get image() {\n    return this.images[0];\n  }\n};\nasync function invokeModelMaxImagesPerCall(model) {\n  const isFunction = model.maxImagesPerCall instanceof Function;\n  if (!isFunction) {\n    return model.maxImagesPerCall;\n  }\n  return model.maxImagesPerCall({\n    modelId: model.modelId\n  });\n}\n\n// src/generate-object/generate-object.ts\nimport {\n  createIdGenerator as createIdGenerator3,\n  withUserAgentSuffix as withUserAgentSuffix6\n} from \"@ai-sdk/provider-utils\";\n\n// src/generate-text/extract-reasoning-content.ts\nfunction extractReasoningContent(content) {\n  const parts = content.filter(\n    (content2) => content2.type === \"reasoning\"\n  );\n  return parts.length === 0 ? void 0 : parts.map((content2) => content2.text).join(\"\\n\");\n}\n\n// src/generate-object/output-strategy.ts\nimport {\n  isJSONArray,\n  isJSONObject,\n  TypeValidationError as TypeValidationError2,\n  UnsupportedFunctionalityError as UnsupportedFunctionalityError2\n} from \"@ai-sdk/provider\";\nimport {\n  asSchema as asSchema3,\n  safeValidateTypes as safeValidateTypes3\n} from \"@ai-sdk/provider-utils\";\nvar noSchemaOutputStrategy = {\n  type: \"no-schema\",\n  jsonSchema: void 0,\n  async validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n  async validateFinalResult(value, context) {\n    return value === void 0 ? {\n      success: false,\n      error: new NoObjectGeneratedError({\n        message: \"No object generated: response did not match schema.\",\n        text: context.text,\n        response: context.response,\n        usage: context.usage,\n        finishReason: context.finishReason\n      })\n    } : { success: true, value };\n  },\n  createElementStream() {\n    throw new UnsupportedFunctionalityError2({\n      functionality: \"element streams in no-schema mode\"\n    });\n  }\n};\nvar objectOutputStrategy = (schema) => ({\n  type: \"object\",\n  jsonSchema: schema.jsonSchema,\n  async validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value,\n        textDelta\n      }\n    };\n  },\n  async validateFinalResult(value) {\n    return safeValidateTypes3({ value, schema });\n  },\n  createElementStream() {\n    throw new UnsupportedFunctionalityError2({\n      functionality: \"element streams in object mode\"\n    });\n  }\n});\nvar arrayOutputStrategy = (schema) => {\n  const { $schema, ...itemSchema } = schema.jsonSchema;\n  return {\n    type: \"array\",\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        elements: { type: \"array\", items: itemSchema }\n      },\n      required: [\"elements\"],\n      additionalProperties: false\n    },\n    async validatePartialResult({\n      value,\n      latestObject,\n      isFirstDelta,\n      isFinalDelta\n    }) {\n      var _a16;\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError2({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      const resultArray = [];\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = await safeValidateTypes3({ value: element, schema });\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n        if (!result.success) {\n          return result;\n        }\n        resultArray.push(result.value);\n      }\n      const publishedElementCount = (_a16 = latestObject == null ? void 0 : latestObject.length) != null ? _a16 : 0;\n      let textDelta = \"\";\n      if (isFirstDelta) {\n        textDelta += \"[\";\n      }\n      if (publishedElementCount > 0) {\n        textDelta += \",\";\n      }\n      textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(\",\");\n      if (isFinalDelta) {\n        textDelta += \"]\";\n      }\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta\n        }\n      };\n    },\n    async validateFinalResult(value) {\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError2({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      for (const element of inputArray) {\n        const result = await safeValidateTypes3({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n      return { success: true, value: inputArray };\n    },\n    createElementStream(originalStream) {\n      let publishedElements = 0;\n      return createAsyncIterableStream(\n        originalStream.pipeThrough(\n          new TransformStream({\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case \"object\": {\n                  const array = chunk.object;\n                  for (; publishedElements < array.length; publishedElements++) {\n                    controller.enqueue(array[publishedElements]);\n                  }\n                  break;\n                }\n                case \"text-delta\":\n                case \"finish\":\n                case \"error\":\n                  break;\n                default: {\n                  const _exhaustiveCheck = chunk;\n                  throw new Error(\n                    `Unsupported chunk type: ${_exhaustiveCheck}`\n                  );\n                }\n              }\n            }\n          })\n        )\n      );\n    }\n  };\n};\nvar enumOutputStrategy = (enumValues) => {\n  return {\n    type: \"enum\",\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: {\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        result: { type: \"string\", enum: enumValues }\n      },\n      required: [\"result\"],\n      additionalProperties: false\n    },\n    async validateFinalResult(value) {\n      if (!isJSONObject(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new TypeValidationError2({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      return enumValues.includes(result) ? { success: true, value: result } : {\n        success: false,\n        error: new TypeValidationError2({\n          value,\n          cause: \"value must be a string in the enum\"\n        })\n      };\n    },\n    async validatePartialResult({ value, textDelta }) {\n      if (!isJSONObject(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new TypeValidationError2({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      const possibleEnumValues = enumValues.filter(\n        (enumValue) => enumValue.startsWith(result)\n      );\n      if (value.result.length === 0 || possibleEnumValues.length === 0) {\n        return {\n          success: false,\n          error: new TypeValidationError2({\n            value,\n            cause: \"value must be a string in the enum\"\n          })\n        };\n      }\n      return {\n        success: true,\n        value: {\n          partial: possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n          textDelta\n        }\n      };\n    },\n    createElementStream() {\n      throw new UnsupportedFunctionalityError2({\n        functionality: \"element streams in enum mode\"\n      });\n    }\n  };\n};\nfunction getOutputStrategy({\n  output,\n  schema,\n  enumValues\n}) {\n  switch (output) {\n    case \"object\":\n      return objectOutputStrategy(asSchema3(schema));\n    case \"array\":\n      return arrayOutputStrategy(asSchema3(schema));\n    case \"enum\":\n      return enumOutputStrategy(enumValues);\n    case \"no-schema\":\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n\n// src/generate-object/parse-and-validate-object-result.ts\nimport { JSONParseError as JSONParseError2, TypeValidationError as TypeValidationError3 } from \"@ai-sdk/provider\";\nimport { safeParseJSON as safeParseJSON3 } from \"@ai-sdk/provider-utils\";\nasync function parseAndValidateObjectResult(result, outputStrategy, context) {\n  const parseResult = await safeParseJSON3({ text: result });\n  if (!parseResult.success) {\n    throw new NoObjectGeneratedError({\n      message: \"No object generated: could not parse the response.\",\n      cause: parseResult.error,\n      text: result,\n      response: context.response,\n      usage: context.usage,\n      finishReason: context.finishReason\n    });\n  }\n  const validationResult = await outputStrategy.validateFinalResult(\n    parseResult.value,\n    {\n      text: result,\n      response: context.response,\n      usage: context.usage\n    }\n  );\n  if (!validationResult.success) {\n    throw new NoObjectGeneratedError({\n      message: \"No object generated: response did not match schema.\",\n      cause: validationResult.error,\n      text: result,\n      response: context.response,\n      usage: context.usage,\n      finishReason: context.finishReason\n    });\n  }\n  return validationResult.value;\n}\nasync function parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, context) {\n  try {\n    return await parseAndValidateObjectResult(result, outputStrategy, context);\n  } catch (error) {\n    if (repairText != null && NoObjectGeneratedError.isInstance(error) && (JSONParseError2.isInstance(error.cause) || TypeValidationError3.isInstance(error.cause))) {\n      const repairedText = await repairText({\n        text: result,\n        error: error.cause\n      });\n      if (repairedText === null) {\n        throw error;\n      }\n      return await parseAndValidateObjectResult(\n        repairedText,\n        outputStrategy,\n        context\n      );\n    }\n    throw error;\n  }\n}\n\n// src/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({\n  output,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues\n}) {\n  if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n    throw new InvalidArgumentError({\n      parameter: \"output\",\n      value: output,\n      message: \"Invalid output type.\"\n    });\n  }\n  if (output === \"no-schema\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for no-schema output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for no-schema output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for no-schema output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for no-schema output.\"\n      });\n    }\n  }\n  if (output === \"object\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is required for object output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for object output.\"\n      });\n    }\n  }\n  if (output === \"array\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Element schema is required for array output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for array output.\"\n      });\n    }\n  }\n  if (output === \"enum\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for enum output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for enum output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for enum output.\"\n      });\n    }\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are required for enum output.\"\n      });\n    }\n    for (const value of enumValues) {\n      if (typeof value !== \"string\") {\n        throw new InvalidArgumentError({\n          parameter: \"enumValues\",\n          value,\n          message: \"Enum values must be strings.\"\n        });\n      }\n    }\n  }\n}\n\n// src/generate-object/generate-object.ts\nvar originalGenerateId3 = createIdGenerator3({ prefix: \"aiobj\", size: 24 });\nasync function generateObject(options) {\n  const {\n    model: modelArg,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download2,\n    providerOptions,\n    _internal: {\n      generateId: generateId3 = originalGenerateId3,\n      currentDate = () => /* @__PURE__ */ new Date()\n    } = {},\n    ...settings\n  } = options;\n  const model = resolveLanguageModel(modelArg);\n  const enumValues = \"enum\" in options ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  const callSettings = prepareCallSettings(settings);\n  const headersWithUserAgent = withUserAgentSuffix6(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { ...callSettings, maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  try {\n    return await recordSpan({\n      name: \"ai.generateObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.generateObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type\n        }\n      }),\n      tracer,\n      fn: async (span) => {\n        var _a16;\n        let result;\n        let finishReason;\n        let usage;\n        let warnings;\n        let response;\n        let request;\n        let resultProviderMetadata;\n        let reasoning;\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: standardizedPrompt,\n          supportedUrls: await model.supportedUrls,\n          download: download2\n        });\n        const generateResult = await retry(\n          () => recordSpan({\n            name: \"ai.generateObject.doGenerate\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.generateObject.doGenerate\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(promptMessages)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                \"gen_ai.request.temperature\": callSettings.temperature,\n                \"gen_ai.request.top_k\": callSettings.topK,\n                \"gen_ai.request.top_p\": callSettings.topP\n              }\n            }),\n            tracer,\n            fn: async (span2) => {\n              var _a17, _b, _c, _d, _e, _f, _g, _h;\n              const result2 = await model.doGenerate({\n                responseFormat: {\n                  type: \"json\",\n                  schema: outputStrategy.jsonSchema,\n                  name: schemaName,\n                  description: schemaDescription\n                },\n                ...prepareCallSettings(settings),\n                prompt: promptMessages,\n                providerOptions,\n                abortSignal,\n                headers: headersWithUserAgent\n              });\n              const responseData = {\n                id: (_b = (_a17 = result2.response) == null ? void 0 : _a17.id) != null ? _b : generateId3(),\n                timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId,\n                headers: (_g = result2.response) == null ? void 0 : _g.headers,\n                body: (_h = result2.response) == null ? void 0 : _h.body\n              };\n              const text2 = extractTextContent(result2.content);\n              const reasoning2 = extractReasoningContent(result2.content);\n              if (text2 === void 0) {\n                throw new NoObjectGeneratedError({\n                  message: \"No object generated: the model did not return a response.\",\n                  response: responseData,\n                  usage: result2.usage,\n                  finishReason: result2.finishReason\n                });\n              }\n              span2.setAttributes(\n                selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.response.finishReason\": result2.finishReason,\n                    \"ai.response.object\": { output: () => text2 },\n                    \"ai.response.id\": responseData.id,\n                    \"ai.response.model\": responseData.modelId,\n                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                    \"ai.response.providerMetadata\": JSON.stringify(\n                      result2.providerMetadata\n                    ),\n                    // TODO rename telemetry attributes to inputTokens and outputTokens\n                    \"ai.usage.promptTokens\": result2.usage.inputTokens,\n                    \"ai.usage.completionTokens\": result2.usage.outputTokens,\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.response.finish_reasons\": [result2.finishReason],\n                    \"gen_ai.response.id\": responseData.id,\n                    \"gen_ai.response.model\": responseData.modelId,\n                    \"gen_ai.usage.input_tokens\": result2.usage.inputTokens,\n                    \"gen_ai.usage.output_tokens\": result2.usage.outputTokens\n                  }\n                })\n              );\n              return {\n                ...result2,\n                objectText: text2,\n                reasoning: reasoning2,\n                responseData\n              };\n            }\n          })\n        );\n        result = generateResult.objectText;\n        finishReason = generateResult.finishReason;\n        usage = generateResult.usage;\n        warnings = generateResult.warnings;\n        resultProviderMetadata = generateResult.providerMetadata;\n        request = (_a16 = generateResult.request) != null ? _a16 : {};\n        response = generateResult.responseData;\n        reasoning = generateResult.reasoning;\n        logWarnings(warnings);\n        const object2 = await parseAndValidateObjectResultWithRepair(\n          result,\n          outputStrategy,\n          repairText,\n          {\n            response,\n            usage,\n            finishReason\n          }\n        );\n        span.setAttributes(\n          selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.response.finishReason\": finishReason,\n              \"ai.response.object\": {\n                output: () => JSON.stringify(object2)\n              },\n              \"ai.response.providerMetadata\": JSON.stringify(\n                resultProviderMetadata\n              ),\n              // TODO rename telemetry attributes to inputTokens and outputTokens\n              \"ai.usage.promptTokens\": usage.inputTokens,\n              \"ai.usage.completionTokens\": usage.outputTokens\n            }\n          })\n        );\n        return new DefaultGenerateObjectResult({\n          object: object2,\n          reasoning,\n          finishReason,\n          usage,\n          warnings,\n          request,\n          response,\n          providerMetadata: resultProviderMetadata\n        });\n      }\n    });\n  } catch (error) {\n    throw wrapGatewayError(error);\n  }\n}\nvar DefaultGenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.reasoning = options.reasoning;\n  }\n  toJsonResponse(init) {\n    var _a16;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a16 = init == null ? void 0 : init.status) != null ? _a16 : 200,\n      headers: prepareHeaders(init == null ? void 0 : init.headers, {\n        \"content-type\": \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// src/generate-object/stream-object.ts\nimport {\n  createIdGenerator as createIdGenerator4,\n  DelayedPromise as DelayedPromise2\n} from \"@ai-sdk/provider-utils\";\n\n// src/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n  if (vector1.length !== vector2.length) {\n    throw new InvalidArgumentError({\n      parameter: \"vector1,vector2\",\n      value: { vector1Length: vector1.length, vector2Length: vector2.length },\n      message: `Vectors must have the same length`\n    });\n  }\n  const n = vector1.length;\n  if (n === 0) {\n    return 0;\n  }\n  let magnitudeSquared1 = 0;\n  let magnitudeSquared2 = 0;\n  let dotProduct = 0;\n  for (let i = 0; i < n; i++) {\n    const value1 = vector1[i];\n    const value2 = vector2[i];\n    magnitudeSquared1 += value1 * value1;\n    magnitudeSquared2 += value2 * value2;\n    dotProduct += value1 * value2;\n  }\n  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0 ? 0 : dotProduct / (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n\n// src/util/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n  const [header, base64Content] = dataUrl.split(\",\");\n  const mediaType = header.split(\";\")[0].split(\":\")[1];\n  if (mediaType == null || base64Content == null) {\n    throw new Error(\"Invalid data URL format\");\n  }\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n\n// src/util/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// src/util/serial-job-executor.ts\nvar SerialJobExecutor = class {\n  constructor() {\n    this.queue = [];\n    this.isProcessing = false;\n  }\n  async processQueue() {\n    if (this.isProcessing) {\n      return;\n    }\n    this.isProcessing = true;\n    while (this.queue.length > 0) {\n      await this.queue[0]();\n      this.queue.shift();\n    }\n    this.isProcessing = false;\n  }\n  async run(job) {\n    return new Promise((resolve2, reject) => {\n      this.queue.push(async () => {\n        try {\n          await job();\n          resolve2();\n        } catch (error) {\n          reject(error);\n        }\n      });\n      void this.processQueue();\n    });\n  }\n};\n\n// src/util/simulate-readable-stream.ts\nimport { delay as delayFunction } from \"@ai-sdk/provider-utils\";\nfunction simulateReadableStream({\n  chunks,\n  initialDelayInMs = 0,\n  chunkDelayInMs = 0,\n  _internal\n}) {\n  var _a16;\n  const delay2 = (_a16 = _internal == null ? void 0 : _internal.delay) != null ? _a16 : delayFunction;\n  let index = 0;\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        await delay2(index === 0 ? initialDelayInMs : chunkDelayInMs);\n        controller.enqueue(chunks[index++]);\n      } else {\n        controller.close();\n      }\n    }\n  });\n}\n\n// src/generate-object/stream-object.ts\nvar originalGenerateId4 = createIdGenerator4({ prefix: \"aiobj\", size: 24 });\nfunction streamObject(options) {\n  const {\n    model,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download2,\n    providerOptions,\n    onError = ({ error }) => {\n      console.error(error);\n    },\n    onFinish,\n    _internal: {\n      generateId: generateId3 = originalGenerateId4,\n      currentDate = () => /* @__PURE__ */ new Date(),\n      now: now2 = now\n    } = {},\n    ...settings\n  } = options;\n  const enumValues = \"enum\" in options && options.enum ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    repairText,\n    onError,\n    onFinish,\n    download: download2,\n    generateId: generateId3,\n    currentDate,\n    now: now2\n  });\n}\nvar DefaultStreamObjectResult = class {\n  constructor({\n    model: modelArg,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    repairText,\n    onError,\n    onFinish,\n    download: download2,\n    generateId: generateId3,\n    currentDate,\n    now: now2\n  }) {\n    this._object = new DelayedPromise2();\n    this._usage = new DelayedPromise2();\n    this._providerMetadata = new DelayedPromise2();\n    this._warnings = new DelayedPromise2();\n    this._request = new DelayedPromise2();\n    this._response = new DelayedPromise2();\n    this._finishReason = new DelayedPromise2();\n    const model = resolveLanguageModel(modelArg);\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal\n    });\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries }\n    });\n    const tracer = getTracer(telemetry);\n    const self = this;\n    const stitchableStream = createStitchableStream();\n    const eventProcessor = new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"error\") {\n          onError({ error: wrapGatewayError(chunk.error) });\n        }\n      }\n    });\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n    recordSpan({\n      name: \"ai.streamObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.streamObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.schema\": outputStrategy.jsonSchema != null ? { input: () => JSON.stringify(outputStrategy.jsonSchema) } : void 0,\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpan) => {\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const callOptions = {\n          responseFormat: {\n            type: \"json\",\n            schema: outputStrategy.jsonSchema,\n            name: schemaName,\n            description: schemaDescription\n          },\n          ...prepareCallSettings(settings),\n          prompt: await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            supportedUrls: await model.supportedUrls,\n            download: download2\n          }),\n          providerOptions,\n          abortSignal,\n          headers,\n          includeRawChunks: false\n        };\n        const transformer = {\n          transform: (chunk, controller) => {\n            switch (chunk.type) {\n              case \"text-delta\":\n                controller.enqueue(chunk.delta);\n                break;\n              case \"response-metadata\":\n              case \"finish\":\n              case \"error\":\n              case \"stream-start\":\n                controller.enqueue(chunk);\n                break;\n            }\n          }\n        };\n        const {\n          result: { stream, response, request },\n          doStreamSpan,\n          startTimestampMs\n        } = await retry(\n          () => recordSpan({\n            name: \"ai.streamObject.doStream\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.streamObject.doStream\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(callOptions.prompt)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                \"gen_ai.request.temperature\": callSettings.temperature,\n                \"gen_ai.request.top_k\": callSettings.topK,\n                \"gen_ai.request.top_p\": callSettings.topP\n              }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (doStreamSpan2) => ({\n              startTimestampMs: now2(),\n              doStreamSpan: doStreamSpan2,\n              result: await model.doStream(callOptions)\n            })\n          })\n        );\n        self._request.resolve(request != null ? request : {});\n        let warnings;\n        let usage = {\n          inputTokens: void 0,\n          outputTokens: void 0,\n          totalTokens: void 0\n        };\n        let finishReason;\n        let providerMetadata;\n        let object2;\n        let error;\n        let accumulatedText = \"\";\n        let textDelta = \"\";\n        let fullResponse = {\n          id: generateId3(),\n          timestamp: currentDate(),\n          modelId: model.modelId\n        };\n        let latestObjectJson = void 0;\n        let latestObject = void 0;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n        const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(\n          new TransformStream({\n            async transform(chunk, controller) {\n              var _a16, _b, _c;\n              if (typeof chunk === \"object\" && chunk.type === \"stream-start\") {\n                warnings = chunk.warnings;\n                return;\n              }\n              if (isFirstChunk) {\n                const msToFirstChunk = now2() - startTimestampMs;\n                isFirstChunk = false;\n                doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n                doStreamSpan.setAttributes({\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n              }\n              if (typeof chunk === \"string\") {\n                accumulatedText += chunk;\n                textDelta += chunk;\n                const { value: currentObjectJson, state: parseState } = await parsePartialJson(accumulatedText);\n                if (currentObjectJson !== void 0 && !isDeepEqualData(latestObjectJson, currentObjectJson)) {\n                  const validationResult = await outputStrategy.validatePartialResult({\n                    value: currentObjectJson,\n                    textDelta,\n                    latestObject,\n                    isFirstDelta,\n                    isFinalDelta: parseState === \"successful-parse\"\n                  });\n                  if (validationResult.success && !isDeepEqualData(\n                    latestObject,\n                    validationResult.value.partial\n                  )) {\n                    latestObjectJson = currentObjectJson;\n                    latestObject = validationResult.value.partial;\n                    controller.enqueue({\n                      type: \"object\",\n                      object: latestObject\n                    });\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      textDelta: validationResult.value.textDelta\n                    });\n                    textDelta = \"\";\n                    isFirstDelta = false;\n                  }\n                }\n                return;\n              }\n              switch (chunk.type) {\n                case \"response-metadata\": {\n                  fullResponse = {\n                    id: (_a16 = chunk.id) != null ? _a16 : fullResponse.id,\n                    timestamp: (_b = chunk.timestamp) != null ? _b : fullResponse.timestamp,\n                    modelId: (_c = chunk.modelId) != null ? _c : fullResponse.modelId\n                  };\n                  break;\n                }\n                case \"finish\": {\n                  if (textDelta !== \"\") {\n                    controller.enqueue({ type: \"text-delta\", textDelta });\n                  }\n                  finishReason = chunk.finishReason;\n                  usage = chunk.usage;\n                  providerMetadata = chunk.providerMetadata;\n                  controller.enqueue({\n                    ...chunk,\n                    usage,\n                    response: fullResponse\n                  });\n                  logWarnings(warnings != null ? warnings : []);\n                  self._usage.resolve(usage);\n                  self._providerMetadata.resolve(providerMetadata);\n                  self._warnings.resolve(warnings);\n                  self._response.resolve({\n                    ...fullResponse,\n                    headers: response == null ? void 0 : response.headers\n                  });\n                  self._finishReason.resolve(finishReason != null ? finishReason : \"unknown\");\n                  try {\n                    object2 = await parseAndValidateObjectResultWithRepair(\n                      accumulatedText,\n                      outputStrategy,\n                      repairText,\n                      {\n                        response: fullResponse,\n                        usage,\n                        finishReason\n                      }\n                    );\n                    self._object.resolve(object2);\n                  } catch (e) {\n                    error = e;\n                    self._object.reject(e);\n                  }\n                  break;\n                }\n                default: {\n                  controller.enqueue(chunk);\n                  break;\n                }\n              }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush(controller) {\n              try {\n                const finalUsage = usage != null ? usage : {\n                  promptTokens: NaN,\n                  completionTokens: NaN,\n                  totalTokens: NaN\n                };\n                doStreamSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": finishReason,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      },\n                      \"ai.response.id\": fullResponse.id,\n                      \"ai.response.model\": fullResponse.modelId,\n                      \"ai.response.timestamp\": fullResponse.timestamp.toISOString(),\n                      \"ai.response.providerMetadata\": JSON.stringify(providerMetadata),\n                      \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                      \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                      \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                      \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                      \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [finishReason],\n                      \"gen_ai.response.id\": fullResponse.id,\n                      \"gen_ai.response.model\": fullResponse.modelId,\n                      \"gen_ai.usage.input_tokens\": finalUsage.inputTokens,\n                      \"gen_ai.usage.output_tokens\": finalUsage.outputTokens\n                    }\n                  })\n                );\n                doStreamSpan.end();\n                rootSpan.setAttributes(\n                  selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                      \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                      \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                      \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                      \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      },\n                      \"ai.response.providerMetadata\": JSON.stringify(providerMetadata)\n                    }\n                  })\n                );\n                await (onFinish == null ? void 0 : onFinish({\n                  usage: finalUsage,\n                  object: object2,\n                  error,\n                  response: {\n                    ...fullResponse,\n                    headers: response == null ? void 0 : response.headers\n                  },\n                  warnings,\n                  providerMetadata\n                }));\n              } catch (error2) {\n                controller.enqueue({ type: \"error\", error: error2 });\n              } finally {\n                rootSpan.end();\n              }\n            }\n          })\n        );\n        stitchableStream.addStream(transformedStream);\n      }\n    }).catch((error) => {\n      stitchableStream.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n    }).finally(() => {\n      stitchableStream.close();\n    });\n    this.outputStrategy = outputStrategy;\n  }\n  get object() {\n    return this._object.promise;\n  }\n  get usage() {\n    return this._usage.promise;\n  }\n  get providerMetadata() {\n    return this._providerMetadata.promise;\n  }\n  get warnings() {\n    return this._warnings.promise;\n  }\n  get request() {\n    return this._request.promise;\n  }\n  get response() {\n    return this._response.promise;\n  }\n  get finishReason() {\n    return this._finishReason.promise;\n  }\n  get partialObjectStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"object\":\n                controller.enqueue(chunk.object);\n                break;\n              case \"text-delta\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get elementStream() {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"text-delta\":\n                controller.enqueue(chunk.textDelta);\n                break;\n              case \"object\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.baseStream);\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\n\n// src/generate-speech/generate-speech.ts\nimport { withUserAgentSuffix as withUserAgentSuffix7 } from \"@ai-sdk/provider-utils\";\n\n// src/generate-speech/generated-audio-file.ts\nvar DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {\n  constructor({\n    data,\n    mediaType\n  }) {\n    super({ data, mediaType });\n    let format = \"mp3\";\n    if (mediaType) {\n      const mediaTypeParts = mediaType.split(\"/\");\n      if (mediaTypeParts.length === 2) {\n        if (mediaType !== \"audio/mpeg\") {\n          format = mediaTypeParts[1];\n        }\n      }\n    }\n    if (!format) {\n      throw new Error(\n        \"Audio format must be provided or determinable from media type\"\n      );\n    }\n    this.format = format;\n  }\n};\n\n// src/generate-speech/generate-speech.ts\nasync function generateSpeech({\n  model,\n  text: text2,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  language,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a16;\n  if (model.specificationVersion !== \"v2\") {\n    throw new UnsupportedModelVersionError({\n      version: model.specificationVersion,\n      provider: model.provider,\n      modelId: model.modelId\n    });\n  }\n  const headersWithUserAgent = withUserAgentSuffix7(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const result = await retry(\n    () => model.doGenerate({\n      text: text2,\n      voice,\n      outputFormat,\n      instructions,\n      speed,\n      language,\n      abortSignal,\n      headers: headersWithUserAgent,\n      providerOptions\n    })\n  );\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({ responses: [result.response] });\n  }\n  logWarnings(result.warnings);\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mediaType: (_a16 = detectMediaType({\n        data: result.audio,\n        signatures: audioMediaTypeSignatures\n      })) != null ? _a16 : \"audio/mp3\"\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultSpeechResult = class {\n  constructor(options) {\n    var _a16;\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a16 = options.providerMetadata) != null ? _a16 : {};\n  }\n};\n\n// src/generate-text/output.ts\nvar output_exports = {};\n__export(output_exports, {\n  object: () => object,\n  text: () => text\n});\nimport {\n  asSchema as asSchema4,\n  safeParseJSON as safeParseJSON4,\n  safeValidateTypes as safeValidateTypes4\n} from \"@ai-sdk/provider-utils\";\nvar text = () => ({\n  type: \"text\",\n  responseFormat: { type: \"text\" },\n  async parsePartial({ text: text2 }) {\n    return { partial: text2 };\n  },\n  async parseOutput({ text: text2 }) {\n    return text2;\n  }\n});\nvar object = ({\n  schema: inputSchema\n}) => {\n  const schema = asSchema4(inputSchema);\n  return {\n    type: \"object\",\n    responseFormat: {\n      type: \"json\",\n      schema: schema.jsonSchema\n    },\n    async parsePartial({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\":\n          return void 0;\n        case \"repaired-parse\":\n        case \"successful-parse\":\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value\n          };\n        default: {\n          const _exhaustiveCheck = result.state;\n          throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    async parseOutput({ text: text2 }, context) {\n      const parseResult = await safeParseJSON4({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      const validationResult = await safeValidateTypes4({\n        value: parseResult.value,\n        schema\n      });\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: response did not match schema.\",\n          cause: validationResult.error,\n          text: text2,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason\n        });\n      }\n      return validationResult.value;\n    }\n  };\n};\n\n// src/generate-text/prune-messages.ts\nfunction pruneMessages({\n  messages,\n  reasoning = \"none\",\n  toolCalls = [],\n  emptyMessages = \"remove\"\n}) {\n  if (reasoning === \"all\" || reasoning === \"before-last-message\") {\n    messages = messages.map((message, messageIndex) => {\n      if (message.role !== \"assistant\" || typeof message.content === \"string\" || reasoning === \"before-last-message\" && messageIndex === messages.length - 1) {\n        return message;\n      }\n      return {\n        ...message,\n        content: message.content.filter((part) => part.type !== \"reasoning\")\n      };\n    });\n  }\n  if (toolCalls === \"none\") {\n    toolCalls = [];\n  } else if (toolCalls === \"all\") {\n    toolCalls = [{ type: \"all\" }];\n  } else if (toolCalls === \"before-last-message\") {\n    toolCalls = [{ type: \"before-last-message\" }];\n  } else if (typeof toolCalls === \"string\") {\n    toolCalls = [{ type: toolCalls }];\n  }\n  for (const toolCall of toolCalls) {\n    const keepLastMessagesCount = toolCall.type === \"all\" ? void 0 : toolCall.type === \"before-last-message\" ? 1 : Number(\n      toolCall.type.slice(\"before-last-\".length).slice(0, -\"-messages\".length)\n    );\n    const keptToolCallIds = /* @__PURE__ */ new Set();\n    const keptApprovalIds = /* @__PURE__ */ new Set();\n    if (keepLastMessagesCount != null) {\n      for (const message of messages.slice(-keepLastMessagesCount)) {\n        if ((message.role === \"assistant\" || message.role === \"tool\") && typeof message.content !== \"string\") {\n          for (const part of message.content) {\n            if (part.type === \"tool-call\" || part.type === \"tool-result\") {\n              keptToolCallIds.add(part.toolCallId);\n            }\n          }\n        }\n      }\n    }\n    messages = messages.map((message, messageIndex) => {\n      if (message.role !== \"assistant\" && message.role !== \"tool\" || typeof message.content === \"string\" || keepLastMessagesCount && messageIndex >= messages.length - keepLastMessagesCount) {\n        return message;\n      }\n      const toolCallIdToToolName = {};\n      return {\n        ...message,\n        content: message.content.filter((part) => {\n          if (part.type !== \"tool-call\" && part.type !== \"tool-result\") {\n            return true;\n          }\n          if (part.type === \"tool-call\") {\n            toolCallIdToToolName[part.toolCallId] = part.toolName;\n          }\n          if ((part.type === \"tool-call\" || part.type === \"tool-result\") && keptToolCallIds.has(part.toolCallId)) {\n            return true;\n          }\n          return toolCall.tools != null && !toolCall.tools.includes(part.toolName);\n        })\n      };\n    });\n  }\n  if (emptyMessages === \"remove\") {\n    messages = messages.filter((message) => message.content.length > 0);\n  }\n  return messages;\n}\n\n// src/generate-text/smooth-stream.ts\nimport { delay as originalDelay } from \"@ai-sdk/provider-utils\";\nimport { InvalidArgumentError as InvalidArgumentError2 } from \"@ai-sdk/provider\";\nvar CHUNKING_REGEXPS = {\n  word: /\\S+\\s+/m,\n  line: /\\n+/m\n};\nfunction smoothStream({\n  delayInMs = 10,\n  chunking = \"word\",\n  _internal: { delay: delay2 = originalDelay } = {}\n} = {}) {\n  let detectChunk;\n  if (typeof chunking === \"function\") {\n    detectChunk = (buffer) => {\n      const match = chunking(buffer);\n      if (match == null) {\n        return null;\n      }\n      if (!match.length) {\n        throw new Error(`Chunking function must return a non-empty string.`);\n      }\n      if (!buffer.startsWith(match)) {\n        throw new Error(\n          `Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`\n        );\n      }\n      return match;\n    };\n  } else {\n    const chunkingRegex = typeof chunking === \"string\" ? CHUNKING_REGEXPS[chunking] : chunking;\n    if (chunkingRegex == null) {\n      throw new InvalidArgumentError2({\n        argument: \"chunking\",\n        message: `Chunking must be \"word\" or \"line\" or a RegExp. Received: ${chunking}`\n      });\n    }\n    detectChunk = (buffer) => {\n      const match = chunkingRegex.exec(buffer);\n      if (!match) {\n        return null;\n      }\n      return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);\n    };\n  }\n  return () => {\n    let buffer = \"\";\n    let id = \"\";\n    return new TransformStream({\n      async transform(chunk, controller) {\n        if (chunk.type !== \"text-delta\") {\n          if (buffer.length > 0) {\n            controller.enqueue({ type: \"text-delta\", text: buffer, id });\n            buffer = \"\";\n          }\n          controller.enqueue(chunk);\n          return;\n        }\n        if (chunk.id !== id && buffer.length > 0) {\n          controller.enqueue({ type: \"text-delta\", text: buffer, id });\n          buffer = \"\";\n        }\n        buffer += chunk.text;\n        id = chunk.id;\n        let match;\n        while ((match = detectChunk(buffer)) != null) {\n          controller.enqueue({ type: \"text-delta\", text: match, id });\n          buffer = buffer.slice(match.length);\n          await delay2(delayInMs);\n        }\n      }\n    });\n  };\n}\n\n// src/middleware/default-settings-middleware.ts\nfunction defaultSettingsMiddleware({\n  settings\n}) {\n  return {\n    middlewareVersion: \"v2\",\n    transformParams: async ({ params }) => {\n      return mergeObjects(settings, params);\n    }\n  };\n}\n\n// src/util/get-potential-start-index.ts\nfunction getPotentialStartIndex(text2, searchedText) {\n  if (searchedText.length === 0) {\n    return null;\n  }\n  const directIndex = text2.indexOf(searchedText);\n  if (directIndex !== -1) {\n    return directIndex;\n  }\n  for (let i = text2.length - 1; i >= 0; i--) {\n    const suffix = text2.substring(i);\n    if (searchedText.startsWith(suffix)) {\n      return i;\n    }\n  }\n  return null;\n}\n\n// src/middleware/extract-reasoning-middleware.ts\nfunction extractReasoningMiddleware({\n  tagName,\n  separator = \"\\n\",\n  startWithReasoning = false\n}) {\n  const openingTag = `<${tagName}>`;\n  const closingTag = `</${tagName}>`;\n  return {\n    middlewareVersion: \"v2\",\n    wrapGenerate: async ({ doGenerate }) => {\n      const { content, ...rest } = await doGenerate();\n      const transformedContent = [];\n      for (const part of content) {\n        if (part.type !== \"text\") {\n          transformedContent.push(part);\n          continue;\n        }\n        const text2 = startWithReasoning ? openingTag + part.text : part.text;\n        const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, \"gs\");\n        const matches = Array.from(text2.matchAll(regexp));\n        if (!matches.length) {\n          transformedContent.push(part);\n          continue;\n        }\n        const reasoningText = matches.map((match) => match[1]).join(separator);\n        let textWithoutReasoning = text2;\n        for (let i = matches.length - 1; i >= 0; i--) {\n          const match = matches[i];\n          const beforeMatch = textWithoutReasoning.slice(0, match.index);\n          const afterMatch = textWithoutReasoning.slice(\n            match.index + match[0].length\n          );\n          textWithoutReasoning = beforeMatch + (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : \"\") + afterMatch;\n        }\n        transformedContent.push({\n          type: \"reasoning\",\n          text: reasoningText\n        });\n        transformedContent.push({\n          type: \"text\",\n          text: textWithoutReasoning\n        });\n      }\n      return { content: transformedContent, ...rest };\n    },\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n      const reasoningExtractions = {};\n      let delayedTextStart;\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream({\n            transform: (chunk, controller) => {\n              if (chunk.type === \"text-start\") {\n                delayedTextStart = chunk;\n                return;\n              }\n              if (chunk.type === \"text-end\" && delayedTextStart) {\n                controller.enqueue(delayedTextStart);\n                delayedTextStart = void 0;\n              }\n              if (chunk.type !== \"text-delta\") {\n                controller.enqueue(chunk);\n                return;\n              }\n              if (reasoningExtractions[chunk.id] == null) {\n                reasoningExtractions[chunk.id] = {\n                  isFirstReasoning: true,\n                  isFirstText: true,\n                  afterSwitch: false,\n                  isReasoning: startWithReasoning,\n                  buffer: \"\",\n                  idCounter: 0,\n                  textId: chunk.id\n                };\n              }\n              const activeExtraction = reasoningExtractions[chunk.id];\n              activeExtraction.buffer += chunk.delta;\n              function publish(text2) {\n                if (text2.length > 0) {\n                  const prefix = activeExtraction.afterSwitch && (activeExtraction.isReasoning ? !activeExtraction.isFirstReasoning : !activeExtraction.isFirstText) ? separator : \"\";\n                  if (activeExtraction.isReasoning && (activeExtraction.afterSwitch || activeExtraction.isFirstReasoning)) {\n                    controller.enqueue({\n                      type: \"reasoning-start\",\n                      id: `reasoning-${activeExtraction.idCounter}`\n                    });\n                  }\n                  if (activeExtraction.isReasoning) {\n                    controller.enqueue({\n                      type: \"reasoning-delta\",\n                      delta: prefix + text2,\n                      id: `reasoning-${activeExtraction.idCounter}`\n                    });\n                  } else {\n                    if (delayedTextStart) {\n                      controller.enqueue(delayedTextStart);\n                      delayedTextStart = void 0;\n                    }\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      delta: prefix + text2,\n                      id: activeExtraction.textId\n                    });\n                  }\n                  activeExtraction.afterSwitch = false;\n                  if (activeExtraction.isReasoning) {\n                    activeExtraction.isFirstReasoning = false;\n                  } else {\n                    activeExtraction.isFirstText = false;\n                  }\n                }\n              }\n              do {\n                const nextTag = activeExtraction.isReasoning ? closingTag : openingTag;\n                const startIndex = getPotentialStartIndex(\n                  activeExtraction.buffer,\n                  nextTag\n                );\n                if (startIndex == null) {\n                  publish(activeExtraction.buffer);\n                  activeExtraction.buffer = \"\";\n                  break;\n                }\n                publish(activeExtraction.buffer.slice(0, startIndex));\n                const foundFullMatch = startIndex + nextTag.length <= activeExtraction.buffer.length;\n                if (foundFullMatch) {\n                  activeExtraction.buffer = activeExtraction.buffer.slice(\n                    startIndex + nextTag.length\n                  );\n                  if (activeExtraction.isReasoning) {\n                    controller.enqueue({\n                      type: \"reasoning-end\",\n                      id: `reasoning-${activeExtraction.idCounter++}`\n                    });\n                  }\n                  activeExtraction.isReasoning = !activeExtraction.isReasoning;\n                  activeExtraction.afterSwitch = true;\n                } else {\n                  activeExtraction.buffer = activeExtraction.buffer.slice(startIndex);\n                  break;\n                }\n              } while (true);\n            }\n          })\n        ),\n        ...rest\n      };\n    }\n  };\n}\n\n// src/middleware/simulate-streaming-middleware.ts\nfunction simulateStreamingMiddleware() {\n  return {\n    middlewareVersion: \"v2\",\n    wrapStream: async ({ doGenerate }) => {\n      const result = await doGenerate();\n      let id = 0;\n      const simulatedStream = new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"stream-start\",\n            warnings: result.warnings\n          });\n          controller.enqueue({ type: \"response-metadata\", ...result.response });\n          for (const part of result.content) {\n            switch (part.type) {\n              case \"text\": {\n                if (part.text.length > 0) {\n                  controller.enqueue({ type: \"text-start\", id: String(id) });\n                  controller.enqueue({\n                    type: \"text-delta\",\n                    id: String(id),\n                    delta: part.text\n                  });\n                  controller.enqueue({ type: \"text-end\", id: String(id) });\n                  id++;\n                }\n                break;\n              }\n              case \"reasoning\": {\n                controller.enqueue({\n                  type: \"reasoning-start\",\n                  id: String(id),\n                  providerMetadata: part.providerMetadata\n                });\n                controller.enqueue({\n                  type: \"reasoning-delta\",\n                  id: String(id),\n                  delta: part.text\n                });\n                controller.enqueue({ type: \"reasoning-end\", id: String(id) });\n                id++;\n                break;\n              }\n              default: {\n                controller.enqueue(part);\n                break;\n              }\n            }\n          }\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: result.finishReason,\n            usage: result.usage,\n            providerMetadata: result.providerMetadata\n          });\n          controller.close();\n        }\n      });\n      return {\n        stream: simulatedStream,\n        request: result.request,\n        response: result.response\n      };\n    }\n  };\n}\n\n// src/middleware/wrap-language-model.ts\nvar wrapLanguageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId\n}) => {\n  return [...asArray(middlewareArg)].reverse().reduce((wrappedModel, middleware) => {\n    return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n  }, model);\n};\nvar doWrap = ({\n  model,\n  middleware: {\n    transformParams,\n    wrapGenerate,\n    wrapStream,\n    overrideProvider,\n    overrideModelId,\n    overrideSupportedUrls\n  },\n  modelId,\n  providerId\n}) => {\n  var _a16, _b, _c;\n  async function doTransform({\n    params,\n    type\n  }) {\n    return transformParams ? await transformParams({ params, type, model }) : params;\n  }\n  return {\n    specificationVersion: \"v2\",\n    provider: (_a16 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({ model })) != null ? _a16 : model.provider,\n    modelId: (_b = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({ model })) != null ? _b : model.modelId,\n    supportedUrls: (_c = overrideSupportedUrls == null ? void 0 : overrideSupportedUrls({ model })) != null ? _c : model.supportedUrls,\n    async doGenerate(params) {\n      const transformedParams = await doTransform({ params, type: \"generate\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapGenerate ? wrapGenerate({\n        doGenerate,\n        doStream,\n        params: transformedParams,\n        model\n      }) : doGenerate();\n    },\n    async doStream(params) {\n      const transformedParams = await doTransform({ params, type: \"stream\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream ? wrapStream({ doGenerate, doStream, params: transformedParams, model }) : doStream();\n    }\n  };\n};\n\n// src/middleware/wrap-provider.ts\nfunction wrapProvider({\n  provider,\n  languageModelMiddleware\n}) {\n  const wrappedProvider = {\n    languageModel(modelId) {\n      let model = provider.languageModel(modelId);\n      model = wrapLanguageModel({\n        model,\n        middleware: languageModelMiddleware\n      });\n      return model;\n    },\n    textEmbeddingModel: provider.textEmbeddingModel,\n    imageModel: provider.imageModel,\n    transcriptionModel: provider.transcriptionModel,\n    speechModel: provider.speechModel\n  };\n  return wrappedProvider;\n}\n\n// src/registry/custom-provider.ts\nimport {\n  NoSuchModelError as NoSuchModelError2\n} from \"@ai-sdk/provider\";\nfunction customProvider({\n  languageModels,\n  textEmbeddingModels,\n  imageModels,\n  transcriptionModels,\n  speechModels,\n  fallbackProvider\n}) {\n  return {\n    languageModel(modelId) {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n      throw new NoSuchModelError2({ modelId, modelType: \"languageModel\" });\n    },\n    textEmbeddingModel(modelId) {\n      if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n        return textEmbeddingModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.textEmbeddingModel(modelId);\n      }\n      throw new NoSuchModelError2({ modelId, modelType: \"textEmbeddingModel\" });\n    },\n    imageModel(modelId) {\n      if (imageModels != null && modelId in imageModels) {\n        return imageModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.imageModel) {\n        return fallbackProvider.imageModel(modelId);\n      }\n      throw new NoSuchModelError2({ modelId, modelType: \"imageModel\" });\n    },\n    transcriptionModel(modelId) {\n      if (transcriptionModels != null && modelId in transcriptionModels) {\n        return transcriptionModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.transcriptionModel) {\n        return fallbackProvider.transcriptionModel(modelId);\n      }\n      throw new NoSuchModelError2({ modelId, modelType: \"transcriptionModel\" });\n    },\n    speechModel(modelId) {\n      if (speechModels != null && modelId in speechModels) {\n        return speechModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.speechModel) {\n        return fallbackProvider.speechModel(modelId);\n      }\n      throw new NoSuchModelError2({ modelId, modelType: \"speechModel\" });\n    }\n  };\n}\nvar experimental_customProvider = customProvider;\n\n// src/registry/no-such-provider-error.ts\nimport { AISDKError as AISDKError20, NoSuchModelError as NoSuchModelError3 } from \"@ai-sdk/provider\";\nvar name15 = \"AI_NoSuchProviderError\";\nvar marker15 = `vercel.ai.error.${name15}`;\nvar symbol15 = Symbol.for(marker15);\nvar _a15;\nvar NoSuchProviderError = class extends NoSuchModelError3 {\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`\n  }) {\n    super({ errorName: name15, modelId, modelType, message });\n    this[_a15] = true;\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n  static isInstance(error) {\n    return AISDKError20.hasMarker(error, marker15);\n  }\n};\n_a15 = symbol15;\n\n// src/registry/provider-registry.ts\nimport {\n  NoSuchModelError as NoSuchModelError4\n} from \"@ai-sdk/provider\";\nfunction createProviderRegistry(providers, {\n  separator = \":\",\n  languageModelMiddleware\n} = {}) {\n  const registry = new DefaultProviderRegistry({\n    separator,\n    languageModelMiddleware\n  });\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n  return registry;\n}\nvar experimental_createProviderRegistry = createProviderRegistry;\nvar DefaultProviderRegistry = class {\n  constructor({\n    separator,\n    languageModelMiddleware\n  }) {\n    this.providers = {};\n    this.separator = separator;\n    this.languageModelMiddleware = languageModelMiddleware;\n  }\n  registerProvider({\n    id,\n    provider\n  }) {\n    this.providers[id] = provider;\n  }\n  getProvider(id, modelType) {\n    const provider = this.providers[id];\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType,\n        providerId: id,\n        availableProviders: Object.keys(this.providers)\n      });\n    }\n    return provider;\n  }\n  splitId(id, modelType) {\n    const index = id.indexOf(this.separator);\n    if (index === -1) {\n      throw new NoSuchModelError4({\n        modelId: id,\n        modelType,\n        message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId${this.separator}modelId\")`\n      });\n    }\n    return [id.slice(0, index), id.slice(index + this.separator.length)];\n  }\n  languageModel(id) {\n    var _a16, _b;\n    const [providerId, modelId] = this.splitId(id, \"languageModel\");\n    let model = (_b = (_a16 = this.getProvider(providerId, \"languageModel\")).languageModel) == null ? void 0 : _b.call(\n      _a16,\n      modelId\n    );\n    if (model == null) {\n      throw new NoSuchModelError4({ modelId: id, modelType: \"languageModel\" });\n    }\n    if (this.languageModelMiddleware != null) {\n      model = wrapLanguageModel({\n        model,\n        middleware: this.languageModelMiddleware\n      });\n    }\n    return model;\n  }\n  textEmbeddingModel(id) {\n    var _a16;\n    const [providerId, modelId] = this.splitId(id, \"textEmbeddingModel\");\n    const provider = this.getProvider(providerId, \"textEmbeddingModel\");\n    const model = (_a16 = provider.textEmbeddingModel) == null ? void 0 : _a16.call(provider, modelId);\n    if (model == null) {\n      throw new NoSuchModelError4({\n        modelId: id,\n        modelType: \"textEmbeddingModel\"\n      });\n    }\n    return model;\n  }\n  imageModel(id) {\n    var _a16;\n    const [providerId, modelId] = this.splitId(id, \"imageModel\");\n    const provider = this.getProvider(providerId, \"imageModel\");\n    const model = (_a16 = provider.imageModel) == null ? void 0 : _a16.call(provider, modelId);\n    if (model == null) {\n      throw new NoSuchModelError4({ modelId: id, modelType: \"imageModel\" });\n    }\n    return model;\n  }\n  transcriptionModel(id) {\n    var _a16;\n    const [providerId, modelId] = this.splitId(id, \"transcriptionModel\");\n    const provider = this.getProvider(providerId, \"transcriptionModel\");\n    const model = (_a16 = provider.transcriptionModel) == null ? void 0 : _a16.call(provider, modelId);\n    if (model == null) {\n      throw new NoSuchModelError4({\n        modelId: id,\n        modelType: \"transcriptionModel\"\n      });\n    }\n    return model;\n  }\n  speechModel(id) {\n    var _a16;\n    const [providerId, modelId] = this.splitId(id, \"speechModel\");\n    const provider = this.getProvider(providerId, \"speechModel\");\n    const model = (_a16 = provider.speechModel) == null ? void 0 : _a16.call(provider, modelId);\n    if (model == null) {\n      throw new NoSuchModelError4({ modelId: id, modelType: \"speechModel\" });\n    }\n    return model;\n  }\n};\n\n// src/transcribe/transcribe.ts\nimport { withUserAgentSuffix as withUserAgentSuffix8 } from \"@ai-sdk/provider-utils\";\n\n// src/error/no-transcript-generated-error.ts\nimport { AISDKError as AISDKError21 } from \"@ai-sdk/provider\";\nvar NoTranscriptGeneratedError = class extends AISDKError21 {\n  constructor(options) {\n    super({\n      name: \"AI_NoTranscriptGeneratedError\",\n      message: \"No transcript generated.\"\n    });\n    this.responses = options.responses;\n  }\n};\n\n// src/transcribe/transcribe.ts\nasync function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  if (model.specificationVersion !== \"v2\") {\n    throw new UnsupportedModelVersionError({\n      version: model.specificationVersion,\n      provider: model.provider,\n      modelId: model.modelId\n    });\n  }\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const headersWithUserAgent = withUserAgentSuffix8(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const audioData = audio instanceof URL ? (await download({ url: audio })).data : convertDataContentToUint8Array(audio);\n  const result = await retry(\n    () => {\n      var _a16;\n      return model.doGenerate({\n        audio: audioData,\n        abortSignal,\n        headers: headersWithUserAgent,\n        providerOptions,\n        mediaType: (_a16 = detectMediaType({\n          data: audioData,\n          signatures: audioMediaTypeSignatures\n        })) != null ? _a16 : \"audio/wav\"\n      });\n    }\n  );\n  logWarnings(result.warnings);\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({ responses: [result.response] });\n  }\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultTranscriptionResult = class {\n  constructor(options) {\n    var _a16;\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a16 = options.providerMetadata) != null ? _a16 : {};\n  }\n};\n\n// src/ui/call-completion-api.ts\nimport {\n  parseJsonEventStream,\n  withUserAgentSuffix as withUserAgentSuffix9,\n  getRuntimeEnvironmentUserAgent as getRuntimeEnvironmentUserAgent2\n} from \"@ai-sdk/provider-utils\";\n\n// src/ui/process-text-stream.ts\nasync function processTextStream({\n  stream,\n  onTextPart\n}) {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n\n// src/ui/call-completion-api.ts\nvar getOriginalFetch = () => fetch;\nasync function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onFinish,\n  onError,\n  fetch: fetch2 = getOriginalFetch()\n}) {\n  var _a16;\n  try {\n    setLoading(true);\n    setError(void 0);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const response = await fetch2(api, {\n      method: \"POST\",\n      body: JSON.stringify({\n        prompt,\n        ...body\n      }),\n      credentials,\n      headers: withUserAgentSuffix9(\n        {\n          \"Content-Type\": \"application/json\",\n          ...headers\n        },\n        `ai-sdk/${VERSION}`,\n        getRuntimeEnvironmentUserAgent2()\n      ),\n      signal: abortController.signal\n    }).catch((err) => {\n      throw err;\n    });\n    if (!response.ok) {\n      throw new Error(\n        (_a16 = await response.text()) != null ? _a16 : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    let result = \"\";\n    switch (streamProtocol) {\n      case \"text\": {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: (chunk) => {\n            result += chunk;\n            setCompletion(result);\n          }\n        });\n        break;\n      }\n      case \"data\": {\n        await consumeStream({\n          stream: parseJsonEventStream({\n            stream: response.body,\n            schema: uiMessageChunkSchema\n          }).pipeThrough(\n            new TransformStream({\n              async transform(part) {\n                if (!part.success) {\n                  throw part.error;\n                }\n                const streamPart = part.value;\n                if (streamPart.type === \"text-delta\") {\n                  result += streamPart.delta;\n                  setCompletion(result);\n                } else if (streamPart.type === \"error\") {\n                  throw new Error(streamPart.errorText);\n                }\n              }\n            })\n          ),\n          onError: (error) => {\n            throw error;\n          }\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    if (err.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/ui/chat.ts\nimport {\n  generateId as generateIdFunc\n} from \"@ai-sdk/provider-utils\";\n\n// src/ui/convert-file-list-to-file-ui-parts.ts\nasync function convertFileListToFileUIParts(files) {\n  if (files == null) {\n    return [];\n  }\n  if (!globalThis.FileList || !(files instanceof globalThis.FileList)) {\n    throw new Error(\"FileList is not supported in the current environment\");\n  }\n  return Promise.all(\n    Array.from(files).map(async (file) => {\n      const { name: name16, type } = file;\n      const dataUrl = await new Promise((resolve2, reject) => {\n        const reader = new FileReader();\n        reader.onload = (readerEvent) => {\n          var _a16;\n          resolve2((_a16 = readerEvent.target) == null ? void 0 : _a16.result);\n        };\n        reader.onerror = (error) => reject(error);\n        reader.readAsDataURL(file);\n      });\n      return {\n        type: \"file\",\n        mediaType: type,\n        filename: name16,\n        url: dataUrl\n      };\n    })\n  );\n}\n\n// src/ui/default-chat-transport.ts\nimport { parseJsonEventStream as parseJsonEventStream2 } from \"@ai-sdk/provider-utils\";\n\n// src/ui/http-chat-transport.ts\nimport {\n  normalizeHeaders,\n  resolve,\n  withUserAgentSuffix as withUserAgentSuffix10,\n  getRuntimeEnvironmentUserAgent as getRuntimeEnvironmentUserAgent3\n} from \"@ai-sdk/provider-utils\";\nvar HttpChatTransport = class {\n  constructor({\n    api = \"/api/chat\",\n    credentials,\n    headers,\n    body,\n    fetch: fetch2,\n    prepareSendMessagesRequest,\n    prepareReconnectToStreamRequest\n  }) {\n    this.api = api;\n    this.credentials = credentials;\n    this.headers = headers;\n    this.body = body;\n    this.fetch = fetch2;\n    this.prepareSendMessagesRequest = prepareSendMessagesRequest;\n    this.prepareReconnectToStreamRequest = prepareReconnectToStreamRequest;\n  }\n  async sendMessages({\n    abortSignal,\n    ...options\n  }) {\n    var _a16, _b, _c, _d, _e;\n    const resolvedBody = await resolve(this.body);\n    const resolvedHeaders = await resolve(this.headers);\n    const resolvedCredentials = await resolve(this.credentials);\n    const baseHeaders = {\n      ...normalizeHeaders(resolvedHeaders),\n      ...normalizeHeaders(options.headers)\n    };\n    const preparedRequest = await ((_a16 = this.prepareSendMessagesRequest) == null ? void 0 : _a16.call(this, {\n      api: this.api,\n      id: options.chatId,\n      messages: options.messages,\n      body: { ...resolvedBody, ...options.body },\n      headers: baseHeaders,\n      credentials: resolvedCredentials,\n      requestMetadata: options.metadata,\n      trigger: options.trigger,\n      messageId: options.messageId\n    }));\n    const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : this.api;\n    const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? normalizeHeaders(preparedRequest.headers) : baseHeaders;\n    const body = (preparedRequest == null ? void 0 : preparedRequest.body) !== void 0 ? preparedRequest.body : {\n      ...resolvedBody,\n      ...options.body,\n      id: options.chatId,\n      messages: options.messages,\n      trigger: options.trigger,\n      messageId: options.messageId\n    };\n    const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n    const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n    const response = await fetch2(api, {\n      method: \"POST\",\n      headers: withUserAgentSuffix10(\n        {\n          \"Content-Type\": \"application/json\",\n          ...headers\n        },\n        `ai-sdk/${VERSION}`,\n        getRuntimeEnvironmentUserAgent3()\n      ),\n      body: JSON.stringify(body),\n      credentials,\n      signal: abortSignal\n    });\n    if (!response.ok) {\n      throw new Error(\n        (_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    return this.processResponseStream(response.body);\n  }\n  async reconnectToStream(options) {\n    var _a16, _b, _c, _d, _e;\n    const resolvedBody = await resolve(this.body);\n    const resolvedHeaders = await resolve(this.headers);\n    const resolvedCredentials = await resolve(this.credentials);\n    const baseHeaders = {\n      ...normalizeHeaders(resolvedHeaders),\n      ...normalizeHeaders(options.headers)\n    };\n    const preparedRequest = await ((_a16 = this.prepareReconnectToStreamRequest) == null ? void 0 : _a16.call(this, {\n      api: this.api,\n      id: options.chatId,\n      body: { ...resolvedBody, ...options.body },\n      headers: baseHeaders,\n      credentials: resolvedCredentials,\n      requestMetadata: options.metadata\n    }));\n    const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : `${this.api}/${options.chatId}/stream`;\n    const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? normalizeHeaders(preparedRequest.headers) : baseHeaders;\n    const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n    const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n    const response = await fetch2(api, {\n      method: \"GET\",\n      headers: withUserAgentSuffix10(\n        headers,\n        `ai-sdk/${VERSION}`,\n        getRuntimeEnvironmentUserAgent3()\n      ),\n      credentials\n    });\n    if (response.status === 204) {\n      return null;\n    }\n    if (!response.ok) {\n      throw new Error(\n        (_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    return this.processResponseStream(response.body);\n  }\n};\n\n// src/ui/default-chat-transport.ts\nvar DefaultChatTransport = class extends HttpChatTransport {\n  constructor(options = {}) {\n    super(options);\n  }\n  processResponseStream(stream) {\n    return parseJsonEventStream2({\n      stream,\n      schema: uiMessageChunkSchema\n    }).pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          if (!chunk.success) {\n            throw chunk.error;\n          }\n          controller.enqueue(chunk.value);\n        }\n      })\n    );\n  }\n};\n\n// src/ui/chat.ts\nvar AbstractChat = class {\n  constructor({\n    generateId: generateId3 = generateIdFunc,\n    id = generateId3(),\n    transport = new DefaultChatTransport(),\n    messageMetadataSchema,\n    dataPartSchemas,\n    state,\n    onError,\n    onToolCall,\n    onFinish,\n    onData,\n    sendAutomaticallyWhen\n  }) {\n    this.activeResponse = void 0;\n    this.jobExecutor = new SerialJobExecutor();\n    /**\n     * Appends or replaces a user message to the chat list. This triggers the API call to fetch\n     * the assistant's response.\n     *\n     * If a messageId is provided, the message will be replaced.\n     */\n    this.sendMessage = async (message, options) => {\n      var _a16, _b, _c, _d;\n      if (message == null) {\n        await this.makeRequest({\n          trigger: \"submit-message\",\n          messageId: (_a16 = this.lastMessage) == null ? void 0 : _a16.id,\n          ...options\n        });\n        return;\n      }\n      let uiMessage;\n      if (\"text\" in message || \"files\" in message) {\n        const fileParts = Array.isArray(message.files) ? message.files : await convertFileListToFileUIParts(message.files);\n        uiMessage = {\n          parts: [\n            ...fileParts,\n            ...\"text\" in message && message.text != null ? [{ type: \"text\", text: message.text }] : []\n          ]\n        };\n      } else {\n        uiMessage = message;\n      }\n      if (message.messageId != null) {\n        const messageIndex = this.state.messages.findIndex(\n          (m) => m.id === message.messageId\n        );\n        if (messageIndex === -1) {\n          throw new Error(`message with id ${message.messageId} not found`);\n        }\n        if (this.state.messages[messageIndex].role !== \"user\") {\n          throw new Error(\n            `message with id ${message.messageId} is not a user message`\n          );\n        }\n        this.state.messages = this.state.messages.slice(0, messageIndex + 1);\n        this.state.replaceMessage(messageIndex, {\n          ...uiMessage,\n          id: message.messageId,\n          role: (_b = uiMessage.role) != null ? _b : \"user\",\n          metadata: message.metadata\n        });\n      } else {\n        this.state.pushMessage({\n          ...uiMessage,\n          id: (_c = uiMessage.id) != null ? _c : this.generateId(),\n          role: (_d = uiMessage.role) != null ? _d : \"user\",\n          metadata: message.metadata\n        });\n      }\n      await this.makeRequest({\n        trigger: \"submit-message\",\n        messageId: message.messageId,\n        ...options\n      });\n    };\n    /**\n     * Regenerate the assistant message with the provided message id.\n     * If no message id is provided, the last assistant message will be regenerated.\n     */\n    this.regenerate = async ({\n      messageId,\n      ...options\n    } = {}) => {\n      const messageIndex = messageId == null ? this.state.messages.length - 1 : this.state.messages.findIndex((message) => message.id === messageId);\n      if (messageIndex === -1) {\n        throw new Error(`message ${messageId} not found`);\n      }\n      this.state.messages = this.state.messages.slice(\n        0,\n        // if the message is a user message, we need to include it in the request:\n        this.messages[messageIndex].role === \"assistant\" ? messageIndex : messageIndex + 1\n      );\n      await this.makeRequest({\n        trigger: \"regenerate-message\",\n        messageId,\n        ...options\n      });\n    };\n    /**\n     * Attempt to resume an ongoing streaming response.\n     */\n    this.resumeStream = async (options = {}) => {\n      await this.makeRequest({ trigger: \"resume-stream\", ...options });\n    };\n    /**\n     * Clear the error state and set the status to ready if the chat is in an error state.\n     */\n    this.clearError = () => {\n      if (this.status === \"error\") {\n        this.state.error = void 0;\n        this.setStatus({ status: \"ready\" });\n      }\n    };\n    this.addToolOutput = async ({\n      state = \"output-available\",\n      tool: tool2,\n      toolCallId,\n      output,\n      errorText\n    }) => this.jobExecutor.run(async () => {\n      var _a16, _b;\n      const messages = this.state.messages;\n      const lastMessage = messages[messages.length - 1];\n      this.state.replaceMessage(messages.length - 1, {\n        ...lastMessage,\n        parts: lastMessage.parts.map(\n          (part) => isToolOrDynamicToolUIPart(part) && part.toolCallId === toolCallId ? { ...part, state, output, errorText } : part\n        )\n      });\n      if (this.activeResponse) {\n        this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(\n          (part) => isToolOrDynamicToolUIPart(part) && part.toolCallId === toolCallId ? {\n            ...part,\n            state,\n            output,\n            errorText\n          } : part\n        );\n      }\n      if (this.status !== \"streaming\" && this.status !== \"submitted\" && ((_a16 = this.sendAutomaticallyWhen) == null ? void 0 : _a16.call(this, { messages: this.state.messages }))) {\n        this.makeRequest({\n          trigger: \"submit-message\",\n          messageId: (_b = this.lastMessage) == null ? void 0 : _b.id\n        });\n      }\n    });\n    /** @deprecated Use addToolOutput */\n    this.addToolResult = this.addToolOutput;\n    /**\n     * Abort the current request immediately, keep the generated tokens if any.\n     */\n    this.stop = async () => {\n      var _a16;\n      if (this.status !== \"streaming\" && this.status !== \"submitted\")\n        return;\n      if ((_a16 = this.activeResponse) == null ? void 0 : _a16.abortController) {\n        this.activeResponse.abortController.abort();\n      }\n    };\n    this.id = id;\n    this.transport = transport;\n    this.generateId = generateId3;\n    this.messageMetadataSchema = messageMetadataSchema;\n    this.dataPartSchemas = dataPartSchemas;\n    this.state = state;\n    this.onError = onError;\n    this.onToolCall = onToolCall;\n    this.onFinish = onFinish;\n    this.onData = onData;\n    this.sendAutomaticallyWhen = sendAutomaticallyWhen;\n  }\n  /**\n   * Hook status:\n   *\n   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.\n   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.\n   * - `ready`: The full response has been received and processed; a new user message can be submitted.\n   * - `error`: An error occurred during the API request, preventing successful completion.\n   */\n  get status() {\n    return this.state.status;\n  }\n  setStatus({\n    status,\n    error\n  }) {\n    if (this.status === status)\n      return;\n    this.state.status = status;\n    this.state.error = error;\n  }\n  get error() {\n    return this.state.error;\n  }\n  get messages() {\n    return this.state.messages;\n  }\n  get lastMessage() {\n    return this.state.messages[this.state.messages.length - 1];\n  }\n  set messages(messages) {\n    this.state.messages = messages;\n  }\n  async makeRequest({\n    trigger,\n    metadata,\n    headers,\n    body,\n    messageId\n  }) {\n    var _a16, _b, _c, _d;\n    this.setStatus({ status: \"submitted\", error: void 0 });\n    const lastMessage = this.lastMessage;\n    let isAbort = false;\n    let isDisconnect = false;\n    let isError = false;\n    try {\n      const activeResponse = {\n        state: createStreamingUIMessageState({\n          lastMessage: this.state.snapshot(lastMessage),\n          messageId: this.generateId()\n        }),\n        abortController: new AbortController()\n      };\n      activeResponse.abortController.signal.addEventListener(\"abort\", () => {\n        isAbort = true;\n      });\n      this.activeResponse = activeResponse;\n      let stream;\n      if (trigger === \"resume-stream\") {\n        const reconnect = await this.transport.reconnectToStream({\n          chatId: this.id,\n          metadata,\n          headers,\n          body\n        });\n        if (reconnect == null) {\n          this.setStatus({ status: \"ready\" });\n          return;\n        }\n        stream = reconnect;\n      } else {\n        stream = await this.transport.sendMessages({\n          chatId: this.id,\n          messages: this.state.messages,\n          abortSignal: activeResponse.abortController.signal,\n          metadata,\n          headers,\n          body,\n          trigger,\n          messageId\n        });\n      }\n      const runUpdateMessageJob = (job) => (\n        // serialize the job execution to avoid race conditions:\n        this.jobExecutor.run(\n          () => job({\n            state: activeResponse.state,\n            write: () => {\n              var _a17;\n              this.setStatus({ status: \"streaming\" });\n              const replaceLastMessage = activeResponse.state.message.id === ((_a17 = this.lastMessage) == null ? void 0 : _a17.id);\n              if (replaceLastMessage) {\n                this.state.replaceMessage(\n                  this.state.messages.length - 1,\n                  activeResponse.state.message\n                );\n              } else {\n                this.state.pushMessage(activeResponse.state.message);\n              }\n            }\n          })\n        )\n      );\n      await consumeStream({\n        stream: processUIMessageStream({\n          stream,\n          onToolCall: this.onToolCall,\n          onData: this.onData,\n          messageMetadataSchema: this.messageMetadataSchema,\n          dataPartSchemas: this.dataPartSchemas,\n          runUpdateMessageJob,\n          onError: (error) => {\n            throw error;\n          }\n        }),\n        onError: (error) => {\n          throw error;\n        }\n      });\n      this.setStatus({ status: \"ready\" });\n    } catch (err) {\n      if (isAbort || err.name === \"AbortError\") {\n        isAbort = true;\n        this.setStatus({ status: \"ready\" });\n        return null;\n      }\n      isError = true;\n      if (err instanceof TypeError && (err.message.toLowerCase().includes(\"fetch\") || err.message.toLowerCase().includes(\"network\"))) {\n        isDisconnect = true;\n      }\n      if (this.onError && err instanceof Error) {\n        this.onError(err);\n      }\n      this.setStatus({ status: \"error\", error: err });\n    } finally {\n      try {\n        (_b = this.onFinish) == null ? void 0 : _b.call(this, {\n          message: this.activeResponse.state.message,\n          messages: this.state.messages,\n          isAbort,\n          isDisconnect,\n          isError,\n          finishReason: (_a16 = this.activeResponse) == null ? void 0 : _a16.state.finishReason\n        });\n      } catch (err) {\n        console.error(err);\n      }\n      this.activeResponse = void 0;\n    }\n    if (((_c = this.sendAutomaticallyWhen) == null ? void 0 : _c.call(this, { messages: this.state.messages })) && !isError) {\n      await this.makeRequest({\n        trigger: \"submit-message\",\n        messageId: (_d = this.lastMessage) == null ? void 0 : _d.id,\n        metadata,\n        headers,\n        body\n      });\n    }\n  }\n};\n\n// src/ui/last-assistant-message-is-complete-with-tool-calls.ts\nfunction lastAssistantMessageIsCompleteWithToolCalls({\n  messages\n}) {\n  const message = messages[messages.length - 1];\n  if (!message) {\n    return false;\n  }\n  if (message.role !== \"assistant\") {\n    return false;\n  }\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === \"step-start\" ? index : lastIndex;\n  }, -1);\n  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolOrDynamicToolUIPart).filter((part) => !part.providerExecuted);\n  return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every(\n    (part) => part.state === \"output-available\" || part.state === \"output-error\"\n  );\n}\n\n// src/ui/transform-text-to-ui-message-stream.ts\nfunction transformTextToUiMessageStream({\n  stream\n}) {\n  return stream.pipeThrough(\n    new TransformStream({\n      start(controller) {\n        controller.enqueue({ type: \"start\" });\n        controller.enqueue({ type: \"start-step\" });\n        controller.enqueue({ type: \"text-start\", id: \"text-1\" });\n      },\n      async transform(part, controller) {\n        controller.enqueue({ type: \"text-delta\", id: \"text-1\", delta: part });\n      },\n      async flush(controller) {\n        controller.enqueue({ type: \"text-end\", id: \"text-1\" });\n        controller.enqueue({ type: \"finish-step\" });\n        controller.enqueue({ type: \"finish\" });\n      }\n    })\n  );\n}\n\n// src/ui/text-stream-chat-transport.ts\nvar TextStreamChatTransport = class extends HttpChatTransport {\n  constructor(options = {}) {\n    super(options);\n  }\n  processResponseStream(stream) {\n    return transformTextToUiMessageStream({\n      stream: stream.pipeThrough(new TextDecoderStream())\n    });\n  }\n};\n\n// src/ui/validate-ui-messages.ts\nimport { TypeValidationError as TypeValidationError4 } from \"@ai-sdk/provider\";\nimport {\n  lazyValidator as lazyValidator2,\n  validateTypes as validateTypes2,\n  zodSchema as zodSchema2\n} from \"@ai-sdk/provider-utils\";\nimport { z as z8 } from \"zod/v4\";\nvar uiMessagesSchema = lazyValidator2(\n  () => zodSchema2(\n    z8.array(\n      z8.object({\n        id: z8.string(),\n        role: z8.enum([\"system\", \"user\", \"assistant\"]),\n        metadata: z8.unknown().optional(),\n        parts: z8.array(\n          z8.union([\n            z8.object({\n              type: z8.literal(\"text\"),\n              text: z8.string(),\n              state: z8.enum([\"streaming\", \"done\"]).optional(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            z8.object({\n              type: z8.literal(\"reasoning\"),\n              text: z8.string(),\n              state: z8.enum([\"streaming\", \"done\"]).optional(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            z8.object({\n              type: z8.literal(\"source-url\"),\n              sourceId: z8.string(),\n              url: z8.string(),\n              title: z8.string().optional(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            z8.object({\n              type: z8.literal(\"source-document\"),\n              sourceId: z8.string(),\n              mediaType: z8.string(),\n              title: z8.string(),\n              filename: z8.string().optional(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            z8.object({\n              type: z8.literal(\"file\"),\n              mediaType: z8.string(),\n              filename: z8.string().optional(),\n              url: z8.string(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            z8.object({\n              type: z8.literal(\"step-start\")\n            }),\n            z8.object({\n              type: z8.string().startsWith(\"data-\"),\n              id: z8.string().optional(),\n              data: z8.unknown()\n            }),\n            z8.object({\n              type: z8.literal(\"dynamic-tool\"),\n              toolName: z8.string(),\n              toolCallId: z8.string(),\n              state: z8.literal(\"input-streaming\"),\n              input: z8.unknown().optional(),\n              providerExecuted: z8.boolean().optional(),\n              output: z8.never().optional(),\n              errorText: z8.never().optional()\n            }),\n            z8.object({\n              type: z8.literal(\"dynamic-tool\"),\n              toolName: z8.string(),\n              toolCallId: z8.string(),\n              state: z8.literal(\"input-available\"),\n              input: z8.unknown(),\n              providerExecuted: z8.boolean().optional(),\n              output: z8.never().optional(),\n              errorText: z8.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional()\n            }),\n            z8.object({\n              type: z8.literal(\"dynamic-tool\"),\n              toolName: z8.string(),\n              toolCallId: z8.string(),\n              state: z8.literal(\"output-available\"),\n              input: z8.unknown(),\n              providerExecuted: z8.boolean().optional(),\n              output: z8.unknown(),\n              errorText: z8.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              preliminary: z8.boolean().optional()\n            }),\n            z8.object({\n              type: z8.literal(\"dynamic-tool\"),\n              toolName: z8.string(),\n              toolCallId: z8.string(),\n              state: z8.literal(\"output-error\"),\n              input: z8.unknown(),\n              providerExecuted: z8.boolean().optional(),\n              output: z8.never().optional(),\n              errorText: z8.string(),\n              callProviderMetadata: providerMetadataSchema.optional()\n            }),\n            z8.object({\n              type: z8.string().startsWith(\"tool-\"),\n              toolCallId: z8.string(),\n              state: z8.literal(\"input-streaming\"),\n              providerExecuted: z8.boolean().optional(),\n              input: z8.unknown().optional(),\n              output: z8.never().optional(),\n              errorText: z8.never().optional(),\n              approval: z8.never().optional()\n            }),\n            z8.object({\n              type: z8.string().startsWith(\"tool-\"),\n              toolCallId: z8.string(),\n              state: z8.literal(\"input-available\"),\n              providerExecuted: z8.boolean().optional(),\n              input: z8.unknown(),\n              output: z8.never().optional(),\n              errorText: z8.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: z8.never().optional()\n            }),\n            z8.object({\n              type: z8.string().startsWith(\"tool-\"),\n              toolCallId: z8.string(),\n              state: z8.literal(\"approval-requested\"),\n              input: z8.unknown(),\n              providerExecuted: z8.boolean().optional(),\n              output: z8.never().optional(),\n              errorText: z8.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: z8.object({\n                id: z8.string(),\n                approved: z8.never().optional(),\n                reason: z8.never().optional()\n              })\n            }),\n            z8.object({\n              type: z8.string().startsWith(\"tool-\"),\n              toolCallId: z8.string(),\n              state: z8.literal(\"approval-responded\"),\n              input: z8.unknown(),\n              providerExecuted: z8.boolean().optional(),\n              output: z8.never().optional(),\n              errorText: z8.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: z8.object({\n                id: z8.string(),\n                approved: z8.boolean(),\n                reason: z8.string().optional()\n              })\n            }),\n            z8.object({\n              type: z8.string().startsWith(\"tool-\"),\n              toolCallId: z8.string(),\n              state: z8.literal(\"output-available\"),\n              providerExecuted: z8.boolean().optional(),\n              input: z8.unknown(),\n              output: z8.unknown(),\n              errorText: z8.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              preliminary: z8.boolean().optional(),\n              approval: z8.object({\n                id: z8.string(),\n                approved: z8.literal(true),\n                reason: z8.string().optional()\n              }).optional()\n            }),\n            z8.object({\n              type: z8.string().startsWith(\"tool-\"),\n              toolCallId: z8.string(),\n              state: z8.literal(\"output-error\"),\n              providerExecuted: z8.boolean().optional(),\n              input: z8.unknown(),\n              output: z8.never().optional(),\n              errorText: z8.string(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: z8.object({\n                id: z8.string(),\n                approved: z8.literal(true),\n                reason: z8.string().optional()\n              }).optional()\n            }),\n            z8.object({\n              type: z8.string().startsWith(\"tool-\"),\n              toolCallId: z8.string(),\n              state: z8.literal(\"output-denied\"),\n              providerExecuted: z8.boolean().optional(),\n              input: z8.unknown(),\n              output: z8.never().optional(),\n              errorText: z8.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: z8.object({\n                id: z8.string(),\n                approved: z8.literal(false),\n                reason: z8.string().optional()\n              })\n            })\n          ])\n        ).nonempty(\"Message must contain at least one part\")\n      })\n    ).nonempty(\"Messages array must not be empty\")\n  )\n);\nasync function safeValidateUIMessages({\n  messages,\n  metadataSchema,\n  dataSchemas,\n  tools\n}) {\n  try {\n    if (messages == null) {\n      return {\n        success: false,\n        error: new InvalidArgumentError({\n          parameter: \"messages\",\n          value: messages,\n          message: \"messages parameter must be provided\"\n        })\n      };\n    }\n    const validatedMessages = await validateTypes2({\n      value: messages,\n      schema: uiMessagesSchema\n    });\n    if (metadataSchema) {\n      for (const message of validatedMessages) {\n        await validateTypes2({\n          value: message.metadata,\n          schema: metadataSchema\n        });\n      }\n    }\n    if (dataSchemas) {\n      for (const message of validatedMessages) {\n        const dataParts = message.parts.filter(\n          (part) => part.type.startsWith(\"data-\")\n        );\n        for (const dataPart of dataParts) {\n          const dataName = dataPart.type.slice(5);\n          const dataSchema = dataSchemas[dataName];\n          if (!dataSchema) {\n            return {\n              success: false,\n              error: new TypeValidationError4({\n                value: dataPart.data,\n                cause: `No data schema found for data part ${dataName}`\n              })\n            };\n          }\n          await validateTypes2({\n            value: dataPart.data,\n            schema: dataSchema\n          });\n        }\n      }\n    }\n    if (tools) {\n      for (const message of validatedMessages) {\n        const toolParts = message.parts.filter(\n          (part) => part.type.startsWith(\"tool-\")\n        );\n        for (const toolPart of toolParts) {\n          const toolName = toolPart.type.slice(5);\n          const tool2 = tools[toolName];\n          if (!tool2) {\n            return {\n              success: false,\n              error: new TypeValidationError4({\n                value: toolPart.input,\n                cause: `No tool schema found for tool part ${toolName}`\n              })\n            };\n          }\n          if (toolPart.state === \"input-available\" || toolPart.state === \"output-available\" || toolPart.state === \"output-error\") {\n            await validateTypes2({\n              value: toolPart.input,\n              schema: tool2.inputSchema\n            });\n          }\n          if (toolPart.state === \"output-available\" && tool2.outputSchema) {\n            await validateTypes2({\n              value: toolPart.output,\n              schema: tool2.outputSchema\n            });\n          }\n        }\n      }\n    }\n    return {\n      success: true,\n      data: validatedMessages\n    };\n  } catch (error) {\n    const err = error;\n    return {\n      success: false,\n      error: err\n    };\n  }\n}\nasync function validateUIMessages({\n  messages,\n  metadataSchema,\n  dataSchemas,\n  tools\n}) {\n  const response = await safeValidateUIMessages({\n    messages,\n    metadataSchema,\n    dataSchemas,\n    tools\n  });\n  if (!response.success)\n    throw response.error;\n  return response.data;\n}\n\n// src/ui-message-stream/create-ui-message-stream.ts\nimport {\n  generateId as generateIdFunc2,\n  getErrorMessage as getErrorMessage8\n} from \"@ai-sdk/provider-utils\";\nfunction createUIMessageStream({\n  execute,\n  onError = getErrorMessage8,\n  originalMessages,\n  onFinish,\n  generateId: generateId3 = generateIdFunc2\n}) {\n  let controller;\n  const ongoingStreamPromises = [];\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    }\n  });\n  function safeEnqueue(data) {\n    try {\n      controller.enqueue(data);\n    } catch (error) {\n    }\n  }\n  try {\n    const result = execute({\n      writer: {\n        write(part) {\n          safeEnqueue(part);\n        },\n        merge(streamArg) {\n          ongoingStreamPromises.push(\n            (async () => {\n              const reader = streamArg.getReader();\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                  break;\n                safeEnqueue(value);\n              }\n            })().catch((error) => {\n              safeEnqueue({\n                type: \"error\",\n                errorText: onError(error)\n              });\n            })\n          );\n        },\n        onError\n      }\n    });\n    if (result) {\n      ongoingStreamPromises.push(\n        result.catch((error) => {\n          safeEnqueue({\n            type: \"error\",\n            errorText: onError(error)\n          });\n        })\n      );\n    }\n  } catch (error) {\n    safeEnqueue({\n      type: \"error\",\n      errorText: onError(error)\n    });\n  }\n  const waitForStreams = new Promise(async (resolve2) => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve2();\n  });\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error) {\n    }\n  });\n  return handleUIMessageStreamFinish({\n    stream,\n    messageId: generateId3(),\n    originalMessages,\n    onFinish,\n    onError\n  });\n}\n\n// src/ui-message-stream/read-ui-message-stream.ts\nfunction readUIMessageStream({\n  message,\n  stream,\n  onError,\n  terminateOnError = false\n}) {\n  var _a16;\n  let controller;\n  let hasErrored = false;\n  const outputStream = new ReadableStream({\n    start(controllerParam) {\n      controller = controllerParam;\n    }\n  });\n  const state = createStreamingUIMessageState({\n    messageId: (_a16 = message == null ? void 0 : message.id) != null ? _a16 : \"\",\n    lastMessage: message\n  });\n  const handleError = (error) => {\n    onError == null ? void 0 : onError(error);\n    if (!hasErrored && terminateOnError) {\n      hasErrored = true;\n      controller == null ? void 0 : controller.error(error);\n    }\n  };\n  consumeStream({\n    stream: processUIMessageStream({\n      stream,\n      runUpdateMessageJob(job) {\n        return job({\n          state,\n          write: () => {\n            controller == null ? void 0 : controller.enqueue(structuredClone(state.message));\n          }\n        });\n      },\n      onError: handleError\n    }),\n    onError: handleError\n  }).finally(() => {\n    if (!hasErrored) {\n      controller == null ? void 0 : controller.close();\n    }\n  });\n  return createAsyncIterableStream(outputStream);\n}\nexport {\n  AISDKError17 as AISDKError,\n  APICallError,\n  AbstractChat,\n  DefaultChatTransport,\n  DownloadError,\n  EmptyResponseBodyError,\n  Agent as Experimental_Agent,\n  HttpChatTransport,\n  InvalidArgumentError,\n  InvalidDataContentError,\n  InvalidMessageRoleError,\n  InvalidPromptError,\n  InvalidResponseDataError,\n  InvalidStreamPartError,\n  InvalidToolInputError,\n  JSONParseError,\n  JsonToSseTransformStream,\n  LoadAPIKeyError,\n  LoadSettingError,\n  MessageConversionError,\n  NoContentGeneratedError,\n  NoImageGeneratedError,\n  NoObjectGeneratedError,\n  NoOutputGeneratedError,\n  NoOutputSpecifiedError,\n  NoSpeechGeneratedError,\n  NoSuchModelError,\n  NoSuchProviderError,\n  NoSuchToolError,\n  output_exports as Output,\n  RetryError,\n  SerialJobExecutor,\n  TextStreamChatTransport,\n  TooManyEmbeddingValuesForCallError,\n  ToolCallRepairError,\n  TypeValidationError,\n  UI_MESSAGE_STREAM_HEADERS,\n  UnsupportedFunctionalityError,\n  UnsupportedModelVersionError,\n  asSchema5 as asSchema,\n  assistantModelMessageSchema,\n  callCompletionApi,\n  consumeStream,\n  convertFileListToFileUIParts,\n  convertToCoreMessages,\n  convertToModelMessages,\n  coreAssistantMessageSchema,\n  coreMessageSchema,\n  coreSystemMessageSchema,\n  coreToolMessageSchema,\n  coreUserMessageSchema,\n  cosineSimilarity,\n  createGateway,\n  createIdGenerator5 as createIdGenerator,\n  createProviderRegistry,\n  createTextStreamResponse,\n  createUIMessageStream,\n  createUIMessageStreamResponse,\n  customProvider,\n  defaultSettingsMiddleware,\n  dynamicTool,\n  embed,\n  embedMany,\n  experimental_createProviderRegistry,\n  experimental_customProvider,\n  generateImage as experimental_generateImage,\n  generateSpeech as experimental_generateSpeech,\n  transcribe as experimental_transcribe,\n  extractReasoningMiddleware,\n  gateway2 as gateway,\n  generateId2 as generateId,\n  generateObject,\n  generateText,\n  getTextFromDataUrl,\n  getToolName,\n  getToolOrDynamicToolName,\n  hasToolCall,\n  isDataUIPart,\n  isDeepEqualData,\n  isFileUIPart,\n  isReasoningUIPart,\n  isTextUIPart,\n  isToolOrDynamicToolUIPart,\n  isToolUIPart,\n  jsonSchema,\n  lastAssistantMessageIsCompleteWithToolCalls,\n  modelMessageSchema,\n  parseJsonEventStream3 as parseJsonEventStream,\n  parsePartialJson,\n  pipeTextStreamToResponse,\n  pipeUIMessageStreamToResponse,\n  pruneMessages,\n  readUIMessageStream,\n  safeValidateUIMessages,\n  simulateReadableStream,\n  simulateStreamingMiddleware,\n  smoothStream,\n  stepCountIs,\n  streamObject,\n  streamText,\n  systemModelMessageSchema,\n  tool,\n  toolModelMessageSchema,\n  uiMessageChunkSchema,\n  userModelMessageSchema,\n  validateUIMessages,\n  wrapLanguageModel,\n  wrapProvider,\n  zodSchema3 as zodSchema\n};\n//# sourceMappingURL=index.mjs.map","function throttle(function_, wait) {\n\tif (typeof function_ !== 'function') {\n\t\tthrow new TypeError(`Expected the first argument to be a \\`function\\`, got \\`${typeof function_}\\`.`);\n\t}\n\n\t// TODO: Add `wait` validation too in the next major version.\n\n\tlet timeoutId;\n\tlet lastCallTime = 0;\n\n\treturn function throttled(...arguments_) { // eslint-disable-line func-names\n\t\tclearTimeout(timeoutId);\n\n\t\tconst now = Date.now();\n\t\tconst timeSinceLastCall = now - lastCallTime;\n\t\tconst delayForNextCall = wait - timeSinceLastCall;\n\n\t\tif (delayForNextCall <= 0) {\n\t\t\tlastCallTime = now;\n\t\t\tfunction_.apply(this, arguments_);\n\t\t} else {\n\t\t\ttimeoutId = setTimeout(() => {\n\t\t\t\tlastCallTime = Date.now();\n\t\t\t\tfunction_.apply(this, arguments_);\n\t\t\t}, delayForNextCall);\n\t\t}\n\t};\n}\n\nmodule.exports = throttle;\n","var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\n\n// src/use-chat.ts\nimport { useCallback, useEffect, useRef, useSyncExternalStore } from \"react\";\n\n// src/chat.react.ts\nimport { AbstractChat } from \"ai\";\n\n// src/throttle.ts\nimport throttleFunction from \"throttleit\";\nfunction throttle(fn, waitMs) {\n  return waitMs != null ? throttleFunction(fn, waitMs) : fn;\n}\n\n// src/chat.react.ts\nvar _messages, _status, _error, _messagesCallbacks, _statusCallbacks, _errorCallbacks, _callMessagesCallbacks, _callStatusCallbacks, _callErrorCallbacks;\nvar ReactChatState = class {\n  constructor(initialMessages = []) {\n    __privateAdd(this, _messages, void 0);\n    __privateAdd(this, _status, \"ready\");\n    __privateAdd(this, _error, void 0);\n    __privateAdd(this, _messagesCallbacks, /* @__PURE__ */ new Set());\n    __privateAdd(this, _statusCallbacks, /* @__PURE__ */ new Set());\n    __privateAdd(this, _errorCallbacks, /* @__PURE__ */ new Set());\n    this.pushMessage = (message) => {\n      __privateSet(this, _messages, __privateGet(this, _messages).concat(message));\n      __privateGet(this, _callMessagesCallbacks).call(this);\n    };\n    this.popMessage = () => {\n      __privateSet(this, _messages, __privateGet(this, _messages).slice(0, -1));\n      __privateGet(this, _callMessagesCallbacks).call(this);\n    };\n    this.replaceMessage = (index, message) => {\n      __privateSet(this, _messages, [\n        ...__privateGet(this, _messages).slice(0, index),\n        // We deep clone the message here to ensure the new React Compiler (currently in RC) detects deeply nested parts/metadata changes:\n        this.snapshot(message),\n        ...__privateGet(this, _messages).slice(index + 1)\n      ]);\n      __privateGet(this, _callMessagesCallbacks).call(this);\n    };\n    this.snapshot = (value) => structuredClone(value);\n    this[\"~registerMessagesCallback\"] = (onChange, throttleWaitMs) => {\n      const callback = throttleWaitMs ? throttle(onChange, throttleWaitMs) : onChange;\n      __privateGet(this, _messagesCallbacks).add(callback);\n      return () => {\n        __privateGet(this, _messagesCallbacks).delete(callback);\n      };\n    };\n    this[\"~registerStatusCallback\"] = (onChange) => {\n      __privateGet(this, _statusCallbacks).add(onChange);\n      return () => {\n        __privateGet(this, _statusCallbacks).delete(onChange);\n      };\n    };\n    this[\"~registerErrorCallback\"] = (onChange) => {\n      __privateGet(this, _errorCallbacks).add(onChange);\n      return () => {\n        __privateGet(this, _errorCallbacks).delete(onChange);\n      };\n    };\n    __privateAdd(this, _callMessagesCallbacks, () => {\n      __privateGet(this, _messagesCallbacks).forEach((callback) => callback());\n    });\n    __privateAdd(this, _callStatusCallbacks, () => {\n      __privateGet(this, _statusCallbacks).forEach((callback) => callback());\n    });\n    __privateAdd(this, _callErrorCallbacks, () => {\n      __privateGet(this, _errorCallbacks).forEach((callback) => callback());\n    });\n    __privateSet(this, _messages, initialMessages);\n  }\n  get status() {\n    return __privateGet(this, _status);\n  }\n  set status(newStatus) {\n    __privateSet(this, _status, newStatus);\n    __privateGet(this, _callStatusCallbacks).call(this);\n  }\n  get error() {\n    return __privateGet(this, _error);\n  }\n  set error(newError) {\n    __privateSet(this, _error, newError);\n    __privateGet(this, _callErrorCallbacks).call(this);\n  }\n  get messages() {\n    return __privateGet(this, _messages);\n  }\n  set messages(newMessages) {\n    __privateSet(this, _messages, [...newMessages]);\n    __privateGet(this, _callMessagesCallbacks).call(this);\n  }\n};\n_messages = new WeakMap();\n_status = new WeakMap();\n_error = new WeakMap();\n_messagesCallbacks = new WeakMap();\n_statusCallbacks = new WeakMap();\n_errorCallbacks = new WeakMap();\n_callMessagesCallbacks = new WeakMap();\n_callStatusCallbacks = new WeakMap();\n_callErrorCallbacks = new WeakMap();\nvar _state;\nvar Chat = class extends AbstractChat {\n  constructor({ messages, ...init }) {\n    const state = new ReactChatState(messages);\n    super({ ...init, state });\n    __privateAdd(this, _state, void 0);\n    this[\"~registerMessagesCallback\"] = (onChange, throttleWaitMs) => __privateGet(this, _state)[\"~registerMessagesCallback\"](onChange, throttleWaitMs);\n    this[\"~registerStatusCallback\"] = (onChange) => __privateGet(this, _state)[\"~registerStatusCallback\"](onChange);\n    this[\"~registerErrorCallback\"] = (onChange) => __privateGet(this, _state)[\"~registerErrorCallback\"](onChange);\n    __privateSet(this, _state, state);\n  }\n};\n_state = new WeakMap();\n\n// src/use-chat.ts\nfunction useChat({\n  experimental_throttle: throttleWaitMs,\n  resume = false,\n  ...options\n} = {}) {\n  const chatRef = useRef(\n    \"chat\" in options ? options.chat : new Chat(options)\n  );\n  const shouldRecreateChat = \"chat\" in options && options.chat !== chatRef.current || \"id\" in options && chatRef.current.id !== options.id;\n  if (shouldRecreateChat) {\n    chatRef.current = \"chat\" in options ? options.chat : new Chat(options);\n  }\n  const subscribeToMessages = useCallback(\n    (update) => chatRef.current[\"~registerMessagesCallback\"](update, throttleWaitMs),\n    // `chatRef.current.id` is required to trigger re-subscription when the chat ID changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [throttleWaitMs, chatRef.current.id]\n  );\n  const messages = useSyncExternalStore(\n    subscribeToMessages,\n    () => chatRef.current.messages,\n    () => chatRef.current.messages\n  );\n  const status = useSyncExternalStore(\n    chatRef.current[\"~registerStatusCallback\"],\n    () => chatRef.current.status,\n    () => chatRef.current.status\n  );\n  const error = useSyncExternalStore(\n    chatRef.current[\"~registerErrorCallback\"],\n    () => chatRef.current.error,\n    () => chatRef.current.error\n  );\n  const setMessages = useCallback(\n    (messagesParam) => {\n      if (typeof messagesParam === \"function\") {\n        messagesParam = messagesParam(chatRef.current.messages);\n      }\n      chatRef.current.messages = messagesParam;\n    },\n    [chatRef]\n  );\n  useEffect(() => {\n    if (resume) {\n      chatRef.current.resumeStream();\n    }\n  }, [resume, chatRef]);\n  return {\n    id: chatRef.current.id,\n    messages,\n    setMessages,\n    sendMessage: chatRef.current.sendMessage,\n    regenerate: chatRef.current.regenerate,\n    clearError: chatRef.current.clearError,\n    stop: chatRef.current.stop,\n    error,\n    resumeStream: chatRef.current.resumeStream,\n    status,\n    /**\n     * @deprecated Use `addToolOutput` instead.\n     */\n    addToolResult: chatRef.current.addToolOutput,\n    addToolOutput: chatRef.current.addToolOutput\n  };\n}\n\n// src/use-completion.ts\nimport {\n  callCompletionApi\n} from \"ai\";\nimport { useCallback as useCallback2, useEffect as useEffect2, useId, useRef as useRef2, useState } from \"react\";\nimport useSWR from \"swr\";\nfunction useCompletion({\n  api = \"/api/completion\",\n  id,\n  initialCompletion = \"\",\n  initialInput = \"\",\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  fetch: fetch2,\n  onFinish,\n  onError,\n  experimental_throttle: throttleWaitMs\n} = {}) {\n  const hookId = useId();\n  const completionId = id || hookId;\n  const { data, mutate } = useSWR([api, completionId], null, {\n    fallbackData: initialCompletion\n  });\n  const { data: isLoading = false, mutate: mutateLoading } = useSWR(\n    [completionId, \"loading\"],\n    null\n  );\n  const [error, setError] = useState(void 0);\n  const completion = data;\n  const [abortController, setAbortController] = useState(null);\n  const extraMetadataRef = useRef2({\n    credentials,\n    headers,\n    body\n  });\n  useEffect2(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body\n    };\n  }, [credentials, headers, body]);\n  const triggerRequest = useCallback2(\n    async (prompt, options) => callCompletionApi({\n      api,\n      prompt,\n      credentials: extraMetadataRef.current.credentials,\n      headers: { ...extraMetadataRef.current.headers, ...options == null ? void 0 : options.headers },\n      body: {\n        ...extraMetadataRef.current.body,\n        ...options == null ? void 0 : options.body\n      },\n      streamProtocol,\n      fetch: fetch2,\n      // throttle streamed ui updates:\n      setCompletion: throttle(\n        (completion2) => mutate(completion2, false),\n        throttleWaitMs\n      ),\n      setLoading: mutateLoading,\n      setError,\n      setAbortController,\n      onFinish,\n      onError\n    }),\n    [\n      mutate,\n      mutateLoading,\n      api,\n      extraMetadataRef,\n      setAbortController,\n      onFinish,\n      onError,\n      setError,\n      streamProtocol,\n      fetch2,\n      throttleWaitMs\n    ]\n  );\n  const stop = useCallback2(() => {\n    if (abortController) {\n      abortController.abort();\n      setAbortController(null);\n    }\n  }, [abortController]);\n  const setCompletion = useCallback2(\n    (completion2) => {\n      mutate(completion2, false);\n    },\n    [mutate]\n  );\n  const complete = useCallback2(\n    async (prompt, options) => {\n      return triggerRequest(prompt, options);\n    },\n    [triggerRequest]\n  );\n  const [input, setInput] = useState(initialInput);\n  const handleSubmit = useCallback2(\n    (event) => {\n      var _a;\n      (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n      return input ? complete(input) : void 0;\n    },\n    [input, complete]\n  );\n  const handleInputChange = useCallback2(\n    (e) => {\n      setInput(e.target.value);\n    },\n    [setInput]\n  );\n  return {\n    completion,\n    complete,\n    error,\n    setCompletion,\n    stop,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading\n  };\n}\n\n// src/use-object.ts\nimport {\n  isAbortError,\n  safeValidateTypes\n} from \"@ai-sdk/provider-utils\";\nimport {\n  asSchema,\n  isDeepEqualData,\n  parsePartialJson\n} from \"ai\";\nimport { useCallback as useCallback3, useId as useId2, useRef as useRef3, useState as useState2 } from \"react\";\nimport useSWR2 from \"swr\";\nvar getOriginalFetch = () => fetch;\nfunction useObject({\n  api,\n  id,\n  schema,\n  // required, in the future we will use it for validation\n  initialValue,\n  fetch: fetch2,\n  onError,\n  onFinish,\n  headers,\n  credentials\n}) {\n  const hookId = useId2();\n  const completionId = id != null ? id : hookId;\n  const { data, mutate } = useSWR2(\n    [api, completionId],\n    null,\n    { fallbackData: initialValue }\n  );\n  const [error, setError] = useState2(void 0);\n  const [isLoading, setIsLoading] = useState2(false);\n  const abortControllerRef = useRef3(null);\n  const stop = useCallback3(() => {\n    var _a;\n    try {\n      (_a = abortControllerRef.current) == null ? void 0 : _a.abort();\n    } catch (ignored) {\n    } finally {\n      setIsLoading(false);\n      abortControllerRef.current = null;\n    }\n  }, []);\n  const submit = async (input) => {\n    var _a;\n    try {\n      clearObject();\n      setIsLoading(true);\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n      const actualFetch = fetch2 != null ? fetch2 : getOriginalFetch();\n      const response = await actualFetch(api, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...headers\n        },\n        credentials,\n        signal: abortController.signal,\n        body: JSON.stringify(input)\n      });\n      if (!response.ok) {\n        throw new Error(\n          (_a = await response.text()) != null ? _a : \"Failed to fetch the response.\"\n        );\n      }\n      if (response.body == null) {\n        throw new Error(\"The response body is empty.\");\n      }\n      let accumulatedText = \"\";\n      let latestObject = void 0;\n      await response.body.pipeThrough(new TextDecoderStream()).pipeTo(\n        new WritableStream({\n          async write(chunk) {\n            accumulatedText += chunk;\n            const { value } = await parsePartialJson(accumulatedText);\n            const currentObject = value;\n            if (!isDeepEqualData(latestObject, currentObject)) {\n              latestObject = currentObject;\n              mutate(currentObject);\n            }\n          },\n          async close() {\n            setIsLoading(false);\n            abortControllerRef.current = null;\n            if (onFinish != null) {\n              const validationResult = await safeValidateTypes({\n                value: latestObject,\n                schema: asSchema(schema)\n              });\n              onFinish(\n                validationResult.success ? { object: validationResult.value, error: void 0 } : { object: void 0, error: validationResult.error }\n              );\n            }\n          }\n        })\n      );\n    } catch (error2) {\n      if (isAbortError(error2)) {\n        return;\n      }\n      if (onError && error2 instanceof Error) {\n        onError(error2);\n      }\n      setIsLoading(false);\n      setError(error2 instanceof Error ? error2 : new Error(String(error2)));\n    }\n  };\n  const clear = () => {\n    stop();\n    clearObject();\n  };\n  const clearObject = () => {\n    setError(void 0);\n    setIsLoading(false);\n    mutate(void 0);\n  };\n  return {\n    submit,\n    object: data,\n    error,\n    isLoading,\n    stop,\n    clear\n  };\n}\nvar experimental_useObject = useObject;\nexport {\n  Chat,\n  experimental_useObject,\n  useChat,\n  useCompletion\n};\n//# sourceMappingURL=index.mjs.map","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import * as React from 'react';\nimport { dequal } from 'dequal';\n\nfunction checkDeps(deps) {\n  if (!deps || !deps.length) {\n    throw new Error('useDeepCompareEffect should not be used with no dependencies. Use React.useEffect instead.');\n  }\n\n  if (deps.every(isPrimitive)) {\n    throw new Error('useDeepCompareEffect should not be used with dependencies that are all primitive values. Use React.useEffect instead.');\n  }\n}\n\nfunction isPrimitive(val) {\n  return val == null || /^[sbn]/.test(typeof val);\n}\n/**\n * @param value the value to be memoized (usually a dependency list)\n * @returns a momoized version of the value as long as it remains deeply equal\n */\n\n\nfunction useDeepCompareMemoize(value) {\n  var ref = React.useRef(value);\n  var signalRef = React.useRef(0);\n\n  if (!dequal(value, ref.current)) {\n    ref.current = value;\n    signalRef.current += 1;\n  } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n\n  return React.useMemo(function () {\n    return ref.current;\n  }, [signalRef.current]);\n}\n\nfunction useDeepCompareEffect(callback, dependencies) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkDeps(dependencies);\n  } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n\n  return React.useEffect(callback, useDeepCompareMemoize(dependencies));\n}\n\nfunction useDeepCompareEffectNoCheck(callback, dependencies) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useEffect(callback, useDeepCompareMemoize(dependencies));\n}\n\nexport { useDeepCompareEffect as default, useDeepCompareEffectNoCheck, useDeepCompareMemoize };\n","import { storage } from '@wxt-dev/storage'\nimport type { ChatAction } from '@/lib/chat-actions/types'\n\n/**\n * @public\n */\nexport interface SearchActionStorage {\n  query: string\n  mode: 'chat' | 'agent'\n  action?: ChatAction\n}\n\n/**\n * @public\n */\nexport const searchActionsStorage = storage.defineItem<SearchActionStorage>(\n  'local:search-actions',\n)\n","import type { ChatStatus, ToolUIPart, UIMessage } from 'ai'\nimport { useEffect, useRef } from 'react'\nimport type { GlowMessage } from '@/entrypoints/glow.content/GlowMessage'\n\nexport const useNotifyActiveTab = ({\n  messages,\n  status,\n  conversationId,\n}: {\n  messages: UIMessage[]\n  status: ChatStatus\n  conversationId: string\n}) => {\n  // Ref to store the last active tab ID\n  const lastTabIdRef = useRef<number | null>(null)\n\n  const lastMessage = messages?.[messages.length - 1]\n\n  const latestTool =\n    lastMessage?.parts?.findLast((part) => part?.type?.startsWith('tool-')) ??\n    null\n\n  const latestTabId = (\n    latestTool as ToolUIPart & { input?: { tabId?: number } }\n  )?.input?.tabId\n\n  useEffect(() => {\n    const isStreaming = status === 'streaming'\n    const previousTabId = lastTabIdRef.current\n\n    // Streaming stopped - turn off glow on the last active tab\n    const stoppedStreaming = !isStreaming && previousTabId\n\n    // Switched to a different tab while streaming - need to turn off glow on old tab\n    const switchedTabs =\n      isStreaming &&\n      latestTabId &&\n      previousTabId &&\n      latestTabId !== previousTabId\n\n    if (stoppedStreaming || switchedTabs) {\n      if (previousTabId) {\n        const deactivateMessage: GlowMessage = {\n          conversationId,\n          isActive: false,\n        }\n        chrome.tabs.sendMessage(previousTabId, deactivateMessage).catch(() => {\n          // no action needed if the tab is closed or does not exist\n        })\n      }\n    }\n\n    // Activate glow on current tab while streaming\n    if (isStreaming && latestTabId) {\n      const activateMessage: GlowMessage = {\n        conversationId,\n        isActive: true,\n      }\n      chrome.tabs.sendMessage(latestTabId, activateMessage).catch(() => {\n        // no action needed if the tab is closed or does not exist\n      })\n    }\n\n    // Track the latest tab for future comparisons\n    if (latestTabId) {\n      lastTabIdRef.current = latestTabId\n    }\n  }, [conversationId, status, latestTabId])\n\n  return\n}\n","import { useChat } from '@ai-sdk/react'\nimport { DefaultChatTransport, type UIMessage } from 'ai'\nimport { compact } from 'es-toolkit/array'\nimport { useEffect, useRef, useState } from 'react'\nimport useDeepCompareEffect from 'use-deep-compare-effect'\nimport { useAgentServerUrl } from '@/lib/browseros/useBrowserOSProviders'\nimport type { ChatAction } from '@/lib/chat-actions/types'\nimport {\n  CONVERSATION_RESET_EVENT,\n  MESSAGE_DISLIKE_EVENT,\n  MESSAGE_LIKE_EVENT,\n  MESSAGE_SENT_EVENT,\n  PROVIDER_SELECTED_EVENT,\n} from '@/lib/constants/analyticsEvents'\nimport type { LlmProviderConfig } from '@/lib/llm-providers/types'\nimport { useLlmProviders } from '@/lib/llm-providers/useLlmProviders'\nimport { type McpServer, useMcpServers } from '@/lib/mcp/mcpServerStorage'\nimport { track } from '@/lib/metrics/track'\nimport { usePersonalization } from '@/lib/personalization/personalizationStorage'\nimport { searchActionsStorage } from '@/lib/search-actions/searchActionsStorage'\nimport type { ChatMode, Provider } from './chatTypes'\nimport { useNotifyActiveTab } from './useNotifyActiveTab'\n\nconst getLastMessageText = (messages: UIMessage[]) => {\n  const lastMessage = messages[messages.length - 1]\n  if (!lastMessage) return ''\n  return lastMessage.parts\n    .filter((part) => part.type === 'text')\n    .map((part) => part.text)\n    .join('')\n}\n\nconst getResponseAndQueryFromMessageId = (\n  messages: UIMessage[],\n  messageId: string,\n) => {\n  const messageIndex = messages.findIndex((each) => each.id === messageId)\n  const response = messages?.[messageIndex] ?? []\n  const query = messages?.[messageIndex - 1] ?? []\n  const responseText = response.parts\n    .filter((each) => each.type === 'text')\n    .map((each) => each.text)\n    .join('\\n\\n')\n  const queryText = query.parts\n    .filter((each) => each.type === 'text')\n    .map((each) => each.text)\n    .join('\\n')\n\n  return {\n    responseText,\n    queryText,\n  }\n}\n\nconst constructMcpServers = (servers: McpServer[]) => {\n  return servers\n    .filter((eachServer) => eachServer.type === 'managed')\n    .map((each) => each.managedServerName)\n}\n\nconst constructCustomServers = (servers: McpServer[]) => {\n  return servers\n    .filter((eachServer) => eachServer.type === 'custom')\n    .map((each) => ({\n      name: each.displayName,\n      url: each.config?.url,\n    }))\n}\n\nexport const useChatSession = () => {\n  const { servers: mcpServers } = useMcpServers()\n\n  const enabledMcpServersRef = useRef(constructMcpServers(mcpServers))\n  const enabledCustomServersRef = useRef(constructCustomServers(mcpServers))\n\n  useDeepCompareEffect(() => {\n    enabledMcpServersRef.current = constructMcpServers(mcpServers)\n    enabledCustomServersRef.current = constructCustomServers(mcpServers)\n  }, [mcpServers])\n\n  const {\n    providers: llmProviders,\n    selectedProvider: selectedLlmProvider,\n    isLoading: isLoadingProviders,\n    setDefaultProvider,\n  } = useLlmProviders()\n\n  const { personalization } = usePersonalization()\n  const personalizationRef = useRef(personalization)\n\n  useEffect(() => {\n    personalizationRef.current = personalization\n  }, [personalization])\n\n  const {\n    baseUrl: agentServerUrl,\n    isLoading: isLoadingAgentUrl,\n    error: agentUrlError,\n  } = useAgentServerUrl()\n\n  const agentUrlRef = useRef(agentServerUrl)\n\n  useEffect(() => {\n    agentUrlRef.current = agentServerUrl\n  }, [agentServerUrl])\n\n  const providers: Provider[] = llmProviders.map((p) => ({\n    id: p.id,\n    name: p.name,\n    type: p.type,\n  }))\n\n  const [mode, setMode] = useState<ChatMode>('chat')\n  const [textToAction, setTextToAction] = useState<Map<string, ChatAction>>(\n    new Map(),\n  )\n  const [liked, setLiked] = useState<Record<string, boolean>>({})\n  const [disliked, setDisliked] = useState<Record<string, boolean>>({})\n  const conversationIdRef = useRef(crypto.randomUUID())\n\n  const onClickLike = (messageId: string) => {\n    const { responseText, queryText } = getResponseAndQueryFromMessageId(\n      messages,\n      messageId,\n    )\n\n    track(MESSAGE_LIKE_EVENT, { responseText, queryText, messageId })\n\n    setLiked((prev) => ({\n      ...prev,\n      [messageId]: !prev[messageId],\n    }))\n  }\n\n  const onClickDislike = (messageId: string, comment?: string) => {\n    const { responseText, queryText } = getResponseAndQueryFromMessageId(\n      messages,\n      messageId,\n    )\n\n    track(MESSAGE_DISLIKE_EVENT, {\n      responseText,\n      queryText,\n      messageId,\n      comment,\n    })\n\n    setDisliked((prev) => ({\n      ...prev,\n      [messageId]: !prev[messageId],\n    }))\n  }\n\n  // Refs to avoid stale closures in prepareSendMessagesRequest callback\n  const selectedLlmProviderRef = useRef<LlmProviderConfig | null>(\n    selectedLlmProvider,\n  )\n  const modeRef = useRef<ChatMode>(mode)\n\n  const textToActionRef = useRef<Map<string, ChatAction>>(textToAction)\n\n  useDeepCompareEffect(() => {\n    selectedLlmProviderRef.current = selectedLlmProvider\n    modeRef.current = mode\n    textToActionRef.current = textToAction\n  }, [selectedLlmProvider, mode, textToAction])\n\n  const selectedProvider = selectedLlmProvider\n    ? {\n        id: selectedLlmProvider.id,\n        name: selectedLlmProvider.name,\n        type:\n          selectedLlmProvider.id === 'browseros'\n            ? ('browseros' as const)\n            : selectedLlmProvider.type,\n      }\n    : providers[0]\n\n  const {\n    messages,\n    sendMessage: baseSendMessage,\n    setMessages,\n    status,\n    stop,\n    error: chatError,\n  } = useChat({\n    transport: new DefaultChatTransport({\n      // Important: this chat logic is also used in apps/agent/lib/schedules/getChatServerResponse.ts for scheduled jobs. Make sure to keep them in sync for any future changes.\n      prepareSendMessagesRequest: async ({ messages }) => {\n        const activeTabsList = await chrome.tabs.query({\n          active: true,\n          currentWindow: true,\n        })\n        const activeTab = activeTabsList?.[0] ?? undefined\n        const message = getLastMessageText(messages)\n        const provider = selectedLlmProviderRef.current\n        const currentMode = modeRef.current\n        const enabledMcpServers = enabledMcpServersRef.current\n        const customMcpServers = enabledCustomServersRef.current\n\n        const getActionForMessage = (messageText: string) => {\n          return textToActionRef.current.get(messageText)\n        }\n\n        const action = getActionForMessage(message)\n\n        const browserContext: {\n          windowId?: number\n          activeTab?: {\n            id?: number\n            url?: string\n            title?: string\n          }\n          selectedTabs?: {\n            id?: number\n            url?: string\n            title?: string\n          }[]\n          enabledMcpServers?: string[]\n          customMcpServers?: {\n            name: string\n            url: string\n          }[]\n        } = {}\n\n        if (activeTab) {\n          browserContext.windowId = activeTab.windowId\n          browserContext.activeTab = {\n            id: activeTab.id,\n            url: activeTab.url,\n            title: activeTab.title,\n          }\n        }\n\n        if (action?.tabs?.length) {\n          browserContext.selectedTabs = action?.tabs?.map((tab) => ({\n            id: tab.id,\n            url: tab.url,\n            title: tab.title,\n          }))\n        }\n\n        if (enabledMcpServers.length) {\n          browserContext.enabledMcpServers = compact(enabledMcpServers)\n        }\n\n        if (customMcpServers.length) {\n          browserContext.customMcpServers = customMcpServers as {\n            name: string\n            url: string\n          }[]\n        }\n\n        return {\n          api: `${agentUrlRef.current}/chat`,\n          body: {\n            message,\n            provider: provider?.type,\n            providerType: provider?.type,\n            providerName: provider?.name,\n            apiKey: provider?.apiKey,\n            baseUrl: provider?.baseUrl,\n            conversationId: conversationIdRef.current,\n            model: provider?.modelId ?? 'default',\n            mode: currentMode,\n            contextWindowSize: provider?.contextWindow,\n            temperature: provider?.temperature,\n            // Azure-specific\n            resourceName: provider?.resourceName,\n            // Bedrock-specific\n            accessKeyId: provider?.accessKeyId,\n            secretAccessKey: provider?.secretAccessKey,\n            region: provider?.region,\n            sessionToken: provider?.sessionToken,\n            browserContext,\n            userSystemPrompt: personalizationRef.current,\n          },\n        }\n      },\n    }),\n  })\n\n  useNotifyActiveTab({\n    messages,\n    status,\n    conversationId: conversationIdRef.current,\n  })\n\n  const sendMessage = (params: { text: string; action?: ChatAction }) => {\n    track(MESSAGE_SENT_EVENT, {\n      mode,\n      provider_type: selectedLlmProvider?.type,\n      model: selectedLlmProvider?.modelId,\n    })\n    if (params.action) {\n      const action = params.action\n      setTextToAction((prev) => {\n        const next = new Map(prev)\n        next.set(params.text, action)\n        return next\n      })\n    }\n    baseSendMessage({ text: params.text })\n  }\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: only need to run this once\n  useEffect(() => {\n    const unwatch = searchActionsStorage.watch((storageAction) => {\n      if (storageAction) {\n        setMode(storageAction.mode)\n        sendMessage({ text: storageAction.query, action: storageAction.action })\n      }\n    })\n    return () => unwatch()\n  }, [])\n\n  const handleSelectProvider = (provider: Provider) => {\n    track(PROVIDER_SELECTED_EVENT, {\n      provider_id: provider.id,\n      provider_type: provider.type,\n    })\n    setDefaultProvider(provider.id)\n  }\n\n  const getActionForMessage = (message: UIMessage) => {\n    if (message.role !== 'user') return undefined\n    const text = message.parts\n      .filter((part) => part.type === 'text')\n      .map((part) => part.text)\n      .join('')\n    return textToAction.get(text)\n  }\n\n  const resetConversation = () => {\n    track(CONVERSATION_RESET_EVENT, { message_count: messages.length })\n    stop()\n    const oldConversationId = conversationIdRef.current\n    conversationIdRef.current = crypto.randomUUID()\n    setMessages([])\n    setTextToAction(new Map())\n    setLiked({})\n    setDisliked({})\n\n    if (agentServerUrl && oldConversationId) {\n      fetch(`${agentServerUrl}/chat/${oldConversationId}`, {\n        method: 'DELETE',\n      }).catch(() => {})\n    }\n  }\n\n  return {\n    mode,\n    setMode,\n    messages,\n    sendMessage,\n    status,\n    stop,\n    providers,\n    selectedProvider,\n    isLoading: isLoadingProviders || isLoadingAgentUrl,\n    agentUrlError,\n    chatError,\n    handleSelectProvider,\n    getActionForMessage,\n    resetConversation,\n    liked,\n    onClickLike,\n    disliked,\n    onClickDislike,\n  }\n}\n","import { useEffect, useRef, useState } from 'react'\nimport { createBrowserOSAction } from '@/lib/chat-actions/types'\nimport { SIDEPANEL_AI_TRIGGERED_EVENT } from '@/lib/constants/analyticsEvents'\nimport { useJtbdPopup } from '@/lib/jtbd-popup/use-jtbd-popup'\nimport { track } from '@/lib/metrics/track'\nimport { ChatEmptyState } from './ChatEmptyState'\nimport { ChatError } from './ChatError'\nimport { ChatFooter } from './ChatFooter'\nimport { ChatHeader } from './ChatHeader'\nimport { ChatMessages } from './ChatMessages'\nimport { useChatSession } from './useChatSession'\n\n/**\n * @public\n */\nexport const Chat = () => {\n  const {\n    mode,\n    setMode,\n    messages,\n    sendMessage,\n    status,\n    stop,\n    providers,\n    selectedProvider,\n    isLoading,\n    agentUrlError,\n    chatError,\n    handleSelectProvider,\n    getActionForMessage,\n    resetConversation,\n    liked,\n    onClickLike,\n    disliked,\n    onClickDislike,\n  } = useChatSession()\n\n  const {\n    popupVisible,\n    recordMessageSent,\n    triggerIfEligible,\n    onTakeSurvey,\n    onDismiss: onDismissJtbdPopup,\n  } = useJtbdPopup()\n\n  const [input, setInput] = useState('')\n  const [attachedTabs, setAttachedTabs] = useState<chrome.tabs.Tab[]>([])\n  const messagesEndRef = useRef<HTMLDivElement>(null)\n  const [mounted, setMounted] = useState(false)\n\n  useEffect(() => {\n    setMounted(true)\n  }, [])\n\n  useEffect(() => {\n    ;(async () => {\n      const currentTab = (\n        await chrome.tabs.query({\n          active: true,\n          currentWindow: true,\n        })\n      ).filter((tab) => tab.url?.startsWith('http'))\n      setAttachedTabs(currentTab)\n    })()\n  }, [])\n\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })\n  }\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: scroll only when messages change\n  useEffect(() => {\n    scrollToBottom()\n  }, [messages])\n\n  // Trigger JTBD popup when AI finishes responding\n  const previousChatStatus = useRef(status)\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentionally only trigger on status change\n  useEffect(() => {\n    const aiWasProcessing =\n      previousChatStatus.current === 'streaming' ||\n      previousChatStatus.current === 'submitted'\n    const aiJustFinished = aiWasProcessing && status === 'ready'\n\n    if (aiJustFinished && messages.length > 0) {\n      triggerIfEligible()\n    }\n    previousChatStatus.current = status\n  }, [status])\n\n  const toggleTabSelection = (tab: chrome.tabs.Tab) => {\n    setAttachedTabs((prev) => {\n      const isSelected = prev.some((t) => t.id === tab.id)\n      if (isSelected) {\n        return prev.filter((t) => t.id !== tab.id)\n      }\n      return [...prev, tab]\n    })\n  }\n\n  const removeTab = (tabId?: number) => {\n    setAttachedTabs((prev) => prev.filter((t) => t.id !== tabId))\n  }\n\n  const executeMessage = (customMessageText?: string) => {\n    const messageText = customMessageText ? customMessageText : input.trim()\n    if (!messageText) return\n\n    recordMessageSent()\n\n    if (attachedTabs.length) {\n      const action = createBrowserOSAction({\n        mode,\n        message: messageText,\n        tabs: attachedTabs,\n      })\n      sendMessage({ text: messageText, action })\n    } else {\n      sendMessage({ text: messageText })\n    }\n    setInput('')\n    setAttachedTabs([])\n  }\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault()\n    if (messages.length === 0) {\n      track(SIDEPANEL_AI_TRIGGERED_EVENT, {\n        mode,\n        tabs_count: attachedTabs.length,\n      })\n    }\n    executeMessage()\n  }\n\n  const handleSuggestionClick = (suggestion: string) => {\n    executeMessage(suggestion)\n  }\n\n  if (isLoading || !selectedProvider) {\n    return (\n      <div className=\"flex h-screen w-screen items-center justify-center bg-background\">\n        <div className=\"h-5 w-5 animate-spin rounded-full border-2 border-muted-foreground border-t-transparent\" />\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"mx-auto flex h-screen w-screen flex-col bg-background text-foreground\">\n      <ChatHeader\n        selectedProvider={selectedProvider}\n        onSelectProvider={handleSelectProvider}\n        providers={providers}\n        onNewConversation={resetConversation}\n        hasMessages={messages.length > 0}\n      />\n\n      <main className=\"mt-4 flex h-full flex-1 flex-col space-y-4 overflow-y-auto\">\n        {messages.length === 0 ? (\n          <ChatEmptyState\n            mode={mode}\n            mounted={mounted}\n            onSuggestionClick={handleSuggestionClick}\n          />\n        ) : (\n          <ChatMessages\n            messages={messages}\n            status={status}\n            messagesEndRef={messagesEndRef}\n            getActionForMessage={getActionForMessage}\n            liked={liked}\n            onClickLike={onClickLike}\n            disliked={disliked}\n            onClickDislike={onClickDislike}\n            showJtbdPopup={popupVisible}\n            onTakeSurvey={onTakeSurvey}\n            onDismissJtbdPopup={onDismissJtbdPopup}\n          />\n        )}\n        {agentUrlError && <ChatError error={agentUrlError} />}\n        {chatError && <ChatError error={chatError} />}\n      </main>\n\n      <ChatFooter\n        mode={mode}\n        onModeChange={setMode}\n        input={input}\n        onInputChange={setInput}\n        onSubmit={handleSubmit}\n        status={status}\n        onStop={stop}\n        attachedTabs={attachedTabs}\n        onToggleTab={toggleTabSelection}\n        onRemoveTab={removeTab}\n      />\n    </div>\n  )\n}\n","import type { FC } from 'react'\nimport { HashRouter, Route, Routes } from 'react-router'\nimport { Chat } from './index/Chat'\n\nexport const App: FC = () => {\n  return (\n    <HashRouter>\n      <Routes>\n        <Route index element={<Chat />} />\n      </Routes>\n    </HashRouter>\n  )\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport '@/styles/global.css'\nimport { ThemeProvider } from '@/components/theme-provider.tsx'\nimport { Toaster } from '@/components/ui/sonner'\nimport { AnalyticsProvider } from '@/lib/analytics/AnalyticsProvider'\nimport { sentryRootErrorHandler } from '@/lib/sentry/sentryRootErrorHandler'\nimport { App } from './App'\n\nconst $root = document.getElementById('root')\n\nif ($root) {\n  ReactDOM.createRoot($root, sentryRootErrorHandler).render(\n    <React.StrictMode>\n      <AnalyticsProvider>\n        <ThemeProvider>\n          <App />\n          <Toaster />\n        </ThemeProvider>\n      </AnalyticsProvider>\n    </React.StrictMode>,\n  )\n}\n"],"names":["__iconNode","Brain","createLucideIcon","CircleDashed","Github","SquareStop","ThumbsDown","ThumbsUp","JTBD_POPUP_CONSTANTS","isEligible","state","useJtbdPopup","popupVisible","setPopupVisible","useState","useEffect","jtbdPopupStorage","val","newVal","recordMessageSent","useCallback","current","newState","triggerIfEligible","track","JTBD_POPUP_SHOWN_EVENT","onTakeSurvey","JTBD_POPUP_CLICKED_EVENT","onDismiss","JTBD_POPUP_DISMISSED_EVENT","CHAT_SUGGESTIONS","AGENT_SUGGESTIONS","ChatEmptyState","mode","mounted","onSuggestionClick","suggestions","jsxs","cn","jsx","Sparkles","suggestion","parseErrorMessage","message","text","parsed","url","ChatError","error","onRetry","isRateLimit","AlertCircle","Button","RefreshCw","ChatAttachedTabs","tabs","onRemoveTab","tab","Globe","X","TabMentionPopover","isOpen","filterText","selectedTabs","onToggleTab","onClose","anchorRef","allTabs","useAvailableTabs","focusedIndex","setFocusedIndex","listRef","useRef","selectedTabIds","useMemo","t","handleKeyDown","e","prev","Popover","open","PopoverAnchor","PopoverContent","Command","CommandList","CommandEmpty","CommandGroup","index","CommandItem","TabListItem","ChatInput","input","status","onInputChange","onSubmit","onStop","textareaRef","mentionState","setMentionState","inputRef","mentionStateRef","closeMention","currentInput","beforeMention","afterMention","newPosition","handleInputChange","value","cursorPosition","textAfterAt","spaceIndex","charBeforeCursor","textBeforeAt","isAtWordBoundary","handleClickOutside","target","Send","ChatModeToggle","onModeChange","MessageSquare","Zap","ChatFooter","attachedTabs","TabSelector","Layers","ChevronDown","ChatProviderSelector","children","providers","selectedProvider","onSelectProvider","setOpen","PopoverTrigger","CommandInput","provider","isSelected","BrowserOSIcon","ProviderIcon","Check","ChatHeader","onNewConversation","hasMessages","Plus","productRepositoryUrl","SettingsIcon","ThemeToggle","DEFAULT_SPRING_ANIMATION","STICK_TO_BOTTOM_OFFSET_PX","SIXTY_FPS_INTERVAL_MS","RETAIN_ANIMATION_DURATION_MS","mouseDown","useStickToBottom","options","escapedFromLock","updateEscapedFromLock","isAtBottom","updateIsAtBottom","isNearBottom","setIsNearBottom","optionsRef","isSelecting","selection","range","scrollRef","setIsAtBottom","setEscapedFromLock","lastCalculation","scrollTop","contentRef","targetScrollTop","calculatedScrollTop","scrollToBottom","scrollOptions","waitElapsed","behavior","mergeAnimations","ignoreEscapes","durationElapsed","startTarget","next","promise","tick","tickDelta","stopScroll","handleScroll","ignoreScrollToTop","lastScrollTop","isScrollingDown","isScrollingUp","handleWheel","deltaY","element","useRefCallback","scroll","content","previousHeight","entry","height","difference","animation","callback","deps","result","ref","animationCache","animations","instant","key","StickToBottomContext","createContext","useIsomorphicLayoutEffect","useLayoutEffect","StickToBottom","instance","resize","initial","mass","damping","stiffness","currentTargetScrollTop","contextRef","props","customTargetScrollTop","React.useCallback","elements","context","defaultInstance","useImperativeHandle","_jsx","Content","useStickToBottomContext","useContext","Conversation","className","ConversationContent","ConversationScrollButton","handleScrollToBottom","ArrowDownIcon","ShimmerComponent","Component","duration","spread","MotionComponent","motion","dynamicSpread","Shimmer","memo","ReasoningContext","useReasoning","AUTO_CLOSE_DELAY","MS_IN_S","Reasoning","isStreaming","defaultOpen","onOpenChange","durationProp","setIsOpen","useControllableState","setDuration","hasAutoClosed","setHasAutoClosed","startTime","setStartTime","timer","handleOpenChange","newOpen","Collapsible","getThinkingMessage","ReasoningTrigger","CollapsibleTrigger","Fragment","BrainIcon","ChevronDownIcon","ReasoningContent","CollapsibleContent","Streamdown","ChatMessageActions","messageId","messageText","liked","disliked","onClickLike","onClickDislike","dislikeDialogOpen","setDislikeDialogOpen","dislikeComment","setDislikeComment","feedbackSubmitted","handleLike","handleDislikeClick","handleDislikeSubmit","handleDislikeCancel","MessageActions","MessageAction","CopyIcon","AnimatePresence","CheckIcon","ThumbsUpIcon","ThumbsDownIcon","Dialog","DialogContent","DialogHeader","DialogTitle","DialogDescription","Input","DialogFooter","getMessageSegments","isLastMessage","segments","currentToolBatch","textSegmentCount","reasoningSegmentCount","flushToolBatch","i","part","toolPart","JtbdPopup","Message","MessageContent","MessageSquareHeart","TaskItem","Task","TaskTrigger","title","TriggerIcon","SearchIcon","TaskContent","ToolBatch","tools","isLastBatch","shouldBeOpen","hasUserInteracted","setHasUserInteracted","completedCount","isToolCompleted","onManualToggle","BotIcon","tool","ToolStatusIcon","formatToolName","name","s","isToolInProgress","isToolError","CheckCircle2","Loader2","XCircle","AttachedTabs","idx","AITabActionCard","action","FileText","BrowserOSActionCard","isAgent","Bot","UserActionMessage","ChatMessages","messages","messagesEndRef","getActionForMessage","showJtbdPopup","onDismissJtbdPopup","messageIndex","toolBatches","lastToolBatchKey","each","likeAction","dislikeAction","comment","segment","MessageResponse","marker","symbol","_a","_AISDKError","name14","cause","marker15","markerSymbol","AISDKError","getErrorMessage","name3","marker4","symbol4","_a4","InvalidArgumentError","argument","name6","marker7","symbol7","_a7","JSONParseError","name12","marker13","symbol13","_a13","_TypeValidationError","TypeValidationError","ParseError","noop","_arg","createParser","callbacks","onEvent","onError","onComment","incompleteLine","isFirstChunk","id","data","eventType","feed","newChunk","chunk","complete","incomplete","splitLines","line","parseLine","dispatchEvent","fieldSeparatorIndex","field","offset","processField","reset","lines","searchIndex","crIndex","lfIndex","lineEnd","EventSourceParserStream","parser","controller","event","createIdGenerator","prefix","size","alphabet","separator","generator","alphabetLength","chars","generateId","getRuntimeEnvironmentUserAgent","globalThisAny","_b","_c","normalizeHeaders","headers","normalized","withUserAgentSuffix","userAgentSuffixParts","normalizedHeaders","currentUserAgentHeader","suspectProtoRx","suspectConstructorRx","_parse","obj","filter","nodes","node","secureJsonParse","stackTraceLimit","validatorSymbol","validator","validate","isValidator","lazyValidator","createValidator","validator2","asValidator","standardSchemaValidator","standardSchema","validateTypes","schema","safeValidateTypes","TypeValidationError2","safeParseJSON","parseJsonEventStream","stream","resolve","addAdditionalPropertiesToJsonSchema","jsonSchema2","properties","property","item","getRelativePath","pathA","pathB","ignoreOverride","defaultOptions","getDefaultOptions","parseAnyDef","parseArrayDef","def","refs","res","ZodFirstPartyTypeKind","parseDef","parseBigintDef","check","parseBooleanDef","parseBrandedDef","_def","parseCatchDef","parseDateDef","overrideDateStrategy","strategy","integerDateParser","parseDefaultDef","parseEffectsDef","parseEnumDef","isJsonSchema7AllOfType","type","parseIntersectionDef","allOf","x","mergedAllOf","nestedSchema","additionalProperties","rest","parseLiteralDef","parsedType","emojiRegex","zodPatterns","parseStringDef","addFormat","addPattern","escapeLiteralCheckValue","literal","escapeNonAlphaNumeric","ALPHA_NUMERIC","source","regex","stringifyRegExpWithFlags","flags","pattern","isEscaped","inCharGroup","inCharRange","parseRecordDef","_d","_e","_f","ZodFirstPartyTypeKind2","keyType","parseMapDef","keys","values","parseNativeEnumDef","object","actualValues","parsedTypes","parseNeverDef","parseNullDef","primitiveMappings","parseUnionDef","types","types2","acc","uniqueTypes","a","x2","asAnyOf","anyOf","parseNullableDef","base","parseNumberDef","parseObjectDef","required","shape","propName","propDef","propOptional","safeIsOptional","parsedDef","decideAdditionalProperties","parseOptionalDef","innerSchema","parsePipelineDef","b","parsePromiseDef","parseSetDef","parseTupleDef","parseUndefinedDef","parseUnknownDef","parseReadonlyDef","selectParser","typeName","ZodFirstPartyTypeKind3","_","forceResolution","seenItem","overrideResult","seenSchema","get$ref","newItem","jsonSchemaOrGetter","addMeta","postProcessResult","getRefs","_options","currentPath","zodToJsonSchema","definitions","name2","schema2","_a2","main","combined","zod_to_json_schema_default","zod3Schema","zodSchema2","useReferences","jsonSchema","zod4Schema","z4.toJSONSchema","z4.safeParseAsync","isZod4Schema","zodSchema","schemaSymbol","isSchema","asSchema","__defProp","__export","all","name16","marker6","symbol6","_a6","NoObjectGeneratedError","AISDKError6","text2","response","usage","finishReason","VERSION","dataContentSchema","z.union","z.string","z.instanceof","z.custom","_a16","jsonValueSchema","z2.lazy","z2.union","z2.null","z2.string","z2.number","z2.boolean","z2.record","z2.array","providerMetadataSchema","z3.record","z3.string","textPartSchema","z4.object","z4.literal","z4.string","imagePartSchema","z4.union","z4.instanceof","filePartSchema","reasoningPartSchema","toolCallPartSchema","z4.unknown","z4.boolean","outputSchema","z4.discriminatedUnion","z4.array","toolResultPartSchema","systemModelMessageSchema","z5.object","z5.literal","z5.string","userModelMessageSchema","z5.union","z5.array","assistantModelMessageSchema","toolModelMessageSchema","uiMessageChunkSchema","z7.union","z7.strictObject","z7.literal","z7.string","z7.boolean","z7.unknown","z7.custom","z7.enum","isDataUIMessageChunk","mergeObjects","overrides","overridesValue","baseValue","isSourceObject","isTargetObject","fixJson","stack","lastValidIndex","literalStart","processValueStart","char","swapState","processAfterObjectValue","processAfterArrayValue","partialLiteral","parsePartialJson","jsonText","safeParseJSON2","isToolUIPart","isDynamicToolUIPart","isToolOrDynamicToolUIPart","getToolName","createStreamingUIMessageState","lastMessage","processUIMessageStream","messageMetadataSchema","dataPartSchemas","runUpdateMessageJob","onToolCall","onData","write","getToolInvocation","toolCallId","toolInvocation","invocation","getDynamicToolInvocation","updateToolPart","_a17","part2","anyOptions","anyPart","updateDynamicToolPart","_b2","updateMessageMetadata","metadata","mergedMetadata","textPart","reasoningPart","toolInvocations","partialToolCall","partialArgs","dataChunk","existingUIPart","chunkArg","consumeStream","reader","done","createIdGenerator2","createIdGenerator3","SerialJobExecutor","job","resolve2","reject","createIdGenerator4","output_exports","inputSchema","asSchema4","_exhaustiveCheck","parseResult","safeParseJSON4","validationResult","safeValidateTypes4","convertFileListToFileUIParts","files","file","dataUrl","readerEvent","HttpChatTransport","api","credentials","body","fetch2","prepareSendMessagesRequest","prepareReconnectToStreamRequest","abortSignal","resolvedBody","resolvedHeaders","resolvedCredentials","baseHeaders","preparedRequest","withUserAgentSuffix10","getRuntimeEnvironmentUserAgent3","DefaultChatTransport","parseJsonEventStream2","AbstractChat","generateId3","generateIdFunc","transport","onFinish","sendAutomaticallyWhen","uiMessage","m","tool2","output","errorText","trigger","isAbort","isDisconnect","isError","activeResponse","reconnect","err","throttle","function_","wait","timeoutId","lastCallTime","arguments_","now","timeSinceLastCall","delayForNextCall","throttleit","__accessCheck","member","msg","__privateGet","getter","__privateAdd","__privateSet","setter","fn","waitMs","throttleFunction","_messages","_status","_error","_messagesCallbacks","_statusCallbacks","_errorCallbacks","_callMessagesCallbacks","_callStatusCallbacks","_callErrorCallbacks","ReactChatState","initialMessages","onChange","throttleWaitMs","newStatus","newError","newMessages","_state","Chat","init","useChat","resume","chatRef","subscribeToMessages","update","useSyncExternalStore","setMessages","messagesParam","has","find","iter","tar","dequal","foo","bar","ctor","len","tmp","useDeepCompareMemoize","React.useRef","signalRef","React.useMemo","useDeepCompareEffect","dependencies","React.useEffect","searchActionsStorage","storage","useNotifyActiveTab","conversationId","lastTabIdRef","latestTabId","previousTabId","deactivateMessage","activateMessage","getLastMessageText","getResponseAndQueryFromMessageId","query","responseText","queryText","constructMcpServers","servers","eachServer","constructCustomServers","useChatSession","mcpServers","useMcpServers","enabledMcpServersRef","enabledCustomServersRef","llmProviders","selectedLlmProvider","isLoadingProviders","setDefaultProvider","useLlmProviders","personalization","usePersonalization","personalizationRef","agentServerUrl","isLoadingAgentUrl","agentUrlError","useAgentServerUrl","agentUrlRef","p","setMode","textToAction","setTextToAction","setLiked","setDisliked","conversationIdRef","MESSAGE_LIKE_EVENT","MESSAGE_DISLIKE_EVENT","selectedLlmProviderRef","modeRef","textToActionRef","baseSendMessage","stop","chatError","activeTab","currentMode","enabledMcpServers","customMcpServers","browserContext","compact","sendMessage","params","MESSAGE_SENT_EVENT","unwatch","storageAction","PROVIDER_SELECTED_EVENT","CONVERSATION_RESET_EVENT","oldConversationId","isLoading","handleSelectProvider","resetConversation","setInput","setAttachedTabs","setMounted","currentTab","previousChatStatus","toggleTabSelection","removeTab","tabId","executeMessage","customMessageText","createBrowserOSAction","handleSubmit","SIDEPANEL_AI_TRIGGERED_EVENT","handleSuggestionClick","App","HashRouter","Routes","Route","$root","ReactDOM","sentryRootErrorHandler","React","AnalyticsProvider","ThemeProvider","Toaster"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,18,19,30,31,32,33,34,35,36,37,38]}